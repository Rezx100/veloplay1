```
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  supabase: () => supabase2
});
import { createClient } from "@supabase/supabase-js";
var SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY, supabase2, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    SUPABASE_URL = process.env.SUPABASE_URL;
    SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
    SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;
    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
      throw new Error("Missing required Supabase environment variables");
    }
    supabase2 = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY || SUPABASE_ANON_KEY);
    console.log("Supabase URL:", SUPABASE_URL);
    console.log("Supabase Anon Key (first 5 chars):", SUPABASE_ANON_KEY.substring(0, 5) + "...");
    db = {};
  }
});

// server/storage.ts
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_db();
    DatabaseStorage = class {
      // User operations
      async getUser(id) {
        const { data, error } = await supabase2.from("users").select("*").eq("id", id).single();
        if (error || !data) return void 0;
        return {
          id: data.id,
          email: data.email,
          firstName: data.first_name,
          lastName: data.last_name,
          profileImageUrl: data.profile_image_url,
          isAdmin: data.is_admin,
          isVerified: data.is_verified,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async getUserById(id) {
        return this.getUser(id);
      }
      async getUserByEmail(email) {
        const { data, error } = await supabase2.from("users").select("*").eq("email", email).single();
        if (error || !data) return void 0;
        return {
          id: data.id,
          email: data.email,
          firstName: data.first_name,
          lastName: data.last_name,
          profileImageUrl: data.profile_image_url,
          isAdmin: data.is_admin,
          isVerified: data.is_verified,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async upsertUser(userData) {
        const user = {
          id: userData.id,
          email: userData.email,
          first_name: userData.firstName,
          last_name: userData.lastName,
          profile_image_url: userData.profileImageUrl,
          is_admin: userData.isAdmin,
          is_verified: userData.isVerified,
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        };
        const { data, error } = await supabase2.from("users").upsert(user).select().single();
        if (error) throw error;
        return {
          id: data.id,
          email: data.email,
          firstName: data.first_name,
          lastName: data.last_name,
          profileImageUrl: data.profile_image_url,
          isAdmin: data.is_admin,
          isVerified: data.is_verified,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async getAllUsers() {
        const { data, error } = await supabase2.from("users").select("*");
        if (error) throw error;
        return data.map((user) => ({
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          profileImageUrl: user.profile_image_url,
          isAdmin: user.is_admin,
          createdAt: user.created_at ? new Date(user.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: user.updated_at ? new Date(user.updated_at) : /* @__PURE__ */ new Date()
        }));
      }
      async updateUser(id, userData) {
        const updateData = { updated_at: (/* @__PURE__ */ new Date()).toISOString() };
        if (userData.email !== void 0) updateData.email = userData.email;
        if (userData.firstName !== void 0) updateData.first_name = userData.firstName;
        if (userData.lastName !== void 0) updateData.last_name = userData.lastName;
        if (userData.profileImageUrl !== void 0) updateData.profile_image_url = userData.profileImageUrl;
        if (userData.isAdmin !== void 0) updateData.is_admin = userData.isAdmin;
        const { data, error } = await supabase2.from("users").update(updateData).eq("id", id).select().single();
        if (error) throw error;
        return {
          id: data.id,
          email: data.email,
          firstName: data.first_name,
          lastName: data.last_name,
          profileImageUrl: data.profile_image_url,
          isAdmin: data.is_admin,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async updateUserVerificationStatus(id, isVerified) {
        const updateData = {
          is_verified: isVerified,
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        };
        const { error } = await supabase2.from("users").update(updateData).eq("id", id);
        if (error) {
          console.error("Error updating user verification status:", error);
          throw new Error(`Failed to update verification status: ${error.message}`);
        }
      }
      async deleteUser(id) {
        try {
          const user = await this.getUser(id);
          if (!user) {
            throw new Error("User not found");
          }
          console.log(`[USER DELETION] Starting deletion process for user ${id} (${user.email})`);
          const { error: dbError } = await supabase2.from("users").delete().eq("id", id);
          if (dbError) {
            console.error("[USER DELETION] Error deleting user from database:", dbError);
            throw new Error(`Failed to delete user from database: ${dbError.message}`);
          }
          console.log(`[USER DELETION] Successfully removed user from application database: ${id}`);
          let authDeletionSuccess = false;
          try {
            const { error: authError } = await supabase2.auth.admin.deleteUser(id);
            if (authError) {
              console.error("[USER DELETION] Error using admin.deleteUser:", authError);
            } else {
              console.log(`[USER DELETION] Successfully deleted user from auth using admin API: ${id}`);
              authDeletionSuccess = true;
            }
          } catch (authError) {
            console.error("[USER DELETION] Failed to use admin.deleteUser:", authError);
          }
          if (!authDeletionSuccess && process.env.DATABASE_URL) {
            try {
              console.log(`[USER DELETION] Attempting direct database connection for user ${id}`);
              const { Pool } = __require("pg");
              const pool = new Pool({
                connectionString: process.env.DATABASE_URL,
                ssl: { rejectUnauthorized: false }
              });
              await pool.query("DELETE FROM auth.users WHERE id = $1", [id]);
              await pool.end();
              console.log(`[USER DELETION] Successfully deleted user from Supabase using direct SQL: ${id}`);
              authDeletionSuccess = true;
            } catch (sqlError) {
              console.error("[USER DELETION] SQL deletion error:", sqlError);
            }
          }
          try {
            await supabase2.auth.admin.signOut(id);
            console.log(`[USER DELETION] Successfully signed out all user sessions: ${id}`);
          } catch (signOutError) {
            console.error("[USER DELETION] Failed to sign out user sessions:", signOutError);
          }
          console.log(`[USER DELETION] User ${id} (${user.email}) deletion process completed. Auth deletion success: ${authDeletionSuccess}`);
        } catch (error) {
          console.error("[USER DELETION] User deletion error:", error);
          throw error;
        }
      }
      async deleteSubscriptionsByUserId(userId) {
        const { error } = await supabase2.from("subscriptions").delete().eq("user_id", userId);
        if (error) {
          console.error("Error deleting user subscriptions:", error);
          throw new Error(`Failed to delete user subscriptions: ${error.message}`);
        }
      }
      // Stream operations
      async getStreamByGameId(gameId) {
        const { data, error } = await supabase2.from("streams").select("*").eq("game_id", gameId).single();
        if (error || !data) return void 0;
        return {
          id: data.id,
          gameId: data.game_id,
          streamUrl: data.stream_url,
          awayStreamUrl: data.away_stream_url,
          isActive: data.is_active,
          addedById: data.added_by_id,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async createStream(stream) {
        const streamData = {
          game_id: stream.gameId,
          stream_url: stream.streamUrl,
          away_stream_url: stream.awayStreamUrl,
          is_active: stream.isActive,
          added_by_id: stream.addedById
        };
        const { data, error } = await supabase2.from("streams").insert(streamData).select().single();
        if (error) throw error;
        return {
          id: data.id,
          gameId: data.game_id,
          streamUrl: data.stream_url,
          awayStreamUrl: data.away_stream_url,
          isActive: data.is_active,
          addedById: data.added_by_id,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async updateStream(id, data) {
        const updateData = { updated_at: (/* @__PURE__ */ new Date()).toISOString() };
        if (data.streamUrl !== void 0) updateData.stream_url = data.streamUrl;
        if (data.awayStreamUrl !== void 0) updateData.away_stream_url = data.awayStreamUrl;
        const { data: updatedStream, error } = await supabase2.from("streams").update(updateData).eq("id", id).select().single();
        if (error) throw error;
        return {
          id: updatedStream.id,
          gameId: updatedStream.game_id,
          streamUrl: updatedStream.stream_url,
          awayStreamUrl: updatedStream.away_stream_url,
          isActive: updatedStream.is_active,
          addedById: updatedStream.added_by_id,
          createdAt: updatedStream.created_at ? new Date(updatedStream.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: updatedStream.updated_at ? new Date(updatedStream.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async deleteStream(id) {
        const { error } = await supabase2.from("streams").delete().eq("id", id);
        if (error) throw error;
      }
      async getAllStreams() {
        const { data, error } = await supabase2.from("streams").select("*");
        if (error) throw error;
        return data.map((stream) => ({
          id: stream.id,
          gameId: stream.game_id,
          streamUrl: stream.stream_url,
          awayStreamUrl: stream.away_stream_url,
          isActive: stream.is_active,
          addedById: stream.added_by_id,
          createdAt: stream.created_at ? new Date(stream.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: stream.updated_at ? new Date(stream.updated_at) : /* @__PURE__ */ new Date()
        }));
      }
      // Subscription operations
      async getSubscriptionByUserId(userId) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const { data, error } = await supabase2.from("subscriptions").select("*").eq("user_id", userId).eq("is_active", true).gte("end_date", now).single();
        if (error || !data) return void 0;
        return {
          id: data.id,
          userId: data.user_id,
          planId: data.plan_id,
          startDate: data.start_date ? new Date(data.start_date) : /* @__PURE__ */ new Date(),
          endDate: data.end_date ? new Date(data.end_date) : /* @__PURE__ */ new Date(),
          isActive: data.is_active,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date()
        };
      }
      async createSubscription(subscription) {
        const subscriptionData = {
          user_id: subscription.userId,
          plan_id: subscription.planId,
          start_date: subscription.startDate?.toISOString(),
          end_date: subscription.endDate?.toISOString(),
          is_active: subscription.isActive
        };
        const { data, error } = await supabase2.from("subscriptions").insert(subscriptionData).select().single();
        if (error) throw error;
        return {
          id: data.id,
          userId: data.user_id,
          planId: data.plan_id,
          startDate: data.start_date ? new Date(data.start_date) : /* @__PURE__ */ new Date(),
          endDate: data.end_date ? new Date(data.end_date) : /* @__PURE__ */ new Date(),
          isActive: data.is_active,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date()
        };
      }
      async cancelSubscription(id) {
        const { error } = await supabase2.from("subscriptions").update({ is_active: false }).eq("id", id);
        if (error) throw error;
      }
      async getAllSubscriptions() {
        const { data, error } = await supabase2.from("subscriptions").select("*");
        if (error) throw error;
        return data.map((sub) => ({
          id: sub.id,
          userId: sub.user_id,
          planId: sub.plan_id,
          startDate: sub.start_date ? new Date(sub.start_date) : /* @__PURE__ */ new Date(),
          endDate: sub.end_date ? new Date(sub.end_date) : /* @__PURE__ */ new Date(),
          isActive: sub.is_active,
          createdAt: sub.created_at ? new Date(sub.created_at) : /* @__PURE__ */ new Date()
        }));
      }
      async adminUpdateSubscription(id, data) {
        const updateData = {};
        if (data.isActive !== void 0) updateData.is_active = data.isActive;
        if (data.endDate) updateData.end_date = data.endDate.toISOString();
        const { data: updatedSub, error } = await supabase2.from("subscriptions").update(updateData).eq("id", id).select().single();
        if (error) throw error;
        return {
          id: updatedSub.id,
          userId: updatedSub.user_id,
          planId: updatedSub.plan_id,
          startDate: updatedSub.start_date ? new Date(updatedSub.start_date) : /* @__PURE__ */ new Date(),
          endDate: updatedSub.end_date ? new Date(updatedSub.end_date) : /* @__PURE__ */ new Date(),
          isActive: updatedSub.is_active,
          createdAt: updatedSub.created_at ? new Date(updatedSub.created_at) : /* @__PURE__ */ new Date()
        };
      }
      // Subscription plan operations
      async getAllSubscriptionPlans() {
        const { data, error } = await supabase2.from("subscription_plans").select("*");
        if (error) throw error;
        return data.map((plan) => ({
          id: plan.id,
          name: plan.name,
          price: plan.price,
          durationDays: plan.duration_days,
          description: plan.description,
          features: plan.features,
          isPopular: plan.is_popular
        }));
      }
      async createSubscriptionPlan(plan) {
        const planData = {
          name: plan.name,
          price: plan.price,
          duration_days: plan.durationDays,
          description: plan.description,
          features: plan.features,
          is_popular: plan.isPopular
        };
        const { data, error } = await supabase2.from("subscription_plans").insert(planData).select().single();
        if (error) throw error;
        return {
          id: data.id,
          name: data.name,
          price: data.price,
          durationDays: data.duration_days,
          description: data.description,
          features: data.features,
          isPopular: data.is_popular
        };
      }
      async updateSubscriptionPlan(id, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.price !== void 0) updateData.price = data.price;
        if (data.durationDays !== void 0) updateData.duration_days = data.durationDays;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.features !== void 0) updateData.features = data.features;
        if (data.isPopular !== void 0) updateData.is_popular = data.isPopular;
        const { data: updatedPlan, error } = await supabase2.from("subscription_plans").update(updateData).eq("id", id).select().single();
        if (error) throw error;
        return {
          id: updatedPlan.id,
          name: updatedPlan.name,
          price: updatedPlan.price,
          durationDays: updatedPlan.duration_days,
          description: updatedPlan.description,
          features: updatedPlan.features,
          isPopular: updatedPlan.is_popular
        };
      }
      async deleteSubscriptionPlan(id) {
        const { error } = await supabase2.from("subscription_plans").delete().eq("id", id);
        if (error) throw error;
      }
      async getSubscriptionPlanById(id) {
        const { data, error } = await supabase2.from("subscription_plans").select().eq("id", id).single();
        if (error) {
          if (error.code === "PGRST116") {
            return void 0;
          }
          throw error;
        }
        return {
          id: data.id,
          name: data.name,
          price: data.price,
          durationDays: data.duration_days,
          description: data.description,
          features: data.features,
          isPopular: data.is_popular
        };
      }
      async getSubscriptionByPaymentIntentId(paymentIntentId) {
        const { data, error } = await supabase2.from("subscriptions").select("*").eq("stripe_payment_intent_id", paymentIntentId).single();
        if (error) {
          if (error.code === "PGRST116") {
            return void 0;
          }
          throw error;
        }
        if (!data) return void 0;
        return {
          id: data.id,
          userId: data.user_id,
          planId: data.plan_id,
          startDate: new Date(data.start_date),
          endDate: new Date(data.expires_at),
          // Map expires_at to endDate
          isActive: data.status === "active",
          // Map status to isActive
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date()
        };
      }
      // League operations
      async initializeLeagues() {
        try {
          const { data: existingLeagues, error: checkError } = await supabase2.from("leagues").select("id");
          if (checkError) {
            console.error("Error checking leagues table:", checkError);
            console.log("Will attempt to create leagues table via SQL Editor");
            return;
          }
          if (!existingLeagues || existingLeagues.length === 0) {
            const defaultLeagues = [\
              {\
                id: "nhl",\
                name: "NHL",\
                icon: "fa-hockey-puck",\
                background_color: "#0033A0",\
                enabled: true\
              },\
              {\
                id: "nba",\
                name: "NBA",\
                icon: "fa-basketball-ball",\
                background_color: "#C9082A",\
                enabled: true\
              },\
              {\
                id: "nfl",\
                name: "NFL",\
                icon: "fa-football-ball",\
                background_color: "#013369",\
                enabled: true\
              },\
              {\
                id: "mlb",\
                name: "MLB",\
                icon: "fa-baseball-ball",\
                background_color: "#002D72",\
                enabled: true\
              }\
            ];
            const { error: insertError } = await supabase2.from("leagues").upsert(defaultLeagues, { onConflict: "id" });
            if (insertError) {
              console.error("Error initializing leagues:", insertError);
            } else {
              console.log("Successfully initialized leagues");
            }
          } else {
            console.log("Leagues already initialized");
          }
        } catch (error) {
          console.error("Exception in initializeLeagues:", error);
        }
      }
      // OTP operations
      async createOtp(data) {
        const { data: otp, error } = await supabase2.from("otp_codes").insert(data).select().single();
        if (error) {
          console.error("Error creating OTP:", error);
          throw new Error(`Failed to create OTP: ${error.message}`);
        }
        return otp;
      }
      async getOtpByUserIdAndCode(userId, code) {
        const { data: otp, error } = await supabase2.from("otp_codes").select().eq("userId", userId).eq("code", code).eq("isUsed", false).single();
        if (error) {
          if (error.code === "PGRST116") {
            return void 0;
          }
          console.error("Error fetching OTP:", error);
          throw new Error(`Failed to fetch OTP: ${error.message}`);
        }
        return otp;
      }
      async markOtpAsUsed(id) {
        const { error } = await supabase2.from("otp_codes").update({ isUsed: true }).eq("id", id);
        if (error) {
          console.error("Error marking OTP as used:", error);
          throw new Error(`Failed to mark OTP as used: ${error.message}`);
        }
      }
      async getActiveOtpsByUserId(userId) {
        const now = /* @__PURE__ */ new Date();
        const { data: otps, error } = await supabase2.from("otp_codes").select().eq("userId", userId).eq("isUsed", false).gt("expiresAt", now.toISOString());
        if (error) {
          console.error("Error fetching active OTPs:", error);
          throw new Error(`Failed to fetch active OTPs: ${error.message}`);
        }
        return otps || [];
      }
      // Game Alert operations
      async createGameAlert(alert) {
        const existingAlert = await this.getGameAlertByUserAndGame(alert.userId, alert.gameId);
        if (existingAlert) {
          console.log("\u2705 Alert already exists, returning existing alert:", existingAlert);
          return existingAlert;
        }
        console.log("\u{1F4DD} Creating game alert using Supabase client");
        const alertId = Date.now();
        const { data, error } = await supabase2.from("game_alerts").insert({
          id: alertId,
          user_id: alert.userId,
          game_id: alert.gameId,
          notify_minutes_before: alert.notifyMinutesBefore || 30,
          is_notified: false,
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        }).select().single();
        if (error) {
          console.error("Supabase error creating alert:", error);
          throw new Error(`Failed to create game alert: ${error.message}`);
        }
        console.log("\u2705 Alert created successfully:", data);
        return {
          id: data.id,
          userId: data.user_id,
          gameId: data.game_id,
          notifyMinutesBefore: data.notify_minutes_before,
          isNotified: data.is_notified,
          createdAt: data.created_at
        };
      }
      async getGameAlertsByUserId(userId) {
        const { data, error } = await supabase2.from("game_alerts").select("*").eq("user_id", userId);
        if (error) {
          console.error("Error fetching game alerts:", error);
          throw new Error(`Failed to fetch game alerts: ${error.message}`);
        }
        return (data || []).map((alert) => ({
          id: alert.id,
          userId: alert.user_id,
          gameId: alert.game_id,
          notifyMinutesBefore: alert.notify_minutes_before,
          isNotified: alert.is_notified,
          createdAt: alert.created_at ? new Date(alert.created_at) : /* @__PURE__ */ new Date()
        }));
      }
      async getGameAlertByUserAndGame(userId, gameId) {
        const { data, error } = await supabase2.from("game_alerts").select("*").eq("user_id", userId).eq("game_id", gameId).single();
        if (error) {
          if (error.code === "PGRST116") {
            return void 0;
          }
          console.error("Error fetching game alert:", error);
          throw new Error(`Failed to fetch game alert: ${error.message}`);
        }
        return {
          id: data.id,
          userId: data.user_id,
          gameId: data.game_id,
          notifyMinutesBefore: data.notify_minutes_before,
          isNotified: data.is_notified,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date()
        };
      }
      async updateGameAlertNotificationStatus(id, isNotified) {
        const { data, error } = await supabase2.from("game_alerts").update({ is_notified: isNotified }).eq("id", id).select().single();
        if (error) {
          console.error("Error updating game alert notification status:", error);
          throw new Error(`Failed to update game alert notification status: ${error.message}`);
        }
        return {
          id: data.id,
          userId: data.user_id,
          gameId: data.game_id,
          notifyMinutesBefore: data.notify_minutes_before,
          isNotified: data.is_notified,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date()
        };
      }
      async deleteGameAlert(id) {
        const { error } = await supabase2.from("game_alerts").delete().eq("id", id);
        if (error) {
          console.error("Error deleting game alert:", error);
          throw new Error(`Failed to delete game alert: ${error.message}`);
        }
      }
      // Network Channel operations
      async getNetworkChannels() {
        const { data, error } = await supabase2.from("network_channels").select("*").order("id", { ascending: true });
        if (error) {
          console.error("Error fetching network channels:", error);
          throw error;
        }
        return data.map((channel) => ({
          id: channel.id,
          name: channel.name,
          icon: channel.icon,
          description: channel.description,
          isActive: channel.is_active,
          isPremium: channel.is_premium,
          createdAt: channel.created_at ? new Date(channel.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: channel.updated_at ? new Date(channel.updated_at) : /* @__PURE__ */ new Date()
        }));
      }
      async getNetworkChannelById(id) {
        const { data, error } = await supabase2.from("network_channels").select("*").eq("id", id).single();
        if (error || !data) return void 0;
        return {
          id: data.id,
          name: data.name,
          icon: data.icon,
          description: data.description,
          isActive: data.is_active,
          isPremium: data.is_premium,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async createNetworkChannel(channel) {
        const channelData = {
          id: channel.id,
          // Use the provided ID (important for stream URL generation)
          name: channel.name,
          icon: channel.icon,
          description: channel.description,
          is_active: channel.isActive !== void 0 ? channel.isActive : true,
          is_premium: channel.isPremium !== void 0 ? channel.isPremium : false
        };
        const { data, error } = await supabase2.from("network_channels").insert(channelData).select().single();
        if (error) {
          console.error("Error creating network channel:", error);
          throw error;
        }
        return {
          id: data.id,
          name: data.name,
          icon: data.icon,
          description: data.description,
          isActive: data.is_active,
          isPremium: data.is_premium,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async updateNetworkChannel(id, channelData) {
        const updateData = { updated_at: (/* @__PURE__ */ new Date()).toISOString() };
        if (channelData.name !== void 0) updateData.name = channelData.name;
        if (channelData.icon !== void 0) updateData.icon = channelData.icon;
        if (channelData.description !== void 0) updateData.description = channelData.description;
        if (channelData.isActive !== void 0) updateData.is_active = channelData.isActive;
        if (channelData.isPremium !== void 0) updateData.is_premium = channelData.isPremium;
        if (channelData.id !== void 0) updateData.id = channelData.id;
        const { data, error } = await supabase2.from("network_channels").update(updateData).eq("id", id).select().single();
        if (error) {
          console.error("Error updating network channel:", error);
          throw error;
        }
        return {
          id: data.id,
          name: data.name,
          icon: data.icon,
          description: data.description,
          isActive: data.is_active,
          isPremium: data.is_premium,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async deleteNetworkChannel(id) {
        const { error } = await supabase2.from("network_channels").delete().eq("id", id);
        if (error) {
          console.error("Error deleting network channel:", error);
          throw error;
        }
      }
      /* Stream Sources API - for m3u8 URL management */
      async getAllStreamSources() {
        const { data, error } = await supabase2.from("stream_sources").select("*").order("id", { ascending: true });
        if (error) throw error;
        return data.map((source) => ({
          id: source.id,
          name: source.name,
          url: source.url,
          description: source.description,
          isActive: source.is_active,
          leagueId: source.league_id,
          priority: source.priority,
          teamName: source.team_name,
          createdAt: source.created_at ? new Date(source.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: source.updated_at ? new Date(source.updated_at) : /* @__PURE__ */ new Date()
        }));
      }
      async getStreamSourceById(id) {
        const { data, error } = await supabase2.from("stream_sources").select("*").eq("id", id).single();
        if (error) {
          if (error.code === "PGRST116") return void 0;
          throw error;
        }
        return {
          id: data.id,
          name: data.name,
          url: data.url,
          description: data.description,
          isActive: data.is_active,
          leagueId: data.league_id,
          priority: data.priority,
          teamName: data.team_name,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async createStreamSource(streamSource) {
        const streamSourceData = {
          name: streamSource.name,
          url: streamSource.url,
          description: streamSource.description,
          is_active: streamSource.isActive,
          league_id: streamSource.leagueId,
          priority: streamSource.priority || 1,
          team_name: streamSource.teamName
        };
        const { data, error } = await supabase2.from("stream_sources").insert(streamSourceData).select().single();
        if (error) throw error;
        return {
          id: data.id,
          name: data.name,
          url: data.url,
          description: data.description,
          isActive: data.is_active,
          leagueId: data.league_id,
          priority: data.priority,
          teamName: data.team_name,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async updateStreamSource(id, streamSource) {
        const existingSource = await this.getStreamSourceById(id);
        if (!existingSource) return void 0;
        const streamSourceData = {};
        if (streamSource.name !== void 0) streamSourceData.name = streamSource.name;
        if (streamSource.url !== void 0) streamSourceData.url = streamSource.url;
        if (streamSource.description !== void 0) streamSourceData.description = streamSource.description;
        if (streamSource.isActive !== void 0) streamSourceData.is_active = streamSource.isActive;
        if (streamSource.leagueId !== void 0) streamSourceData.league_id = streamSource.leagueId;
        if (streamSource.priority !== void 0) streamSourceData.priority = streamSource.priority;
        if (streamSource.teamName !== void 0) streamSourceData.team_name = streamSource.teamName;
        streamSourceData.updated_at = (/* @__PURE__ */ new Date()).toISOString();
        const { data, error } = await supabase2.from("stream_sources").update(streamSourceData).eq("id", id).select().single();
        if (error) throw error;
        return {
          id: data.id,
          name: data.name,
          url: data.url,
          description: data.description,
          isActive: data.is_active,
          leagueId: data.league_id,
          priority: data.priority,
          teamName: data.team_name,
          createdAt: data.created_at ? new Date(data.created_at) : /* @__PURE__ */ new Date(),
          updatedAt: data.updated_at ? new Date(data.updated_at) : /* @__PURE__ */ new Date()
        };
      }
      async deleteStreamSource(id) {
        const existingSource = await this.getStreamSourceById(id);
        if (!existingSource) return false;
        const { error } = await supabase2.from("stream_sources").delete().eq("id", id);
        if (error) throw error;
        return true;
      }
      async deleteAllStreamSources() {
        const { error } = await supabase2.from("stream_sources").delete().gte("id", 0);
        if (error) {
          console.error("Error deleting all stream sources:", error);
          throw new Error("Failed to delete all stream sources");
        }
      }
      /* End of Stream Sources API */
      // Additional Game Alert methods
      async getUnsentGameAlerts() {
        const { data, error } = await supabase2.from("game_alerts").select("*").eq("is_notified", false);
        if (error) {
          console.error("Error fetching unsent game alerts:", error);
          throw new Error(`Failed to fetch unsent game alerts: ${error.message}`);
        }
        return data.map((alert) => ({
          id: alert.id,
          userId: alert.user_id,
          gameId: alert.game_id,
          notifyMinutesBefore: alert.notify_minutes_before,
          isNotified: alert.is_notified,
          createdAt: alert.created_at ? new Date(alert.created_at) : /* @__PURE__ */ new Date()
        }));
      }
      async markGameAlertAsSent(id) {
        const { error } = await supabase2.from("game_alerts").update({ is_notified: true }).eq("id", id);
        if (error) {
          console.error("Error marking game alert as sent:", error);
          throw new Error(`Failed to mark game alert as sent: ${error.message}`);
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/supabaseAuth.ts
import { createClient as createClient2 } from "@supabase/supabase-js";
var SUPABASE_URL2, SUPABASE_SERVICE_KEY2, supabaseClient, isAuthenticated;
var init_supabaseAuth = __esm({
  "server/supabaseAuth.ts"() {
    "use strict";
    init_storage();
    SUPABASE_URL2 = "https://cozhbakfzyykdcmccxnb.supabase.co";
    SUPABASE_SERVICE_KEY2 = process.env.SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvemhiYWtmenl5a2RjbWNjeG5iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY4Mzg4OTYsImV4cCI6MjA2MjQxNDg5Nn0.K9KyGR1p4qMek3-MdqZLyu0tMd24fuolcGdJNuWVY1w";
    console.log("Supabase URL:", SUPABASE_URL2);
    console.log("Supabase Anon Key (first 5 chars):", SUPABASE_SERVICE_KEY2.substring(0, 5) + "...");
    supabaseClient = createClient2(SUPABASE_URL2, SUPABASE_SERVICE_KEY2);
    isAuthenticated = async (req, res, next) => {
      try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const token = authHeader.split(" ")[1];
        const { data: { user }, error } = await supabaseClient.auth.getUser(token);
        if (error || !user) {
          return res.status(401).json({ message: "Invalid or expired token" });
        }
        let dbUser = await storage.getUserById(user.id);
        if (!dbUser) {
          dbUser = await storage.upsertUser({
            id: user.id,
            email: user.email || "",
            firstName: user.user_metadata.first_name,
            lastName: user.user_metadata.last_name,
            profileImageUrl: user.user_metadata.avatar_url,
            isAdmin: false,
            isVerified: true
            // Only verified users reach this point
          });
        }
        if (!dbUser.isVerified) {
          console.log(`\u{1F6AB} SECURITY BLOCK: User ${dbUser.email} has is_verified=FALSE, denying access`);
          return res.status(403).json({
            message: "Email verification required. Please verify your email address before accessing this content.",
            requiresVerification: true
          });
        }
        req.user = dbUser;
        next();
      } catch (error) {
        console.error("Authentication error:", error);
        return res.status(401).json({ message: "Authentication failed" });
      }
    };
  }
});

// server/adminMiddleware.ts
var isAdmin;
var init_adminMiddleware = __esm({
  "server/adminMiddleware.ts"() {
    "use strict";
    init_storage();
    isAdmin = async (req, res, next) => {
      try {
        if (!req.user) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const userId = req.user.id;
        const user = await storage.getUser(userId);
        if (!user?.isAdmin) {
          return res.status(403).json({ message: "Admin access required" });
        }
        next();
      } catch (error) {
        console.error("Admin verification error:", error);
        return res.status(500).json({ message: "Server error during authorization check" });
      }
    };
  }
});

// server/redis.ts
import { createClient as createClient3 } from "redis";
var redisClient, redis, RedisCache;
var init_redis = __esm({
  "server/redis.ts"() {
    "use strict";
    redisClient = createClient3({
      username: "default",
      password: process.env.REDIS_PASSWORD || "VssHFXrVNn5ZQ99jIHk0zuNx1ciJGkXY",
      socket: {
        host: "redis-18177.c322.us-east-1-2.ec2.redns.redis-cloud.com",
        port: 18177
      }
    });
    redisClient.on("error", (err) => {
      console.log("\u274C Redis Client Error:", err.message);
    });
    redisClient.on("connect", () => {
      console.log("\u{1F50C} Connecting to Redis Cloud...");
    });
    redisClient.on("ready", () => {
      console.log("\u2705 Redis Cloud connected successfully!");
    });
    redisClient.on("end", () => {
      console.log("\u{1F50C} Redis connection closed");
    });
    redisClient.connect().catch((err) => {
      console.log("\u274C Failed to connect to Redis Cloud:", err.message);
    });
    redis = {
      async ping() {
        try {
          return await redisClient.ping();
        } catch (error) {
          console.log("Redis ping failed:", error);
          return "PONG";
        }
      },
      async set(key2, value, mode, duration) {
        try {
          if (mode === "EX" && duration) {
            return await redisClient.setEx(key2, duration, value);
          }
          return await redisClient.set(key2, value);
        } catch (error) {
          console.log("Redis set failed:", error);
          return null;
        }
      },
      async get(key2) {
        try {
          return await redisClient.get(key2);
        } catch (error) {
          console.log("Redis get failed:", error);
          return null;
        }
      },
      async del(key2) {
        try {
          return await redisClient.del(key2);
        } catch (error) {
          console.log("Redis del failed:", error);
          return 0;
        }
      },
      async info(section) {
        try {
          return await redisClient.info(section);
        } catch (error) {
          console.log("Redis info failed:", error);
          return "";
        }
      },
      disconnect() {
        return redisClient.disconnect();
      }
    };
    RedisCache = class {
      static async cacheGameData(gameId, gameData, ttlSeconds = 300) {
        try {
          const key2 = `game:${gameId}`;
          await redis.set(key2, JSON.stringify(gameData), "EX", ttlSeconds);
          console.log(`\u{1F4E6} Redis: Cached game ${gameId} for ${ttlSeconds}s`);
        } catch (error) {
          console.log(`Error caching game ${gameId}:`, error);
        }
      }
      static async getGameData(gameId) {
        try {
          const key2 = `game:${gameId}`;
          const cached = await redis.get(key2);
          if (cached) {
            console.log(`\u26A1 Retrieved game ${gameId} from Redis cache`);
            return JSON.parse(cached);
          }
          return null;
        } catch (error) {
          console.log(`Error getting cached game ${gameId}:`, error);
          return null;
        }
      }
      static async cacheGamesList(date2, games, ttlSeconds = 180) {
        try {
          const key2 = `all-games:${date2}:true`;
          await redis.set(key2, JSON.stringify(games), "EX", ttlSeconds);
          console.log(`\u{1F4E6} Redis: Cached ${games.length} games for ${date2}`);
        } catch (error) {
          console.log(`Error setting cache key ${key}:`, error);
        }
      }
      static async getGamesList(date2) {
        try {
          const key2 = `all-games:${date2}:true`;
          const cached = await redis.get(key2);
          if (cached) {
            const games = JSON.parse(cached);
            console.log(`\u26A1 Retrieved ${games.length} games from Redis cache for ${date2}`);
            return games;
          }
          return null;
        } catch (error) {
          console.log(`Error getting cache key ${key}:`, error);
          return null;
        }
      }
      static async cacheStreamUrl(gameId, streamData, ttlSeconds = 600) {
        try {
          const key2 = `stream:${gameId}`;
          await redis.set(key2, JSON.stringify(streamData), "EX", ttlSeconds);
          console.log(`\u{1F4E6} Redis: Cached stream for game ${gameId}`);
        } catch (error) {
          console.log(`Error caching stream ${gameId}:`, error);
        }
      }
      static async getStreamUrl(gameId) {
        try {
          const key2 = `stream:${gameId}`;
          const cached = await redis.get(key2);
          if (cached) {
            console.log(`\u26A1 Retrieved stream for game ${gameId} from Redis cache`);
            return JSON.parse(cached);
          }
          return null;
        } catch (error) {
          console.log(`Error getting cached stream ${gameId}:`, error);
          return null;
        }
      }
      static async cacheUserSession(userId, sessionData, ttlSeconds = 3600) {
        try {
          const key2 = `session:${userId}`;
          await redis.set(key2, JSON.stringify(sessionData), "EX", ttlSeconds);
          console.log(`\u{1F4E6} Redis: Cached session for user ${userId}`);
        } catch (error) {
          console.log(`Error caching session ${userId}:`, error);
        }
      }
      static async getUserSession(userId) {
        try {
          const key2 = `session:${userId}`;
          const cached = await redis.get(key2);
          if (cached) {
            console.log(`\u26A1 Retrieved session for user ${userId} from Redis cache`);
            return JSON.parse(cached);
          }
          return null;
        } catch (error) {
          console.log(`Error getting cached session ${userId}:`, error);
          return null;
        }
      }
      static async set(key2, value, ttlSeconds) {
        try {
          const stringValue = typeof value === "string" ? value : JSON.stringify(value);
          if (ttlSeconds) {
            await redis.set(key2, stringValue, "EX", ttlSeconds);
          } else {
            await redis.set(key2, stringValue);
          }
          console.log(`\u{1F4E6} Redis: Set ${key2}`);
        } catch (error) {
          console.log(`Error setting ${key2}:`, error);
        }
      }
      static async get(key2) {
        try {
          const value = await redis.get(key2);
          if (value) {
            console.log(`\u26A1 Retrieved ${key2} from Redis cache`);
            try {
              return JSON.parse(value);
            } catch {
              return value;
            }
          }
          return null;
        } catch (error) {
          console.log(`Error getting ${key2}:`, error);
          return null;
        }
      }
      static async del(key2) {
        try {
          await redis.del(key2);
          console.log(`\u{1F5D1}\uFE0F Redis: Deleted ${key2}`);
        } catch (error) {
          console.log(`Error deleting ${key2}:`, error);
        }
      }
      static async clearAll() {
        try {
          console.log("\u{1F5D1}\uFE0F Redis: Clear all requested (not implemented for safety)");
        } catch (error) {
          console.log("Error clearing Redis cache:", error);
        }
      }
    };
  }
});

// server/espnApi.ts
var espnApi_exports = {};
__export(espnApi_exports, {
  getAllGames: () => getAllGames,
  getCurrentEasternTime: () => getCurrentEasternTime,
  getGameById: () => getGameById,
  getLeagueGames: () => getLeagueGames,
  getRawESPNData: () => getRawESPNData
});
import fetch2 from "node-fetch";
import { format } from "date-fns";
function formatDateForESPN(date2) {
  const etDate = new Date(date2.toLocaleString("en-US", { timeZone: "America/New_York" }));
  const year = etDate.getFullYear();
  const month = etDate.getMonth() + 1;
  const day = etDate.getDate();
  const dateStr = `${year}${String(month).padStart(2, "0")}${String(day).padStart(2, "0")}`;
  console.log(`Formatting date ${date2.toISOString()} to ESPN format: ${dateStr} (ET: ${month}/${day}/${year})`);
  return dateStr;
}
function getCurrentEasternTime() {
  const now = /* @__PURE__ */ new Date();
  const etDateString = now.toLocaleString("en-US", { timeZone: "America/New_York" });
  const etDate = new Date(etDateString);
  console.log(`Time conversion: UTC ${now.toISOString()} \u2192 Eastern Time ${etDate.toLocaleString("en-US", { timeZone: "America/New_York" })}`);
  return etDate;
}
function isGameInWarmup(gameDate) {
  try {
    const gameTime = new Date(gameDate);
    const now = /* @__PURE__ */ new Date();
    const timeDiffMs = gameTime.getTime() - now.getTime();
    const timeDiffMinutes = timeDiffMs / (1e3 * 60);
    console.log(
      `Game warmup check:
      - Game time (UTC): ${gameTime.toISOString()}
      - Current time (UTC): ${now.toISOString()}
      - Time difference: ${Math.round(timeDiffMinutes)} minutes
      - Warmup status: ${timeDiffMinutes <= 30 && timeDiffMinutes > 0 ? "In warmup" : "Not in warmup"}`
    );
    return timeDiffMinutes <= 30 && timeDiffMinutes > 0;
  } catch (error) {
    console.error("Error calculating warmup status:", error);
    return false;
  }
}
function determineGameState(espnGame) {
  let state = "pre";
  let statusDetail = espnGame.note || "";
  let isWarmup = false;
  try {
    if (espnGame.statusType) {
      if (espnGame.statusType.state === "in" || espnGame.statusType.state === "live") {
        state = "in";
      } else if (espnGame.statusType.completed === true || espnGame.statusType.state === "post") {
        state = "post";
      }
      statusDetail = espnGame.statusType.detail || espnGame.statusType.shortDetail || espnGame.statusType.description || statusDetail;
      isWarmup = typeof statusDetail === "string" && statusDetail.toLowerCase().includes("warmup") || !!(espnGame.statusType.description && typeof espnGame.statusType.description === "string" && espnGame.statusType.description.toLowerCase().includes("warmup"));
    } else {
      if (espnGame.status === "in" || espnGame.status === "live" || espnGame.status === "in_progress") {
        state = "in";
      } else if (espnGame.status === "post" || espnGame.status === "final" || espnGame.status === "complete" || espnGame.status === "completed" || espnGame.status.toLowerCase().includes("final") || espnGame.status.toLowerCase().includes("complet")) {
        state = "post";
      }
      isWarmup = typeof espnGame.status === "string" && espnGame.status.toLowerCase().includes("warmup") || typeof statusDetail === "string" && statusDetail.toLowerCase().includes("warmup");
    }
    if (state === "pre" && !isWarmup && espnGame.date) {
      isWarmup = isGameInWarmup(espnGame.date);
      const now = /* @__PURE__ */ new Date();
      const gameTime = new Date(espnGame.date);
      const timeDiffMs = now.getTime() - gameTime.getTime();
      const timeDiffMinutes = timeDiffMs / (1e3 * 60);
      console.log(`Game ${espnGame.id} time check:
          - Game at: ${gameTime.toISOString()}
          - Current: ${now.toISOString()}
          - Minutes since scheduled start: ${Math.round(timeDiffMinutes)}`);
      if (timeDiffMinutes > 5) {
        state = "in";
        console.log(`Game ${espnGame.id} should have started ${Math.round(timeDiffMinutes)} minutes ago - marking as in progress`);
      } else if (timeDiffMinutes > 0) {
        state = "in";
        console.log(`Game ${espnGame.id} is starting now (${Math.round(timeDiffMinutes)} minutes past scheduled time)`);
      }
      if (state === "delayed" && statusDetail && !statusDetail.toLowerCase().includes("delay")) {
        statusDetail = `Delayed - ${statusDetail}`;
      } else if (state === "delayed" && !statusDetail) {
        statusDetail = "Delayed";
      }
      if (now.getTime() > gameTime.getTime() + 3 * 60 * 60 * 1e3) {
        state = "postponed";
        if (!statusDetail.toLowerCase().includes("postpon") && !statusDetail.toLowerCase().includes("cancel")) {
          statusDetail = statusDetail ? `Possible Postponement - ${statusDetail}` : "Possible Postponement";
        }
        console.log(`Game ${espnGame.id} marked as POSTPONED - ${Math.floor((now.getTime() - gameTime.getTime()) / (60 * 60 * 1e3))} hours past scheduled start`);
      }
    }
    if (state === "post" && !statusDetail.toLowerCase().includes("final")) {
      statusDetail = statusDetail ? `Final - ${statusDetail}` : "Final";
    }
    if (isWarmup && typeof statusDetail === "string" && !statusDetail.toLowerCase().includes("warmup")) {
      statusDetail = `Warmup - ${statusDetail}`;
    }
    return { state, isWarmup, statusDetail };
  } catch (error) {
    console.error("Error determining game state:", error);
    return { state, isWarmup, statusDetail };
  }
}
async function getRawESPNData(leagueId, date2) {
  try {
    const { sport, league } = LEAGUES[leagueId];
    let url = `${ESPN_API_BASE}?sport=${sport}&league=${league}`;
    if (date2) {
      url += `&date=${formatDateForESPN(date2)}`;
    }
    console.log(`Fetching ESPN API URL: ${url}`);
    const response = await fetch2(url);
    if (!response.ok) {
      throw new Error(`ESPN API error: ${response.status} - ${response.statusText}`);
    }
    return await response.json();
  } catch (error) {
    console.error(`Error fetching raw ${leagueId} data:`, error);
    throw error;
  }
}
async function getLeagueGames(leagueId, date2) {
  try {
    const { sport, league } = LEAGUES[leagueId];
    const dateToUse = date2 || /* @__PURE__ */ new Date();
    const formattedDate = formatDateForESPN(dateToUse);
    const url = `${ESPN_API_BASE}?sport=${sport}&league=${league}&dates=${formattedDate}`;
    console.log(`Fetching games for date: ${dateToUse.toISOString()}, formatted as: ${formattedDate}`);
    console.log(`ESPN API URL: ${url}`);
    const response = await fetch2(url);
    if (!response.ok) {
      throw new Error(`ESPN API error: ${response.status} - ${response.statusText}`);
    }
    const data = await response.json();
    if (!data.sports?.[0]?.leagues?.[0]?.events) {
      console.log(`No events found for ${leagueId} on ${formattedDate}`);
      return [];
    }
    const espnGames = data.sports[0].leagues[0].events;
    console.log(`Found ${espnGames.length} games for ${leagueId} on ${formattedDate}`);
    let apiGames = mapESPNGamesToGameModel(espnGames, leagueId);
    console.log(`Returning ${apiGames.length} games for ${leagueId}`);
    return apiGames;
  } catch (error) {
    console.error(`Error fetching ${leagueId} games:`, error);
    return [];
  }
}
async function getAllGames(date2, includeTomorrow = false) {
  try {
    const leagues2 = Object.keys(LEAGUES);
    const dateToUse = date2 || /* @__PURE__ */ new Date();
    const formattedDate = formatDateForESPN(dateToUse);
    const cacheKey = `all-games:${formattedDate}:${includeTomorrow}`;
    const cachedGames = await RedisCache.get(cacheKey);
    if (cachedGames) {
      console.log(`\u26A1 Retrieved ${cachedGames.length} games from Redis cache for ${formattedDate}`);
      return cachedGames;
    }
    console.log(`Fetching games for date: ${dateToUse.toISOString()}`);
    const allGamesPromises = leagues2.map((leagueId) => getLeagueGames(leagueId, dateToUse));
    if (includeTomorrow) {
      const tomorrow = new Date(dateToUse);
      tomorrow.setDate(tomorrow.getDate() + 1);
      console.log(`Also fetching games for tomorrow: ${tomorrow.toISOString()}`);
      const tomorrowGamesPromises = leagues2.map((leagueId) => getLeagueGames(leagueId, tomorrow));
      allGamesPromises.push(...tomorrowGamesPromises);
    }
    const results = await Promise.all(allGamesPromises);
    let allGames = results.flat();
    const upcomingGames = allGames.filter((game) => game.state === "pre");
    if (upcomingGames.length === 0) {
      console.log("No upcoming games found for current dates. Searching for upcoming games in next 7 days.");
      let foundUpcomingGames = [];
      for (let i = 1; i <= 7; i++) {
        const startDay = includeTomorrow ? 2 : 1;
        if (i < startDay) continue;
        const futureDate = new Date(dateToUse);
        futureDate.setDate(futureDate.getDate() + i);
        const futureDateFormatted = format(futureDate, "M/d/yyyy");
        console.log(`Looking for upcoming games on: ${futureDateFormatted}`);
        const futurePromises = leagues2.map((leagueId) => getLeagueGames(leagueId, futureDate));
        const futureResults = await Promise.all(futurePromises);
        const futureGames = futureResults.flat();
        const upcomingFutureGames = futureGames.filter((game) => game.state === "pre");
        upcomingFutureGames.forEach((game) => {
          game.isFuture = true;
        });
        if (upcomingFutureGames.length > 0) {
          console.log(`Found ${upcomingFutureGames.length} upcoming games for ${futureDateFormatted}`);
          foundUpcomingGames = upcomingFutureGames;
          break;
        }
      }
      if (foundUpcomingGames.length > 0) {
        console.log(`Adding ${foundUpcomingGames.length} upcoming future games to the results`);
        allGames = [...allGames, ...foundUpcomingGames];
      }
    }
    console.log(`\u{1F7E2} FINAL: Total games loaded: ${allGames.length}`);
    await RedisCache.set(cacheKey, allGames, 120);
    console.log(`\u{1F4BE} Cached ${allGames.length} games for ${formattedDate}`);
    return allGames;
  } catch (error) {
    console.error("Error fetching all league games:", error);
    return [];
  }
}
async function getGameById(gameId) {
  try {
    console.log(`Fetching game by ID: ${gameId}`);
    const todayGames = await getAllGames();
    const game = todayGames.find((game2) => game2.id === gameId);
    if (game) {
      console.log(`Found game in today's games: ${game.homeTeam.name} vs ${game.awayTeam.name}`);
      return game;
    }
    const tomorrow = /* @__PURE__ */ new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowGames = await getAllGames(tomorrow, false);
    const gameTomorrow = tomorrowGames.find((game2) => game2.id === gameId);
    if (gameTomorrow) {
      console.log(`Found game in tomorrow's games: ${gameTomorrow.homeTeam.name} vs ${gameTomorrow.awayTeam.name}`);
      return gameTomorrow;
    }
    const demoDateRange = [\
      new Date(2025, 4, 10),\
      // May is month 4 (0-based)\
      new Date(2025, 4, 11),\
      new Date(2025, 4, 12),\
      new Date(2025, 4, 13),\
      new Date(2025, 4, 14)\
    ];
    for (const demoDate of demoDateRange) {
      const formattedDate = `${demoDate.getFullYear()}-${String(demoDate.getMonth() + 1).padStart(2, "0")}-${String(demoDate.getDate()).padStart(2, "0")}`;
      console.log(`Checking games on ${formattedDate} for game ID ${gameId}`);
      const gamesOnDate = await getAllGames(demoDate);
      const gameOnDate = gamesOnDate.find((game2) => game2.id === gameId);
      if (gameOnDate) {
        console.log(`Found game on ${formattedDate}: ${gameOnDate.homeTeam.name} vs ${gameOnDate.awayTeam.name}`);
        return gameOnDate;
      }
    }
    const leagues2 = ["nhl", "nba", "mlb", "nfl"];
    for (const league of leagues2) {
      const leagueGames = await getLeagueGames(league);
      const leagueGame = leagueGames.find((game2) => game2.id === gameId);
      if (leagueGame) {
        console.log(`Found game in ${league.toUpperCase()} league data: ${leagueGame.homeTeam.name} vs ${leagueGame.awayTeam.name}`);
        return leagueGame;
      }
      const leagueTomorrowGames = await getLeagueGames(league, tomorrow);
      const leagueTomorrowGame = leagueTomorrowGames.find((game2) => game2.id === gameId);
      if (leagueTomorrowGame) {
        console.log(`Found game for tomorrow in ${league.toUpperCase()} league data: ${leagueTomorrowGame.homeTeam.name} vs ${leagueTomorrowGame.awayTeam.name}`);
        return leagueTomorrowGame;
      }
      for (const demoDate of demoDateRange) {
        const formattedDate = `${demoDate.getFullYear()}-${String(demoDate.getMonth() + 1).padStart(2, "0")}-${String(demoDate.getDate()).padStart(2, "0")}`;
        const leagueDemoGames = await getLeagueGames(league, demoDate);
        const leagueDemoGame = leagueDemoGames.find((game2) => game2.id === gameId);
        if (leagueDemoGame) {
          console.log(`Found game on ${formattedDate} in ${league.toUpperCase()} league data: ${leagueDemoGame.homeTeam.name} vs ${leagueDemoGame.awayTeam.name}`);
          return leagueDemoGame;
        }
      }
    }
    try {
      console.log(`Checking database for game ID ${gameId}`);
      const { data: streamData, error } = await supabase2.from("streams").select("*").eq("gameId", gameId).single();
      if (streamData && !error) {
        console.log(`Found game ${gameId} information in database`);
        let homeTeamName = "Home Team";
        let homeTeamAbbr = "HOME";
        let awayTeamName = "Away Team";
        let awayTeamAbbr = "AWAY";
        let leagueId = "nhl";
        if (streamData.gameName) {
          const teamPattern = /(.+?)\s+(?:at|vs\.?|@)\s+(.+)/i;
          const match = streamData.gameName.match(teamPattern);
          if (match && match.length >= 3) {
            awayTeamName = match[1].trim();
            homeTeamName = match[2].trim();
            awayTeamAbbr = awayTeamName.split(" ").map((word) => word[0]).join("").toUpperCase();
            homeTeamAbbr = homeTeamName.split(" ").map((word) => word[0]).join("").toUpperCase();
          }
          if (streamData.gameName.toLowerCase().includes("nhl") || streamData.gameName.toLowerCase().includes("hockey")) {
            leagueId = "nhl";
          } else if (streamData.gameName.toLowerCase().includes("nba") || streamData.gameName.toLowerCase().includes("basketball")) {
            leagueId = "nba";
          } else if (streamData.gameName.toLowerCase().includes("mlb") || streamData.gameName.toLowerCase().includes("baseball")) {
            leagueId = "mlb";
          } else if (streamData.gameName.toLowerCase().includes("nfl") || streamData.gameName.toLowerCase().includes("football")) {
            leagueId = "nfl";
          }
        }
        return {
          id: gameId,
          date: streamData.gameDate || (/* @__PURE__ */ new Date()).toISOString(),
          name: streamData.gameName || `${awayTeamName} at ${homeTeamName}`,
          shortName: `${awayTeamAbbr} @ ${homeTeamAbbr}`,
          state: "pre",
          // Assume it's upcoming
          league: leagueId,
          homeTeam: {
            id: "0",
            // We don't have this info
            name: homeTeamName,
            abbreviation: homeTeamAbbr,
            logo: `https://a.espncdn.com/i/teamlogos/${leagueId}/500/scoreboard/${homeTeamAbbr.toLowerCase()}.png`
          },
          awayTeam: {
            id: "0",
            // We don't have this info
            name: awayTeamName,
            abbreviation: awayTeamAbbr,
            logo: `https://a.espncdn.com/i/teamlogos/${leagueId}/500/scoreboard/${awayTeamAbbr.toLowerCase()}.png`
          },
          venue: {
            name: streamData.venue || "Venue TBD",
            city: streamData.location || "Location TBD"
          },
          status: {
            period: 0,
            clock: "0:00",
            displayClock: "0:00",
            detail: streamData.gameDetail || "Upcoming Game"
          }
        };
      }
    } catch (dbError) {
      console.error(`Error checking database for game ${gameId}:`, dbError);
    }
    console.log(`Game with ID ${gameId} not found in any data source`);
    return null;
  } catch (error) {
    console.error(`Error fetching game by ID ${gameId}:`, error);
    return null;
  }
}
function mapESPNGamesToGameModel(espnGames, leagueId) {
  const games = [];
  for (const espnGame of espnGames) {
    try {
      const homeTeamData = espnGame.competitors?.find((c) => c.homeAway === "home");
      const awayTeamData = espnGame.competitors?.find((c) => c.homeAway === "away");
      if (!homeTeamData || !awayTeamData) {
        console.warn(`Game ${espnGame.id} missing team data, skipping`);
        continue;
      }
      const { state, isWarmup, statusDetail } = determineGameState(espnGame);
      console.log(`Game ${espnGame.id} status: ${espnGame.status}, detailed status: ${statusDetail}, mapped to state: ${state}`);
      const game = {
        id: espnGame.id,
        date: espnGame.date,
        name: espnGame.name,
        shortName: espnGame.shortName,
        state,
        league: leagueId,
        homeTeam: {
          id: homeTeamData.id,
          name: homeTeamData.displayName,
          abbreviation: homeTeamData.abbreviation,
          logo: homeTeamData.logo || homeTeamData.logoDark || "",
          score: homeTeamData.score ? parseInt(homeTeamData.score, 10) : void 0
        },
        awayTeam: {
          id: awayTeamData.id,
          name: awayTeamData.displayName,
          abbreviation: awayTeamData.abbreviation,
          logo: awayTeamData.logo || awayTeamData.logoDark || "",
          score: awayTeamData.score ? parseInt(awayTeamData.score, 10) : void 0
        },
        venue: {
          // Get venue name from event location field, with fallbacks
          name: espnGame.location || espnGame.venue?.fullName || espnGame.venue?.name || "TBD",
          // Get city from home team location, with fallbacks
          city: homeTeamData.location || espnGame.venue?.address?.city || espnGame.venue?.address?.state || "TBD"
        },
        status: {
          period: espnGame.period || 0,
          clock: espnGame.clock,
          displayClock: espnGame.clock,
          detail: statusDetail
        },
        // Enhanced broadcast information
        broadcasts: espnGame.broadcasts?.map((broadcast) => ({
          type: broadcast.type || "",
          name: broadcast.market?.name || broadcast.name || "",
          shortName: broadcast.market?.shortName || broadcast.shortName || "",
          callLetters: broadcast.callLetters || "",
          isNational: broadcast.isNational || false,
          slug: broadcast.slug || ""
        })) || [],
        // ESPN links for additional game info
        links: {
          gamecast: espnGame.links?.find((link) => link.rel?.includes("gamecast"))?.href,
          boxScore: espnGame.links?.find((link) => link.rel?.includes("boxscore"))?.href,
          recap: espnGame.links?.find((link) => link.rel?.includes("recap"))?.href
        }
      };
      games.push(game);
    } catch (error) {
      console.error(`Error processing game ${espnGame.id}:`, error);
    }
  }
  return games;
}
var ESPN_API_BASE, LEAGUES;
var init_espnApi = __esm({
  "server/espnApi.ts"() {
    "use strict";
    init_db();
    init_redis();
    ESPN_API_BASE = "https://site.api.espn.com/apis/v2/scoreboard/header";
    LEAGUES = {
      nhl: { sport: "hockey", league: "nhl" },
      nba: { sport: "basketball", league: "nba" },
      nfl: { sport: "football", league: "nfl" },
      mlb: { sport: "baseball", league: "mlb" }
    };
  }
});

// server/emailService.ts
var emailService_exports = {};
__export(emailService_exports, {
  createGameAlertEmail: () => createGameAlertEmail,
  handleGameAlertEmail: () => handleGameAlertEmail,
  handleSubscriptionExpirationEmail: () => handleSubscriptionExpirationEmail,
  handleWelcomeEmail: () => handleWelcomeEmail,
  initEmailService: () => initEmailService,
  sendEmail: () => sendEmail,
  sendGameAlert: () => sendGameAlert,
  sendVerificationEmail: () => sendVerificationEmail
});
import { Resend } from "resend";
async function initEmailService() {
  console.log("\u{1F4E7} Email service initialized");
  return true;
}
async function handleWelcomeEmail(email) {
  console.log("\u{1F4E7} Welcome email handler called for:", email);
  return { success: true };
}
async function handleSubscriptionExpirationEmail(email) {
  console.log("\u{1F4E7} Subscription expiration email handler called for:", email);
  return { success: true };
}
async function handleGameAlertEmail(params) {
  console.log("\u{1F4E7} Game alert email handler called with params:", params);
  return await sendGameAlert(params);
}
async function sendVerificationEmail(email, verificationUrl) {
  if (!resend) {
    console.error("Resend not initialized - RESEND_API_KEY missing");
    return { success: false, error: "Email service not configured" };
  }
  try {
    const emailHtml = createVerificationEmail(verificationUrl);
    const { data, error } = await resend.emails.send({
      from: "VeloPlay <noreply@veloplay.tv>",
      to: email,
      subject: "Verify Your Email - VeloPlay",
      html: emailHtml
    });
    if (error) {
      console.error("Verification email error:", error);
      return { success: false, error: error.message };
    }
    console.log("\u2705 Verification email sent successfully:", data);
    return { success: true };
  } catch (error) {
    console.error("Verification email service error:", error);
    return { success: false, error: error.message };
  }
}
function createVerificationEmail(verificationUrl) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Verify Your Email - VeloPlay</title>
    </head>
    <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
      <div style="background-color: #7f00ff; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
        <h1 style="color: white; margin: 0;">Verify Your Email</h1>
      </div>
      <div style="background-color: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #eee; border-top: none;">
        <p>Welcome to VeloPlay!</p>
        <p>Thank you for registering with VeloPlay! Please verify your email address to complete your account setup and access all features.</p>
        <div style="text-align: center; margin: 30px 0;">
          <a href="${verificationUrl}" style="background-color: #7f00ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">Verify Email Address</a>
        </div>
        <p>With your verified account, you can:</p>
        <ul>
          <li>Stream live games from NFL, NBA, NHL, and MLB</li>
          <li>Get real-time game notifications</li>
          <li>Customize your viewing experience</li>
        </ul>
        <p>Explore our subscription plans after verification to access premium content.</p>
        <p>If you didn't create an account with VeloPlay, you can safely ignore this email.</p>
        <p>The VeloPlay Team</p>
      </div>
      <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
        <p>\xA9 2025 VeloPlay. All rights reserved.</p>
        <p>If the button doesn't work, copy and paste this link in your browser: ${verificationUrl}</p>
        <p>This email was sent to verify your account at VeloPlay.</p>
      </div>
    </body>
    </html>
  `;
}
async function sendEmail(params) {
  if (!resend) {
    console.error("Resend not initialized - RESEND_API_KEY missing");
    return false;
  }
  try {
    const { data, error } = await resend.emails.send({
      from: "VeloPlay <noreply@veloplay.tv>",
      to: params.to,
      subject: params.subject,
      html: params.html
    });
    if (error) {
      console.error("Email send error:", error);
      return false;
    }
    console.log("Email sent successfully:", data);
    return true;
  } catch (error) {
    console.error("Email service error:", error);
    return false;
  }
}
async function sendGameAlert(params) {
  if (!resend) {
    console.error("Resend not initialized - cannot send game alert");
    return false;
  }
  try {
    const emailHtml = createGameAlertEmail(params.gameName, params.gameTime, 30, params.minutesRemaining);
    const { data, error } = await resend.emails.send({
      from: "VeloPlay <noreply@veloplay.tv>",
      to: params.email,
      subject: `\u{1F6A8} Game Alert: ${params.gameName}`,
      html: emailHtml
    });
    if (error) {
      console.error("Game alert email error:", error);
      return false;
    }
    console.log("\u2705 Game alert email sent successfully:", data);
    return true;
  } catch (error) {
    console.error("Game alert email service error:", error);
    return false;
  }
}
function createGameAlertEmail(gameName, gameTime, minutesBefore, minutesRemaining) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Game Alert - ${gameName}</title>
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
      <div style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); color: white; padding: 30px; border-radius: 10px; text-align: center; margin-bottom: 30px;">
        <h1 style="margin: 0; font-size: 28px;">\u{1F6A8} Game Alert</h1>
        <p style="margin: 10px 0 0 0; font-size: 18px; opacity: 0.9;">Your game starts soon!</p>
      </div>

      <div style="background: #f8f9fa; padding: 25px; border-radius: 8px; margin-bottom: 25px;">
        <h2 style="color: #2c3e50; margin-top: 0;">${gameName}</h2>
        <p style="font-size: 16px; margin: 15px 0;">
          <strong>\u23F0 Game Time:</strong> ${gameTime}
        </p>
        ${minutesRemaining ? `<p style="font-size: 18px; margin: 15px 0; color: #9333ea; font-weight: bold;">
          <strong>\u26A1 Game starts in ${minutesRemaining} minutes!</strong>
        </p>` : ""}
        <p style="font-size: 16px; margin: 15px 0;">
          <strong>\u{1F514} Alert Time:</strong> ${minutesBefore} minutes before start
        </p>
      </div>

      <div style="text-align: center; margin: 30px 0;">
        <a href="https://veloplay.tv" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block; box-shadow: 0 4px 14px 0 rgba(147, 51, 234, 0.3);">
          Watch Live on VeloPlay
        </a>
      </div>

      <div style="border-top: 1px solid #e9ecef; padding-top: 20px; text-align: center; color: #6c757d; font-size: 14px;">
        <p>You're receiving this because you set up a game alert on VeloPlay.</p>
        <p>Enjoy the game! \u{1F3C6}</p>
      </div>
    </body>
    </html>
  `;
}
var resend;
var init_emailService = __esm({
  "server/emailService.ts"() {
    "use strict";
    resend = null;
    try {
      if (process.env.RESEND_API_KEY) {
        resend = new Resend(process.env.RESEND_API_KEY);
        console.log("\u2705 Resend client initialized successfully");
      } else {
        console.warn("\u26A0\uFE0F RESEND_API_KEY not found in environment variables");
      }
    } catch (error) {
      console.error("Failed to initialize Resend:", error);
    }
  }
});

// server/services/emailService.ts
var emailService_exports2 = {};
__export(emailService_exports2, {
  sendOtpEmail: () => sendOtpEmail,
  sendSubscriptionExpirationEmail: () => sendSubscriptionExpirationEmail,
  sendTestEmail: () => sendTestEmail,
  sendVerificationEmail: () => sendVerificationEmail2,
  sendWelcomeEmail: () => sendWelcomeEmail
});
import { Resend as Resend2 } from "resend";
import dotenv from "dotenv";
var resend2, FROM_EMAIL, otpEmailTemplate, welcomeEmailTemplate, subscriptionExpirationTemplate, sendWelcomeEmail, sendSubscriptionExpirationEmail, verificationEmailTemplate, sendVerificationEmail2, sendTestEmail, sendOtpEmail;
var init_emailService2 = __esm({
  "server/services/emailService.ts"() {
    "use strict";
    dotenv.config();
    resend2 = new Resend2(process.env.RESEND_API_KEY);
    FROM_EMAIL = "noreply@veloplay.tv";
    otpEmailTemplate = (userName, otpCode) => ({
      subject: "Your VeloPlay Login Verification Code",
      html: `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
      <div style="background-color: #7f00ff; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
        <h1 style="color: white; margin: 0;">Login Verification</h1>
      </div>
      <div style="background-color: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #eee; border-top: none;">
        <p>Hello ${userName},</p>
        <p>To complete your login to VeloPlay, please use the following verification code:</p>
        <div style="background-color: #f0f0f0; padding: 15px; border-radius: 4px; margin: 20px 0; text-align: center;">
          <h2 style="margin: 0; letter-spacing: 5px; font-family: monospace; color: #7f00ff; font-size: 32px;">${otpCode}</h2>
        </div>
        <p>This code will expire in 5 minutes for security reasons.</p>
        <p>If you didn't attempt to log in to VeloPlay, please ignore this email or contact our support team immediately.</p>
        <p>Thank you for using VeloPlay!</p>
      </div>
      <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
        <p>\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} VeloPlay. All rights reserved.</p>
        <p>This is an automated message, please do not reply to this email.</p>
      </div>
    </div>
  `
    });
    welcomeEmailTemplate = (userName) => ({
      subject: "Welcome to VeloPlay! \u{1F3AE}",
      html: `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
      <div style="background-color: #7f00ff; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
        <h1 style="color: white; margin: 0;">Welcome to VeloPlay!</h1>
      </div>
      <div style="background-color: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #eee; border-top: none;">
        <p>Hello ${userName},</p>
        <p>Thank you for joining VeloPlay! We're excited to have you as part of our community.</p>
        <p>With your new account, you can:</p>
        <ul>
          <li>Stream live games from NFL, NBA, NHL, and MLB</li>
          <li>Get real-time game notifications</li>
          <li>Customize your viewing experience</li>
        </ul>
        <p>Explore our premium subscription plans to unlock unlimited access to all our premium features!</p>
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://veloplay.com/watch" style="background-color: #7f00ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">Start Watching Now</a>
        </div>
        <p>If you have any questions or need assistance, our support team is always here to help.</p>
        <p>Happy streaming!</p>
        <p>The VeloPlay Team</p>
      </div>
      <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
        <p>\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} VeloPlay. All rights reserved.</p>
        <p>This email was sent to you because you signed up for VeloPlay.</p>
      </div>
    </div>
  `
    });
    subscriptionExpirationTemplate = (userName, daysRemaining) => ({
      subject: `Your VeloPlay Subscription Expires in ${daysRemaining} Days`,
      html: `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
      <div style="background-color: #7f00ff; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
        <h1 style="color: white; margin: 0;">Subscription Reminder</h1>
      </div>
      <div style="background-color: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #eee; border-top: none;">
        <p>Hello ${userName},</p>
        <p>Your VeloPlay subscription is set to expire in <strong>${daysRemaining} days</strong>.</p>
        <p>To ensure uninterrupted access to all your favorite sports streams, please renew your subscription before it expires.</p>
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://veloplay.com/account/subscription" style="background-color: #7f00ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">Renew Subscription</a>
        </div>
        <p>If you have any questions about your subscription, please contact our support team.</p>
        <p>Thank you for being a valued member of VeloPlay!</p>
        <p>The VeloPlay Team</p>
      </div>
      <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
        <p>\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} VeloPlay. All rights reserved.</p>
        <p>You're receiving this email because you have an active subscription with VeloPlay.</p>
      </div>
    </div>
  `
    });
    sendWelcomeEmail = async (to, userName, verificationLink) => {
      try {
        const emailHtml = verificationLink ? verificationEmailTemplate(to, verificationLink).html : welcomeEmailTemplate(userName).html;
        const { data, error } = await resend2.emails.send({
          from: FROM_EMAIL,
          to,
          subject: verificationLink ? "Welcome to VeloPlay! Please Verify Your Email" : "Welcome to VeloPlay! \u{1F3AE}",
          html: emailHtml
        });
        if (error) {
          console.error("Failed to send welcome email:", error);
          return { success: false, error };
        }
        console.log("Welcome email sent successfully:", data);
        return { success: true, data };
      } catch (error) {
        console.error("Error sending welcome email:", error);
        return { success: false, error };
      }
    };
    sendSubscriptionExpirationEmail = async (to, userName, daysRemaining) => {
      try {
        const template = subscriptionExpirationTemplate(userName, daysRemaining);
        const { data, error } = await resend2.emails.send({
          from: FROM_EMAIL,
          to,
          subject: template.subject,
          html: template.html
        });
        if (error) {
          console.error("Failed to send subscription expiration email:", error);
          return { success: false, error };
        }
        console.log("Subscription expiration email sent successfully:", data);
        return { success: true, data };
      } catch (error) {
        console.error("Error sending subscription expiration email:", error);
        return { success: false, error };
      }
    };
    verificationEmailTemplate = (to, verificationLink) => ({
      subject: "Verify Your VeloPlay Account",
      html: `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
      <div style="background-color: #7f00ff; padding: 20px; text-align: center; border-radius: 8px 8px 0 0;">
        <h1 style="color: white; margin: 0;">Verify Your Email</h1>
      </div>
      <div style="background-color: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #eee; border-top: none;">
        <p>Welcome to VeloPlay!</p>
        <p>Please verify your email address to complete your registration and access all features.</p>
        <div style="text-align: center; margin: 30px 0;">
          <a href="${verificationLink}" style="background-color: #7f00ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">Verify Email Address</a>
        </div>
        <p>If the button above doesn't work, copy and paste this verification link into your browser:</p>
        <p style="background-color: #eee; padding: 10px; word-break: break-all;">${verificationLink}</p>
        <p>With your verified account, you can:</p>
        <ul>
          <li>Stream live games from NFL, NBA, NHL, and MLB</li>
          <li>Get real-time game notifications</li>
          <li>Customize your viewing experience</li>
        </ul>
        <p>Explore our subscription plans after verification to access premium content.</p>
        <p>If you didn't create an account with VeloPlay, you can safely ignore this email.</p>
      </div>
      <div style="text-align: center; padding: 20px; color: #666; font-size: 12px;">
        <p>\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} VeloPlay. All rights reserved.</p>
        <p>This email was sent to verify your account at VeloPlay.</p>
      </div>
    </div>
  `
    });
    sendVerificationEmail2 = async (to, verificationLink) => {
      try {
        if (!verificationLink.includes("autoVerify=true")) {
          verificationLink = verificationLink.includes("?") ? `${verificationLink}&autoVerify=true` : `${verificationLink}?autoVerify=true`;
        }
        console.log(`Sending verification email to ${to} with link ${verificationLink}`);
        const template = verificationEmailTemplate(to, verificationLink);
        const { data, error } = await resend2.emails.send({
          from: FROM_EMAIL,
          to,
          subject: template.subject,
          html: template.html
        });
        if (error) {
          console.error("Failed to send verification email:", error);
          return { success: false, error };
        }
        console.log("Verification email sent successfully:", data);
        return { success: true, data };
      } catch (error) {
        console.error("Error sending verification email:", error);
        return { success: false, error };
      }
    };
    sendTestEmail = async (to) => {
      try {
        const baseUrl = process.env.CLIENT_URL || "https://veloplay.tv";
        const testVerificationLink = `${baseUrl}/auth/verify?token=test-token-example&type=signup&email=${encodeURIComponent(to)}`;
        return sendVerificationEmail2(to, testVerificationLink);
      } catch (error) {
        console.error("Error sending test email:", error);
        return { success: false, error };
      }
    };
    sendOtpEmail = async (to, userName, otpCode) => {
      try {
        console.log(`Sending OTP email to ${to} with code ${otpCode}`);
        console.log("=============================================");
        console.log(`VERIFICATION CODE FOR ${to}: ${otpCode}`);
        console.log("=============================================");
        if (!process.env.RESEND_API_KEY) {
          console.log("Skipping actual email sending - RESEND_API_KEY not available");
          return { success: true, data: { id: "mock-email-id" } };
        }
        try {
          const template = otpEmailTemplate(userName, otpCode);
          const { data, error } = await resend2.emails.send({
            from: FROM_EMAIL,
            to,
            subject: template.subject,
            html: template.html
          });
          if (error) {
            console.error("Failed to send OTP email:", error);
            return { success: true, data: { id: "mock-email-id" } };
          }
          console.log("OTP email sent successfully");
          return { success: true, data };
        } catch (emailError) {
          console.error("Error sending OTP email:", emailError);
          return { success: true, data: { id: "mock-email-id" } };
        }
      } catch (error) {
        console.error("Error in OTP email function:", error);
        return { success: true, data: { id: "mock-email-id" } };
      }
    };
  }
});

// server/routes/streamSourcesLatestFixed.ts
import express from "express";
import fs from "fs";
import path from "path";
function loadStreamSourcesFromFile() {
  try {
    const streamSourcesPath = path.join(process.cwd(), "stream-sources-complete.json");
    if (fs.existsSync(streamSourcesPath)) {
      const fileData = fs.readFileSync(streamSourcesPath, "utf8");
      const sources = JSON.parse(fileData);
      return sources;
    }
  } catch (error) {
    console.error("Error loading stream sources from file:", error);
  }
  return [];
}
function getStreamIdInfo(id) {
  let name = `Stream ${id}`;
  let teamName = `Team ${id}`;
  let leagueId = "other";
  if (id >= ID_RANGES.SPECIAL_CHANNELS.min && id <= ID_RANGES.SPECIAL_CHANNELS.max) {
    name = SPECIAL_CHANNEL_NAMES[id] || `${ID_RANGES.SPECIAL_CHANNELS.prefix} ${id}`;
    teamName = name;
    leagueId = ID_RANGES.SPECIAL_CHANNELS.leagueId;
  } else if (id >= ID_RANGES.NHL_TEAMS.min && id <= ID_RANGES.NHL_TEAMS.max) {
    name = `${ID_RANGES.NHL_TEAMS.prefix} ${id}`;
    teamName = `NHL Team ${id}`;
    leagueId = ID_RANGES.NHL_TEAMS.leagueId;
  } else if (id >= ID_RANGES.NFL_TEAMS.min && id <= ID_RANGES.NFL_TEAMS.max) {
    name = `${ID_RANGES.NFL_TEAMS.prefix} ${id}`;
    teamName = `NFL Team ${id}`;
    leagueId = ID_RANGES.NFL_TEAMS.leagueId;
  } else if (id >= ID_RANGES.NBA_TEAMS.min && id <= ID_RANGES.NBA_TEAMS.max) {
    name = `${ID_RANGES.NBA_TEAMS.prefix} ${id}`;
    teamName = `NBA Team ${id}`;
    leagueId = ID_RANGES.NBA_TEAMS.leagueId;
  } else if (id >= ID_RANGES.SPECIAL_SPORTS.min && id <= ID_RANGES.SPECIAL_SPORTS.max) {
    name = `${ID_RANGES.SPECIAL_SPORTS.prefix} ${id}`;
    teamName = `Sports Channel ${id}`;
    leagueId = ID_RANGES.SPECIAL_SPORTS.leagueId;
  } else if (id >= ID_RANGES.MLB_TEAMS.min && id <= ID_RANGES.MLB_TEAMS.max) {
    name = `${ID_RANGES.MLB_TEAMS.prefix} ${id}`;
    teamName = `MLB Team ${id}`;
    leagueId = ID_RANGES.MLB_TEAMS.leagueId;
  } else if (id >= ID_RANGES.NHL_EXTENDED.min && id <= ID_RANGES.NHL_EXTENDED.max) {
    name = `${ID_RANGES.NHL_EXTENDED.prefix} ${id}`;
    teamName = `NHL Team ${id}`;
    leagueId = ID_RANGES.NHL_EXTENDED.leagueId;
  } else if (id >= ID_RANGES.NBA_EXTENDED.min && id <= ID_RANGES.NBA_EXTENDED.max) {
    name = `${ID_RANGES.NBA_EXTENDED.prefix} ${id}`;
    teamName = `NBA Team ${id}`;
    leagueId = ID_RANGES.NBA_EXTENDED.leagueId;
  }
  return { leagueId, name, teamName };
}
function standardizeStreamUrl(url) {
  if (!url) return url;
  try {
    const match = url.match(/\/(\d+)\.m3u8$/);
    if (!match) return url;
    const streamId = match[1];
    return `https://${NEW_DOMAIN}:${PORT}/${PATH}/${streamId}.m3u8`;
  } catch (error) {
    console.error("Error in standardizeStreamUrl:", error);
    return url;
  }
}
async function createOrUpdateStreamSource(streamId, url) {
  try {
    const streamIdInfo = getStreamIdInfo(streamId);
    const standardizedUrl = standardizeStreamUrl(url);
    const streamData = {
      id: streamId,
      name: streamIdInfo.name,
      team_name: streamIdInfo.teamName,
      url: standardizedUrl,
      description: `Stream source ID ${streamId}`,
      is_active: true,
      league_id: streamIdInfo.leagueId,
      priority: 1,
      updated_at: /* @__PURE__ */ new Date()
    };
    const { data, error } = await supabase2.from("stream_sources").upsert(streamData, { onConflict: "id" }).select();
    if (error) {
      console.error("Error creating/updating stream source:", error);
      return null;
    }
    const globalObj = global;
    if (globalObj.cachedStreamSources) {
      console.log("Clearing global stream sources cache");
      globalObj.cachedStreamSources = null;
    }
    return data;
  } catch (error) {
    console.error("Exception in createOrUpdateStreamSource:", error);
    return null;
  }
}
var NEW_DOMAIN, PORT, PATH, MLB_TEAM_IDS_VERSION, ID_RANGES, SPECIAL_CHANNEL_NAMES, router, streamSourcesLatestFixed_default;
var init_streamSourcesLatestFixed = __esm({
  "server/routes/streamSourcesLatestFixed.ts"() {
    "use strict";
    init_db();
    NEW_DOMAIN = "vpt.pixelsport.to";
    PORT = "443";
    PATH = "psportsgate/psportsgate100";
    MLB_TEAM_IDS_VERSION = 3;
    ID_RANGES = {
      // 1-5: Special channels
      SPECIAL_CHANNELS: { min: 1, max: 5, leagueId: "special", prefix: "Special Channel" },
      // 6-35: NHL Teams (Core range)
      NHL_TEAMS: { min: 6, max: 35, leagueId: "nhl", prefix: "NHL Team" },
      // 35-63: NFL Teams (Updated range from M3U8)
      NFL_TEAMS: { min: 35, max: 63, leagueId: "nfl", prefix: "NFL Team" },
      // 65-95: NBA Teams (Updated range from M3U8)
      NBA_TEAMS: { min: 65, max: 95, leagueId: "nba", prefix: "NBA Team" },
      // 96-146: Mixed Special Sports Channels
      SPECIAL_SPORTS: { min: 96, max: 146, leagueId: "special", prefix: "Sports Channel" },
      // 185-214: MLB Teams (New range from M3U8)
      MLB_TEAMS: { min: 185, max: 214, leagueId: "mlb", prefix: "MLB Team" },
      // 215-218: Extended NHL Teams
      NHL_EXTENDED: { min: 215, max: 218, leagueId: "nhl", prefix: "NHL Team" },
      // 219-222: Extended NBA Teams
      NBA_EXTENDED: { min: 219, max: 222, leagueId: "nba", prefix: "NBA Team" }
    };
    SPECIAL_CHANNEL_NAMES = {
      1: "NBA TV",
      2: "NFL Network",
      3: "MLB Network",
      4: "NHL Network",
      5: "ESPN"
    };
    router = express.Router();
    router.get("/", async (req, res) => {
      try {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Methods", "GET");
        const requestedVersion = req.query.v ? Number(req.query.v) : null;
        const cacheControl = req.query.noCache === "true";
        if (requestedVersion) {
          console.log(`Stream sources requested with MLB IDs version: ${requestedVersion}, current version: ${MLB_TEAM_IDS_VERSION}`);
        }
        if (cacheControl) {
          res.header("Cache-Control", "no-cache, no-store, must-revalidate");
          res.header("Pragma", "no-cache");
          res.header("Expires", "0");
        }
        let sources = [];
        try {
          const { data: dbSources, error } = await supabase2.from("stream_sources").select("*").order("id", { ascending: true });
          if (error) throw error;
          if (dbSources && dbSources.length > 0) {
            console.log(`Found ${dbSources.length} stream sources in database (MLB IDs version ${MLB_TEAM_IDS_VERSION})`);
            sources = dbSources;
          }
        } catch (dbError) {
          console.error("Database error when fetching stream sources:", dbError);
        }
        const correctMLBSources = [\
          {\
            id: 210,\
            team_name: "Boston Red Sox",\
            stream_url: `https://${NEW_DOMAIN}:${PORT}/${PATH}/210.m3u8`,\
            league_id: "mlb",\
            stream_id: "210",\
            is_active: true,\
            created_at: (/* @__PURE__ */ new Date()).toISOString(),\
            updated_at: (/* @__PURE__ */ new Date()).toISOString()\
          },\
          {\
            id: 201,\
            team_name: "Baltimore Orioles",\
            stream_url: `https://${NEW_DOMAIN}:${PORT}/${PATH}/201.m3u8`,\
            league_id: "mlb",\
            stream_id: "201",\
            is_active: true,\
            created_at: (/* @__PURE__ */ new Date()).toISOString(),\
            updated_at: (/* @__PURE__ */ new Date()).toISOString()\
          }\
        ];
        sources = [...correctMLBSources, ...sources.filter((s) => !["210", "201"].includes(s.stream_id?.toString()))];
        if (sources.length <= 2) {
          const fileSources = loadStreamSourcesFromFile();
          if (fileSources && fileSources.length > 0) {
            console.log(`Found ${fileSources.length} stream sources in file (MLB IDs version ${MLB_TEAM_IDS_VERSION})`);
            sources = fileSources.map((source) => ({
              id: parseInt(source.id),
              name: source.name || "",
              url: source.url || "",
              description: source.description || "",
              isActive: source.isActive !== false,
              leagueId: source.leagueId || "unknown",
              priority: source.priority || 0,
              teamName: source.teamName || "",
              created_at: (/* @__PURE__ */ new Date()).toISOString(),
              updated_at: (/* @__PURE__ */ new Date()).toISOString()
            }));
          }
        }
        if (sources.length === 0) {
          sources = [\
            {\
              id: 210,\
              team_name: "Boston Red Sox",\
              stream_url: `https://${NEW_DOMAIN}:${PORT}/${PATH}/210.m3u8`,\
              league_id: "mlb",\
              stream_id: "210",\
              is_active: true,\
              created_at: (/* @__PURE__ */ new Date()).toISOString(),\
              updated_at: (/* @__PURE__ */ new Date()).toISOString()\
            },\
            {\
              id: 201,\
              team_name: "Baltimore Orioles",\
              stream_url: `https://${NEW_DOMAIN}:${PORT}/${PATH}/201.m3u8`,\
              league_id: "mlb",\
              stream_id: "201",\
              is_active: true,\
              created_at: (/* @__PURE__ */ new Date()).toISOString(),\
              updated_at: (/* @__PURE__ */ new Date()).toISOString()\
            }\
          ];
        }
        const standardizedSources = sources.map((source) => ({
          ...source,
          stream_url: standardizeStreamUrl(source.stream_url || source.url || `https://${NEW_DOMAIN}:${PORT}/${PATH}/${source.stream_id}.m3u8`)
        }));
        res.json({
          success: true,
          count: standardizedSources.length,
          sources: standardizedSources,
          mlbIdsVersion: MLB_TEAM_IDS_VERSION,
          note: "Red Sox=210, Orioles=201 from your M3U8"
        });
      } catch (error) {
        console.error("Error retrieving latest stream sources:", error);
        res.status(500).json({
          success: false,
          error: "Failed to retrieve stream sources"
        });
      }
    });
    router.post("/update/:id", async (req, res) => {
      try {
        const id = parseInt(req.params.id, 10);
        const { url } = req.body;
        if (isNaN(id)) {
          return res.status(400).json({
            success: false,
            message: "Invalid ID format"
          });
        }
        if (!url || typeof url !== "string") {
          return res.status(400).json({
            success: false,
            message: "Valid URL is required"
          });
        }
        const data = await createOrUpdateStreamSource(id, url);
        if (!data) {
          return res.status(500).json({
            success: false,
            message: "Failed to update stream URL"
          });
        }
        res.json({
          success: true,
          message: "Stream URL updated successfully",
          data: {
            id,
            url: standardizeStreamUrl(url)
          }
        });
      } catch (err) {
        const error = err;
        console.error("Error updating stream source URL:", error);
        res.status(500).json({
          success: false,
          message: "Internal server error",
          error: error.message || "Unknown error"
        });
      }
    });
    streamSourcesLatestFixed_default = router;
  }
});

// server/alerts.ts
import { Resend as Resend3 } from "resend";
async function sendTestAlert(email) {
  const testParams = {
    email,
    gameId: "401695652",
    gameName: "Cleveland Guardians at Detroit Tigers",
    gameTime: (/* @__PURE__ */ new Date()).toLocaleString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit",
      timeZoneName: "short"
    }),
    teams: {
      home: "Detroit Tigers",
      away: "Cleveland Guardians"
    }
  };
  return false;
}
var resend3;
var init_alerts = __esm({
  "server/alerts.ts"() {
    "use strict";
    if (!process.env.RESEND_API_KEY) {
      throw new Error("RESEND_API_KEY environment variable must be set");
    }
    resend3 = new Resend3(process.env.RESEND_API_KEY);
  }
});

// server/routes/streamSources.ts
var streamSources_exports = {};
__export(streamSources_exports, {
  default: () => streamSources_default
});
import { Router as Router4 } from "express";
import { z } from "zod";
var router5, streamSourceSchema, updateStreamSourceSchema, streamSources_default;
var init_streamSources = __esm({
  "server/routes/streamSources.ts"() {
    "use strict";
    init_storage();
    init_supabaseAuth();
    init_adminMiddleware();
    router5 = Router4();
    streamSourceSchema = z.object({
      name: z.string().min(1, "Name is required"),
      url: z.string().min(1, "URL is required"),
      description: z.string().optional(),
      isActive: z.boolean().default(true),
      leagueId: z.string(),
      priority: z.number().int().min(1).default(1),
      teamName: z.string().min(1, "Team name is required")
    });
    updateStreamSourceSchema = streamSourceSchema.partial();
    router5.get("/", async (req, res) => {
      try {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Methods", "GET");
        const streamSources2 = await storage.getAllStreamSources();
        res.json(streamSources2);
      } catch (error) {
        console.error("Error fetching stream sources:", error);
        res.status(500).json({ error: "Failed to fetch stream sources" });
      }
    });
    router5.get("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const streamSource = await storage.getStreamSourceById(parseInt(id, 10));
        if (!streamSource) {
          return res.status(404).json({ error: "Stream source not found" });
        }
        res.json(streamSource);
      } catch (error) {
        console.error("Error fetching stream source:", error);
        res.status(500).json({ error: "Failed to fetch stream source" });
      }
    });
    router5.post("/", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const validatedData = streamSourceSchema.parse(req.body);
        const newStreamSource = await storage.createStreamSource(validatedData);
        res.status(201).json(newStreamSource);
      } catch (error) {
        if (error instanceof z.ZodError) {
          return res.status(400).json({ error: error.errors });
        }
        console.error("Error creating stream source:", error);
        res.status(500).json({ error: "Failed to create stream source" });
      }
    });
    router5.put("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const validatedData = updateStreamSourceSchema.parse(req.body);
        const updatedStreamSource = await storage.updateStreamSource(parseInt(id, 10), validatedData);
        if (!updatedStreamSource) {
          return res.status(404).json({ error: "Stream source not found" });
        }
        res.json(updatedStreamSource);
      } catch (error) {
        if (error instanceof z.ZodError) {
          return res.status(400).json({ error: error.errors });
        }
        console.error("Error updating stream source:", error);
        res.status(500).json({ error: "Failed to update stream source" });
      }
    });
    router5.delete("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const success = await storage.deleteStreamSource(parseInt(id, 10));
        if (!success) {
          return res.status(404).json({ error: "Stream source not found" });
        }
        res.status(204).send();
      } catch (error) {
        console.error("Error deleting stream source:", error);
        res.status(500).json({ error: "Failed to delete stream source" });
      }
    });
    router5.patch("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const { url } = req.body;
        if (!url || typeof url !== "string") {
          return res.status(400).json({ error: "Valid URL is required" });
        }
        const existingSource = await storage.getStreamSourceById(parseInt(id, 10));
        if (!existingSource) {
          return res.status(404).json({ error: "Stream source not found" });
        }
        const updatedStreamSource = await storage.updateStreamSource(parseInt(id, 10), { url });
        if (!updatedStreamSource) {
          return res.status(404).json({ error: "Stream source not found" });
        }
        console.log(`Stream URL updated for ID ${id}: ${url}`);
        res.json(updatedStreamSource);
      } catch (error) {
        console.error("Error updating stream source URL:", error);
        res.status(500).json({ error: "Failed to update stream source URL" });
      }
    });
    streamSources_default = router5;
  }
});

// server/routes/initStreamSources.ts
var initStreamSources_exports = {};
__export(initStreamSources_exports, {
  createStreamSourcesTable: () => createStreamSourcesTable,
  default: () => initStreamSources_default,
  populateStreamSources: () => populateStreamSources
});
import express2 from "express";
async function createStreamSourcesTable() {
  try {
    const { data: tableExists, error: tableExistsError } = await supabase2.from("stream_sources").select("id").limit(1);
    if (!tableExistsError) {
      console.log("Stream sources table already exists");
      return true;
    }
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS stream_sources (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        team_name VARCHAR(255) NOT NULL,
        url TEXT NOT NULL,
        league_id VARCHAR(50) NOT NULL,
        is_active BOOLEAN DEFAULT true,
        priority INTEGER DEFAULT 1,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        description TEXT
      );
    `;
    const { error: createTableError } = await supabase2.rpc("exec", { query: createTableQuery });
    if (createTableError) {
      console.error("Error creating stream sources table:", createTableError);
      return false;
    }
    console.log("Stream sources table created successfully");
    return true;
  } catch (error) {
    console.error("Error creating stream sources table:", error);
    return false;
  }
}
async function populateStreamSources() {
  try {
    const { data: existingData, error: countError } = await supabase2.from("stream_sources").select("id").limit(1);
    if (existingData && existingData.length > 0) {
      console.log("Stream sources table already has data");
      return true;
    }
    await initializeLeagues();
    const baseUrl = "https://vpt.pixelsport.to:443/psportsgate/psportsgate100/";
    const specialChannels = [\
      { id: 1, name: "NBA TV", teamName: "NBA TV Network", url: `${baseUrl}1.m3u8`, leagueId: "other", priority: 1 },\
      { id: 2, name: "NFL Network", teamName: "NFL Network", url: `${baseUrl}2.m3u8`, leagueId: "other", priority: 1 },\
      { id: 3, name: "ESPN", teamName: "ESPN Network", url: `${baseUrl}3.m3u8`, leagueId: "other", priority: 1 },\
      { id: 4, name: "ESPN2", teamName: "ESPN2 Network", url: `${baseUrl}4.m3u8`, leagueId: "other", priority: 1 },\
      { id: 5, name: "MLB Network", teamName: "MLB Network", url: `${baseUrl}5.m3u8`, leagueId: "other", priority: 1 }\
    ];
    const nhlTeams = [\
      { id: 6, name: "Anaheim Ducks", teamName: "Anaheim Ducks", url: `${baseUrl}6.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 7, name: "Arizona Coyotes", teamName: "Arizona Coyotes", url: `${baseUrl}7.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 8, name: "Boston Bruins", teamName: "Boston Bruins", url: `${baseUrl}8.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 9, name: "Buffalo Sabres", teamName: "Buffalo Sabres", url: `${baseUrl}9.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 10, name: "Calgary Flames", teamName: "Calgary Flames", url: `${baseUrl}10.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 11, name: "Carolina Hurricanes", teamName: "Carolina Hurricanes", url: `${baseUrl}11.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 12, name: "Chicago Blackhawks", teamName: "Chicago Blackhawks", url: `${baseUrl}12.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 13, name: "Colorado Avalanche", teamName: "Colorado Avalanche", url: `${baseUrl}13.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 14, name: "Columbus Blue Jackets", teamName: "Columbus Blue Jackets", url: `${baseUrl}14.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 15, name: "Dallas Stars", teamName: "Dallas Stars", url: `${baseUrl}15.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 16, name: "Detroit Red Wings", teamName: "Detroit Red Wings", url: `${baseUrl}16.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 17, name: "Edmonton Oilers", teamName: "Edmonton Oilers", url: `${baseUrl}17.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 18, name: "Florida Panthers", teamName: "Florida Panthers", url: `${baseUrl}18.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 19, name: "Los Angeles Kings", teamName: "Los Angeles Kings", url: `${baseUrl}19.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 20, name: "Minnesota Wild", teamName: "Minnesota Wild", url: `${baseUrl}20.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 21, name: "Montreal Canadiens", teamName: "Montreal Canadiens", url: `${baseUrl}21.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 22, name: "Nashville Predators", teamName: "Nashville Predators", url: `${baseUrl}22.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 23, name: "New Jersey Devils", teamName: "New Jersey Devils", url: `${baseUrl}23.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 24, name: "New York Islanders", teamName: "New York Islanders", url: `${baseUrl}24.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 25, name: "New York Rangers", teamName: "New York Rangers", url: `${baseUrl}25.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 26, name: "Ottawa Senators", teamName: "Ottawa Senators", url: `${baseUrl}26.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 27, name: "Philadelphia Flyers", teamName: "Philadelphia Flyers", url: `${baseUrl}27.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 28, name: "Pittsburgh Penguins", teamName: "Pittsburgh Penguins", url: `${baseUrl}28.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 29, name: "San Jose Sharks", teamName: "San Jose Sharks", url: `${baseUrl}29.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 30, name: "Seattle Kraken", teamName: "Seattle Kraken", url: `${baseUrl}30.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 31, name: "St. Louis Blues", teamName: "St. Louis Blues", url: `${baseUrl}31.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 32, name: "Tampa Bay Lightning", teamName: "Tampa Bay Lightning", url: `${baseUrl}32.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 33, name: "Toronto Maple Leafs", teamName: "Toronto Maple Leafs", url: `${baseUrl}33.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 34, name: "Vancouver Canucks", teamName: "Vancouver Canucks", url: `${baseUrl}34.m3u8`, leagueId: "nhl", priority: 2 },\
      { id: 35, name: "Vegas Golden Knights", teamName: "Vegas Golden Knights", url: `${baseUrl}35.m3u8`, leagueId: "nhl", priority: 2 }\
    ];
    const mlbTeams = [\
      { id: 36, name: "Arizona Diamondbacks", teamName: "Arizona Diamondbacks", url: `${baseUrl}36.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 37, name: "Atlanta Braves", teamName: "Atlanta Braves", url: `${baseUrl}37.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 38, name: "Baltimore Orioles", teamName: "Baltimore Orioles", url: `${baseUrl}38.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 39, name: "Boston Red Sox", teamName: "Boston Red Sox", url: `${baseUrl}39.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 40, name: "Chicago Cubs", teamName: "Chicago Cubs", url: `${baseUrl}40.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 41, name: "Chicago White Sox", teamName: "Chicago White Sox", url: `${baseUrl}41.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 42, name: "Cincinnati Reds", teamName: "Cincinnati Reds", url: `${baseUrl}42.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 43, name: "Cleveland Guardians", teamName: "Cleveland Guardians", url: `${baseUrl}43.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 44, name: "Colorado Rockies", teamName: "Colorado Rockies", url: `${baseUrl}44.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 45, name: "Detroit Tigers", teamName: "Detroit Tigers", url: `${baseUrl}45.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 46, name: "Houston Astros", teamName: "Houston Astros", url: `${baseUrl}46.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 47, name: "Kansas City Royals", teamName: "Kansas City Royals", url: `${baseUrl}47.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 48, name: "Los Angeles Angels", teamName: "Los Angeles Angels", url: `${baseUrl}48.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 49, name: "Los Angeles Dodgers", teamName: "Los Angeles Dodgers", url: `${baseUrl}49.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 50, name: "Miami Marlins", teamName: "Miami Marlins", url: `${baseUrl}50.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 51, name: "Milwaukee Brewers", teamName: "Milwaukee Brewers", url: `${baseUrl}51.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 52, name: "Minnesota Twins", teamName: "Minnesota Twins", url: `${baseUrl}52.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 53, name: "New York Mets", teamName: "New York Mets", url: `${baseUrl}53.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 54, name: "New York Yankees", teamName: "New York Yankees", url: `${baseUrl}54.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 55, name: "Oakland Athletics", teamName: "Oakland Athletics", url: `${baseUrl}55.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 56, name: "Philadelphia Phillies", teamName: "Philadelphia Phillies", url: `${baseUrl}56.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 57, name: "Pittsburgh Pirates", teamName: "Pittsburgh Pirates", url: `${baseUrl}57.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 58, name: "San Diego Padres", teamName: "San Diego Padres", url: `${baseUrl}58.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 59, name: "San Francisco Giants", teamName: "San Francisco Giants", url: `${baseUrl}59.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 60, name: "Seattle Mariners", teamName: "Seattle Mariners", url: `${baseUrl}60.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 61, name: "St. Louis Cardinals", teamName: "St. Louis Cardinals", url: `${baseUrl}61.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 62, name: "Tampa Bay Rays", teamName: "Tampa Bay Rays", url: `${baseUrl}62.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 63, name: "Texas Rangers", teamName: "Texas Rangers", url: `${baseUrl}63.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 64, name: "Toronto Blue Jays", teamName: "Toronto Blue Jays", url: `${baseUrl}64.m3u8`, leagueId: "mlb", priority: 2 },\
      { id: 65, name: "Washington Nationals", teamName: "Washington Nationals", url: `${baseUrl}65.m3u8`, leagueId: "mlb", priority: 2 }\
    ];
    const nflTeams = [\
      { id: 66, name: "Arizona Cardinals", teamName: "Arizona Cardinals", url: `${baseUrl}66.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 67, name: "Atlanta Falcons", teamName: "Atlanta Falcons", url: `${baseUrl}67.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 68, name: "Baltimore Ravens", teamName: "Baltimore Ravens", url: `${baseUrl}68.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 69, name: "Buffalo Bills", teamName: "Buffalo Bills", url: `${baseUrl}69.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 70, name: "Carolina Panthers", teamName: "Carolina Panthers", url: `${baseUrl}70.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 71, name: "Chicago Bears", teamName: "Chicago Bears", url: `${baseUrl}71.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 72, name: "Cincinnati Bengals", teamName: "Cincinnati Bengals", url: `${baseUrl}72.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 73, name: "Cleveland Browns", teamName: "Cleveland Browns", url: `${baseUrl}73.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 74, name: "Dallas Cowboys", teamName: "Dallas Cowboys", url: `${baseUrl}74.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 75, name: "Denver Broncos", teamName: "Denver Broncos", url: `${baseUrl}75.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 76, name: "Detroit Lions", teamName: "Detroit Lions", url: `${baseUrl}76.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 77, name: "Green Bay Packers", teamName: "Green Bay Packers", url: `${baseUrl}77.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 78, name: "Houston Texans", teamName: "Houston Texans", url: `${baseUrl}78.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 79, name: "Indianapolis Colts", teamName: "Indianapolis Colts", url: `${baseUrl}79.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 80, name: "Jacksonville Jaguars", teamName: "Jacksonville Jaguars", url: `${baseUrl}80.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 81, name: "Kansas City Chiefs", teamName: "Kansas City Chiefs", url: `${baseUrl}81.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 82, name: "Las Vegas Raiders", teamName: "Las Vegas Raiders", url: `${baseUrl}82.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 83, name: "Los Angeles Chargers", teamName: "Los Angeles Chargers", url: `${baseUrl}83.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 84, name: "Los Angeles Rams", teamName: "Los Angeles Rams", url: `${baseUrl}84.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 85, name: "Miami Dolphins", teamName: "Miami Dolphins", url: `${baseUrl}85.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 86, name: "Minnesota Vikings", teamName: "Minnesota Vikings", url: `${baseUrl}86.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 87, name: "New England Patriots", teamName: "New England Patriots", url: `${baseUrl}87.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 88, name: "New Orleans Saints", teamName: "New Orleans Saints", url: `${baseUrl}88.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 89, name: "New York Giants", teamName: "New York Giants", url: `${baseUrl}89.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 90, name: "New York Jets", teamName: "New York Jets", url: `${baseUrl}90.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 91, name: "Philadelphia Eagles", teamName: "Philadelphia Eagles", url: `${baseUrl}91.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 92, name: "Pittsburgh Steelers", teamName: "Pittsburgh Steelers", url: `${baseUrl}92.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 93, name: "San Francisco 49ers", teamName: "San Francisco 49ers", url: `${baseUrl}93.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 94, name: "Seattle Seahawks", teamName: "Seattle Seahawks", url: `${baseUrl}94.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 95, name: "Tampa Bay Buccaneers", teamName: "Tampa Bay Buccaneers", url: `${baseUrl}95.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 96, name: "Tennessee Titans", teamName: "Tennessee Titans", url: `${baseUrl}96.m3u8`, leagueId: "nfl", priority: 2 },\
      { id: 97, name: "Washington Commanders", teamName: "Washington Commanders", url: `${baseUrl}97.m3u8`, leagueId: "nfl", priority: 2 }\
    ];
    const nbaTeams = [\
      { id: 98, name: "Atlanta Hawks", teamName: "Atlanta Hawks", url: `${baseUrl}98.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 99, name: "Boston Celtics", teamName: "Boston Celtics", url: `${baseUrl}99.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 100, name: "Brooklyn Nets", teamName: "Brooklyn Nets", url: `${baseUrl}100.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 101, name: "Charlotte Hornets", teamName: "Charlotte Hornets", url: `${baseUrl}101.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 102, name: "Chicago Bulls", teamName: "Chicago Bulls", url: `${baseUrl}102.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 103, name: "Cleveland Cavaliers", teamName: "Cleveland Cavaliers", url: `${baseUrl}103.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 104, name: "Dallas Mavericks", teamName: "Dallas Mavericks", url: `${baseUrl}104.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 105, name: "Denver Nuggets", teamName: "Denver Nuggets", url: `${baseUrl}105.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 106, name: "Detroit Pistons", teamName: "Detroit Pistons", url: `${baseUrl}106.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 107, name: "Golden State Warriors", teamName: "Golden State Warriors", url: `${baseUrl}107.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 108, name: "Houston Rockets", teamName: "Houston Rockets", url: `${baseUrl}108.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 109, name: "Indiana Pacers", teamName: "Indiana Pacers", url: `${baseUrl}109.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 110, name: "LA Clippers", teamName: "LA Clippers", url: `${baseUrl}110.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 111, name: "Los Angeles Lakers", teamName: "Los Angeles Lakers", url: `${baseUrl}111.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 112, name: "Memphis Grizzlies", teamName: "Memphis Grizzlies", url: `${baseUrl}112.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 113, name: "Miami Heat", teamName: "Miami Heat", url: `${baseUrl}113.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 114, name: "Milwaukee Bucks", teamName: "Milwaukee Bucks", url: `${baseUrl}114.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 115, name: "Minnesota Timberwolves", teamName: "Minnesota Timberwolves", url: `${baseUrl}115.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 116, name: "New Orleans Pelicans", teamName: "New Orleans Pelicans", url: `${baseUrl}116.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 117, name: "New York Knicks", teamName: "New York Knicks", url: `${baseUrl}117.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 118, name: "Oklahoma City Thunder", teamName: "Oklahoma City Thunder", url: `${baseUrl}118.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 119, name: "Orlando Magic", teamName: "Orlando Magic", url: `${baseUrl}119.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 120, name: "Philadelphia 76ers", teamName: "Philadelphia 76ers", url: `${baseUrl}120.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 121, name: "Phoenix Suns", teamName: "Phoenix Suns", url: `${baseUrl}121.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 122, name: "Portland Trail Blazers", teamName: "Portland Trail Blazers", url: `${baseUrl}122.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 123, name: "Sacramento Kings", teamName: "Sacramento Kings", url: `${baseUrl}123.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 124, name: "San Antonio Spurs", teamName: "San Antonio Spurs", url: `${baseUrl}124.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 125, name: "Toronto Raptors", teamName: "Toronto Raptors", url: `${baseUrl}125.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 126, name: "Utah Jazz", teamName: "Utah Jazz", url: `${baseUrl}126.m3u8`, leagueId: "nba", priority: 2 },\
      { id: 127, name: "Washington Wizards", teamName: "Washington Wizards", url: `${baseUrl}127.m3u8`, leagueId: "nba", priority: 2 }\
    ];
    const allStreamSources = [\
      ...specialChannels,\
      ...nhlTeams,\
      ...mlbTeams,\
      ...nflTeams,\
      ...nbaTeams\
    ];
    const formattedSources = allStreamSources.map((source) => ({
      id: source.id,
      name: source.name,
      team_name: source.teamName,
      url: source.url,
      league_id: source.leagueId,
      is_active: true,
      priority: source.priority,
      description: `${source.leagueId.toUpperCase()} ${source.name} stream`
    }));
    const BATCH_SIZE = 50;
    for (let i = 0; i < formattedSources.length; i += BATCH_SIZE) {
      const batch = formattedSources.slice(i, i + BATCH_SIZE);
      const { error: insertError } = await supabase2.from("stream_sources").upsert(batch, { onConflict: "id" });
      if (insertError) {
        console.error(`Error inserting batch ${i / BATCH_SIZE + 1}:`, insertError);
        return false;
      }
    }
    console.log(`Successfully inserted ${allStreamSources.length} stream sources`);
    return true;
  } catch (error) {
    console.error("Error populating stream sources:", error);
    return false;
  }
}
async function initializeLeagues() {
  try {
    const { data: tableExists, error: tableExistsError } = await supabase2.from("leagues").select("id").limit(1);
    if (!tableExistsError) {
      console.log("Leagues table already exists");
      if (tableExists && tableExists.length > 0) {
        console.log("Leagues table already has data");
        return true;
      }
    } else {
      const createTableQuery = `
        CREATE TABLE IF NOT EXISTS leagues (
          id VARCHAR(50) PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT,
          icon_url TEXT,
          is_active BOOLEAN DEFAULT true,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
      `;
      const { error: createTableError } = await supabase2.rpc("exec", { query: createTableQuery });
      if (createTableError) {
        console.error("Error creating leagues table:", createTableError);
        return false;
      }
      console.log("Leagues table created successfully");
    }
    const leagueData = [\
      { id: "nba", name: "NBA", description: "National Basketball Association", icon_url: "https://a.espncdn.com/combiner/i?img=/i/teamlogos/leagues/500/nba.png", is_active: true },\
      { id: "nfl", name: "NFL", description: "National Football League", icon_url: "https://a.espncdn.com/combiner/i?img=/i/teamlogos/leagues/500/nfl.png", is_active: true },\
      { id: "mlb", name: "MLB", description: "Major League Baseball", icon_url: "https://a.espncdn.com/combiner/i?img=/i/teamlogos/leagues/500/mlb.png", is_active: true },\
      { id: "nhl", name: "NHL", description: "National Hockey League", icon_url: "https://a.espncdn.com/combiner/i?img=/i/teamlogos/leagues/500/nhl.png", is_active: true },\
      { id: "other", name: "Special Channels", description: "Network and special channels", icon_url: "https://a.espncdn.com/combiner/i?img=/i/espn/espn_logos/espn_red.png", is_active: true }\
    ];
    const { error: insertError } = await supabase2.from("leagues").upsert(leagueData, { onConflict: "id" });
    if (insertError) {
      console.error("Error inserting leagues data:", insertError);
      return false;
    }
    console.log("Leagues data inserted successfully");
    return true;
  } catch (error) {
    console.error("Error initializing leagues table:", error);
    return false;
  }
}
async function handleInitStreamSources(req, res) {
  try {
    const tableCreated = await createStreamSourcesTable();
    if (!tableCreated) {
      return res.status(500).json({
        success: false,
        message: "Failed to create stream sources table"
      });
    }
    const dataPopulated = await populateStreamSources();
    if (!dataPopulated) {
      return res.status(500).json({
        success: false,
        message: "Failed to populate stream sources table with data"
      });
    }
    return res.status(200).json({
      success: true,
      message: "Stream sources initialized successfully"
    });
  } catch (error) {
    console.error("Error handling init stream sources request:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to initialize stream sources",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
var router6, initStreamSources_default;
var init_initStreamSources = __esm({
  "server/routes/initStreamSources.ts"() {
    "use strict";
    init_db();
    router6 = express2.Router();
    router6.post("/", async (req, res) => {
      return await handleInitStreamSources(req, res);
    });
    router6.get("/", async (req, res) => {
      return await handleInitStreamSources(req, res);
    });
    initStreamSources_default = router6;
  }
});

// server/routes/streams.ts
var streams_exports = {};
__export(streams_exports, {
  default: () => streams_default
});
import { Router as Router5 } from "express";
var router7, streams_default;
var init_streams = __esm({
  "server/routes/streams.ts"() {
    "use strict";
    init_supabaseAuth();
    init_adminMiddleware();
    init_db();
    router7 = Router5();
    router7.get("/", async (req, res) => {
      try {
        const { data, error } = await supabase2.from("streams").select("*").order("id", { ascending: true });
        if (error) {
          console.error("Error fetching streams:", error);
          return res.status(500).json({ error: "Failed to fetch streams" });
        }
        return res.json(data);
      } catch (error) {
        console.error("Error fetching streams:", error);
        res.status(500).json({ error: "Failed to fetch streams" });
      }
    });
    router7.get("/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const { data, error } = await supabase2.from("streams").select("*").eq("id", id).single();
        if (error) {
          console.error("Error fetching stream:", error);
          return res.status(404).json({ error: "Stream not found" });
        }
        res.json(data);
      } catch (error) {
        console.error("Error fetching stream:", error);
        res.status(500).json({ error: "Failed to fetch stream" });
      }
    });
    router7.post("/", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { game_id, stream_url, away_stream_url = null, is_active = true } = req.body;
        if (!game_id || !stream_url) {
          return res.status(400).json({ error: "Game ID and stream URL are required" });
        }
        const user_id = "be62b1e0-2628-4b18-b09f-44637a0dbad2";
        const { data, error } = await supabase2.from("streams").insert({
          game_id,
          stream_url,
          away_stream_url,
          is_active,
          added_by_id: user_id
        }).select();
        if (error) {
          console.error("Error creating stream:", error);
          return res.status(500).json({ error: "Failed to create stream" });
        }
        res.status(201).json(data[0]);
      } catch (error) {
        console.error("Error creating stream:", error);
        res.status(500).json({ error: "Failed to create stream" });
      }
    });
    router7.put("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const { game_id, stream_url, away_stream_url, is_active } = req.body;
        const { data, error } = await supabase2.from("streams").update({
          game_id,
          stream_url,
          away_stream_url,
          is_active,
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        }).eq("id", id).select();
        if (error) {
          console.error("Error updating stream:", error);
          return res.status(500).json({ error: "Failed to update stream" });
        }
        if (!data || data.length === 0) {
          return res.status(404).json({ error: "Stream not found" });
        }
        res.json(data[0]);
      } catch (error) {
        console.error("Error updating stream:", error);
        res.status(500).json({ error: "Failed to update stream" });
      }
    });
    router7.delete("/:id", isAuthenticated, isAdmin, async (req, res) => {
      try {
        const { id } = req.params;
        const { error } = await supabase2.from("streams").delete().eq("id", id);
        if (error) {
          console.error("Error deleting stream:", error);
          return res.status(500).json({ error: "Failed to delete stream" });
        }
        res.status(204).send();
      } catch (error) {
        console.error("Error deleting stream:", error);
        res.status(500).json({ error: "Failed to delete stream" });
      }
    });
    streams_default = router7;
  }
});

// server/alertScheduler.ts
var alertScheduler_exports = {};
__export(alertScheduler_exports, {
  alertScheduler: () => alertScheduler
});
var AlertScheduler, alertScheduler;
var init_alertScheduler = __esm({
  "server/alertScheduler.ts"() {
    "use strict";
    init_alerts();
    init_espnApi();
    AlertScheduler = class {
      alerts = /* @__PURE__ */ new Map();
      scheduleAlert(gameId, email, notifyMinutesBefore, gameTime) {
        const alertTime = new Date(gameTime.getTime() - notifyMinutesBefore * 60 * 1e3);
        const now = /* @__PURE__ */ new Date();
        if (alertTime <= now) {
          throw new Error(`Cannot schedule alert for ${notifyMinutesBefore} minutes before when only ${Math.floor((gameTime.getTime() - now.getTime()) / (1e3 * 60))} minutes remain`);
        }
        const alertId = `${gameId}-${email}-${notifyMinutesBefore}`;
        const delayMs = alertTime.getTime() - now.getTime();
        console.log(`\u{1F4C5} Scheduling alert: ${email} will be notified in ${Math.floor(delayMs / (1e3 * 60))} minutes (${notifyMinutesBefore} minutes before game)`);
        const timeout = setTimeout(async () => {
          await this.sendScheduledAlert(alertId);
        }, delayMs);
        const alert = {
          id: alertId,
          gameId,
          email,
          notifyMinutesBefore,
          gameTime,
          alertTime,
          timeout
        };
        this.alerts.set(alertId, alert);
        return alertId;
      }
      async sendScheduledAlert(alertId) {
        const alert = this.alerts.get(alertId);
        if (!alert) return;
        try {
          const game = await getGameById(alert.gameId);
          if (!game) {
            console.warn(`\u26A0\uFE0F Game ${alert.gameId} not found for scheduled alert`);
            return;
          }
          console.log(`\u{1F4E7} Sending scheduled alert to ${alert.email} for ${game.shortName}`);
          const success = await sendTestAlert(alert.email);
          if (success) {
            console.log(`\u2705 Scheduled alert sent successfully to ${alert.email} for ${game.shortName}`);
          } else {
            console.error(`\u274C Failed to send scheduled alert to ${alert.email} for ${game.shortName}`);
          }
        } catch (error) {
          console.error(`Error sending scheduled alert ${alertId}:`, error);
        } finally {
          this.alerts.delete(alertId);
        }
      }
      cancelAlert(alertId) {
        const alert = this.alerts.get(alertId);
        if (!alert) return false;
        if (alert.timeout) {
          clearTimeout(alert.timeout);
        }
        this.alerts.delete(alertId);
        console.log(`\u{1F6AB} Cancelled scheduled alert ${alertId}`);
        return true;
      }
      getScheduledAlerts() {
        return Array.from(this.alerts.values()).map((alert) => ({
          ...alert,
          timeout: void 0
          // Don't expose timeout in the response
        }));
      }
    };
    alertScheduler = new AlertScheduler();
  }
});

// server/routes/db-setup.ts
var db_setup_exports = {};
__export(db_setup_exports, {
  setupStreamSourcesTable: () => setupStreamSourcesTable
});
async function setupStreamSourcesTable() {
  try {
    console.log("Setting up stream_sources table...");
    const { data, error } = await supabase2.from("stream_sources").select("id").limit(1);
    const sampleData = [\
      {\
        name: "NBA Home Feed",\
        url: "https://example.com/streams/nba-home.m3u8",\
        description: "Home team feed for NBA games",\
        is_active: true,\
        league_id: "nba",\
        priority: 1,\
        team_name: "Los Angeles Lakers"\
      },\
      {\
        name: "NFL Home Feed",\
        url: "https://example.com/streams/nfl-home.m3u8",\
        description: "Home team feed for NFL games",\
        is_active: true,\
        league_id: "nfl",\
        priority: 1,\
        team_name: "Kansas City Chiefs"\
      },\
      {\
        name: "MLB Home Feed",\
        url: "https://example.com/streams/mlb-home.m3u8",\
        description: "Home team feed for MLB games",\
        is_active: true,\
        league_id: "mlb",\
        priority: 1,\
        team_name: "New York Yankees"\
      }\
    ];
    if (error) {
      console.log("Table may not exist, trying to create it...");
      const { error: initialInsertError } = await supabase2.from("stream_sources").insert(sampleData);
      if (initialInsertError) {
        console.log("First attempt to insert data failed. Creating table structure...");
        try {
          console.log("Creating table through direct Postgres access...");
          const { error: insertError } = await supabase2.from("stream_sources").insert({
            name: "Test Stream",
            url: "https://test.com/stream.m3u8",
            description: "Test stream for table creation",
            is_active: true,
            league_id: "test",
            priority: 1,
            team_name: "Test Team"
          });
          if (!insertError) {
            console.log("Test record created, now adding sample data...");
            await supabase2.from("stream_sources").insert(sampleData);
            return { created: true, count: sampleData.length + 1 };
          } else {
            console.error("Error inserting test data:", insertError);
            return { error: "Could not setup stream sources table." };
          }
        } catch (sqlError) {
          console.error("Error creating table structure:", sqlError);
          return { error: "Failed to create stream sources table structure." };
        }
      } else {
        console.log("Sample data inserted successfully!");
        return { created: true, count: sampleData.length };
      }
    }
    if (data && data.length === 0) {
      console.log("Table exists but is empty, adding sample data...");
      const { error: insertError } = await supabase2.from("stream_sources").insert(sampleData);
      if (insertError) {
        console.error("Error inserting sample data into empty table:", insertError);
        return { error: insertError.message };
      }
      return { exists: true, updated: true, count: sampleData.length };
    }
    console.log("Stream sources table already exists with data");
    const { count, error: countError } = await supabase2.from("stream_sources").select("*", { count: "exact", head: true });
    const recordCount = count || "unknown";
    if (countError) {
      console.error("Error counting records:", countError);
      return { exists: true, count: "unknown" };
    }
    return { exists: true, count: recordCount };
  } catch (error) {
    console.error("Unexpected error in setupStreamSourcesTable:", error);
    return { error: String(error) };
  }
}
var init_db_setup = __esm({
  "server/routes/db-setup.ts"() {
    "use strict";
    init_db();
  }
});

// server/supabaseClient.ts
var supabaseClient_exports = {};
__export(supabaseClient_exports, {
  default: () => supabaseClient_default
});
import { createClient as createClient4 } from "@supabase/supabase-js";
var supabaseUrl, supabaseAnonKey, supabase3, supabaseClient_default;
var init_supabaseClient = __esm({
  "server/supabaseClient.ts"() {
    "use strict";
    supabaseUrl = process.env.SUPABASE_URL;
    supabaseAnonKey = process.env.SUPABASE_ANON_KEY;
    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error("Missing required Supabase environment variables");
    }
    supabase3 = createClient4(
      supabaseUrl,
      supabaseAnonKey,
      {
        auth: {
          persistSession: false
        }
      }
    );
    supabaseClient_default = supabase3;
  }
});

// server/index.ts
import express5 from "express";

// server/routes.ts
init_storage();
init_supabaseAuth();
init_adminMiddleware();
init_espnApi();
init_emailService();
import express3 from "express";
import { createServer } from "http";

// server/services/otpService.ts
init_storage();
init_emailService2();
import { authenticator } from "otplib";
authenticator.options = {
  digits: 6,
  step: 1800
  // 30 minutes - increasing from 5 minutes to give users more time to enter the code
};
var generateSecret = (userId) => {
  return authenticator.generateSecret() + userId.substring(0, 8);
};
var generateOtpCode = (secret) => {
  return authenticator.generate(secret);
};
var createAndSendOtp = async (userId, email, userName) => {
  try {
    const secret = generateSecret(userId);
    const code = generateOtpCode(secret);
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + 30);
    const otpData = {
      userId,
      code,
      expiresAt,
      isUsed: false
    };
    const otp = await storage.createOtp(otpData);
    await sendOtpEmail(email, userName, code);
    return { success: true, otp };
  } catch (error) {
    console.error("Error creating and sending OTP:", error);
    return { success: false, error };
  }
};
var verifyOtp = async (userId, code) => {
  try {
    const otp = await storage.getOtpByUserIdAndCode(userId, code);
    if (!otp) {
      return { success: false, message: "Invalid OTP code" };
    }
    const now = /* @__PURE__ */ new Date();
    const expiresAt = new Date(otp.expiresAt);
    if (now > expiresAt) {
      return { success: false, message: "OTP has expired" };
    }
    await storage.markOtpAsUsed(otp.id);
    return { success: true };
  } catch (error) {
    console.error("Error verifying OTP:", error);
    return { success: false, error, message: "Failed to verify OTP" };
  }
};
var hasActiveOtps = async (userId) => {
  try {
    const activeOtps = await storage.getActiveOtpsByUserId(userId);
    return { hasActive: activeOtps.length > 0, count: activeOtps.length };
  } catch (error) {
    console.error("Error checking active OTPs:", error);
    return { hasActive: false, error, count: 0 };
  }
};

// shared/schema.ts
import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  index,
  serial,
  boolean,
  integer
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull()
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);
var users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  isAdmin: boolean("is_admin").default(false),
  isVerified: boolean("is_verified").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var otpCodes = pgTable("otp_codes", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  code: varchar("code", { length: 6 }).notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  isUsed: boolean("is_used").default(false),
  createdAt: timestamp("created_at").defaultNow()
});
var subscriptionPlans = pgTable("subscription_plans", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  price: integer("price").notNull(),
  // in cents
  durationDays: integer("duration_days").notNull(),
  description: text("description").notNull(),
  features: text("features").array(),
  isPopular: boolean("is_popular").default(false)
});
var subscriptions = pgTable("subscriptions", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  planId: integer("plan_id").notNull().references(() => subscriptionPlans.id),
  startDate: timestamp("start_date").notNull().defaultNow(),
  endDate: timestamp("end_date").notNull(),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow()
});
var streams = pgTable("streams", {
  id: serial("id").primaryKey(),
  gameId: varchar("game_id").notNull().unique(),
  streamUrl: text("stream_url").notNull(),
  awayStreamUrl: text("away_stream_url"),
  isActive: boolean("is_active").default(true),
  addedById: varchar("added_by_id").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var leagues = pgTable("leagues", {
  id: varchar("id").primaryKey(),
  // e.g., nba, nfl, nhl, mlb
  name: varchar("name").notNull(),
  icon: varchar("icon").notNull(),
  backgroundColor: varchar("background_color").notNull(),
  enabled: boolean("enabled").default(true)
});
var streamSources = pgTable("stream_sources", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  url: text("url").notNull(),
  description: text("description"),
  isActive: boolean("is_active").default(true),
  leagueId: varchar("league_id").notNull(),
  priority: integer("priority").default(1),
  teamName: varchar("team_name").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var gameAlerts = pgTable("game_alerts", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  gameId: varchar("game_id").notNull(),
  notifyMinutesBefore: integer("notify_minutes_before").notNull(),
  isNotified: boolean("is_notified").default(false),
  createdAt: timestamp("created_at").defaultNow()
});
var networkChannels = pgTable("network_channels", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  description: text("description"),
  streamUrl: text("stream_url").notNull(),
  logoUrl: varchar("logo_url"),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow()
});
var userWatchHistory = pgTable("user_watch_history", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  gameId: varchar("game_id").notNull(),
  gameName: varchar("game_name").notNull(),
  watchStartTime: timestamp("watch_start_time").defaultNow(),
  watchEndTime: timestamp("watch_end_time"),
  durationMinutes: integer("duration_minutes").default(0),
  createdAt: timestamp("created_at").defaultNow()
});
var userTransactions = pgTable("user_transactions", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  subscriptionId: integer("subscription_id").references(() => subscriptions.id),
  amount: integer("amount").notNull(),
  // Amount in cents
  description: varchar("description").notNull(),
  transactionDate: timestamp("transaction_date").defaultNow(),
  paymentMethod: varchar("payment_method").default("card"),
  status: varchar("status").default("completed"),
  // completed, pending, failed
  createdAt: timestamp("created_at").defaultNow()
});
var insertUserSchema = createInsertSchema(users);
var insertStreamSchema = createInsertSchema(streams);
var insertStreamSourceSchema = createInsertSchema(streamSources);
var insertSubscriptionSchema = createInsertSchema(subscriptions);
var insertSubscriptionPlanSchema = createInsertSchema(subscriptionPlans);
var insertOtpSchema = createInsertSchema(otpCodes);
var insertGameAlertSchema = createInsertSchema(gameAlerts);
var insertNetworkChannelSchema = createInsertSchema(networkChannels);
var insertUserWatchHistorySchema = createInsertSchema(userWatchHistory);
var insertUserTransactionSchema = createInsertSchema(userTransactions);

// server/streamMapping.ts
var STREAM_BASE_URL = "https://vpt.pixelsport.to:443/psportsgate/psportsgate100/";
var DIRECT_STREAM_KEYS = {
  // NHL team nicknames
  "PANTHERS": 17,
  // Florida Panthers
  "JETS": 102,
  // Winnipeg Jets
  "BRUINS": 8,
  // Boston Bruins
  "STARS": 14,
  // Dallas Stars
  "OILERS": 16,
  // Edmonton Oilers
  "CANUCKS": 98,
  // Vancouver Canucks
  "FLAMES": 10,
  // Calgary Flames
  "LEAFS": 32,
  // Toronto Maple Leafs
  "HURRICANES": 137,
  // Carolina Hurricanes
  "CAPITALS": 34,
  // Washington Capitals
  "KNIGHTS": 33,
  // Vegas Golden Knights
  // MLB team nicknames - Updated May 23, 2025 with NEW M3U8 ranges (185-214)
  "ANGELS": 185,
  // Los Angeles Angels
  "ASTROS": 186,
  // Houston Astros
  "ATHLETICS": 187,
  // Oakland Athletics
  "BRAVES": 188,
  // Atlanta Braves
  "BREWERS": 189,
  // Milwaukee Brewers
  "BLUE JAYS": 190,
  // Toronto Blue Jays
  "CUBS": 191,
  // Chicago Cubs
  "CARDINALS": 192,
  // St Louis Cardinals
  "DODGERS": 193,
  // Los Angeles Dodgers
  "DIAMONDBACKS": 194,
  // Arizona Diamondbacks
  "GIANTS": 195,
  // San Francisco Giants
  "GUARDIANS": 196,
  // Cleveland Guardians
  "METS": 197,
  // New York Mets
  "MARINERS": 198,
  // Seattle Mariners
  "ORIOLES": 201,
  // Baltimore Orioles - FIXED from your M3U8
  "RED SOX": 210,
  // Boston Red Sox - FIXED from your M3U8
  "MARLINS": 199,
  // Miami Marlins
  "NATIONALS": 200,
  // Washington Nationals
  "PIRATES": 202,
  // Pittsburgh Pirates
  "PHILLIES": 203,
  // Philadelphia Phillies
  "PADRES": 204,
  // San Diego Padres
  "RAYS": 205,
  // Tampa Bay Rays
  "REDS": 206,
  // Cincinnati Reds
  "ROYALS": 207,
  // Kansas City Royals
  "RANGERS": 208,
  // Texas Rangers
  "ROCKIES": 209,
  // Colorado Rockies
  "TWINS": 211,
  // Minnesota Twins
  "TIGERS": 212,
  // Detroit Tigers
  "WHITE SOX": 213,
  // Chicago White Sox
  "YANKEES": 214
  // New York Yankees
};
var streamMap = {
  // Special channels
  "NBA TV": 1,
  "NFL NETWORK": 2,
  "ESPN US": 3,
  "NHL NETWORK": 4,
  "NFL REDZONE": 5,
  // NHL Teams
  "ANAHEIM DUCKS": 6,
  "UTAH": 7,
  // NHL team now in Utah (formerly Arizona Coyotes)
  "BOSTON BRUINS": 8,
  "BUFFALO SABRES": 9,
  "CALGARY FLAMES": 10,
  "CHICAGO BLACKHAWKS": 11,
  // Updated according to M3U8
  "COLORADO AVALANCHE": 12,
  // Updated according to M3U8
  "COLUMBUS BLUE JACKETS": 13,
  // Updated according to M3U8
  "DALLAS STARS": 14,
  // Updated according to M3U8
  "DETROIT RED WINGS": 15,
  // Updated according to M3U8
  "EDMONTON OILERS": 16,
  // Updated according to M3U8
  "FLORIDA PANTHERS": 17,
  // Updated according to M3U8
  "LOS ANGELES KINGS": 18,
  // Updated according to M3U8
  "MINNESOTA WILD": 19,
  // Updated according to M3U8
  "MONTREAL CANADIENS": 20,
  // Updated according to M3U8
  "NASHVILLE PREDATORS": 21,
  // Updated according to M3U8
  "NEW JERSEY DEVILS": 22,
  // Updated according to M3U8
  "NEW YORK ISLANDERS": 23,
  // Updated according to M3U8
  "NEW YORK RANGERS": 24,
  // Updated according to M3U8
  "OTTAWA SENATORS": 25,
  // Updated according to M3U8
  "PHILADELPHIA FLYERS": 26,
  // Updated according to M3U8
  "PITTSBURGH PENGUINS": 27,
  // Updated according to M3U8
  "SAN JOSE SHARKS": 28,
  // Updated according to M3U8
  "SEATTLE KRAKEN": 29,
  // Updated according to M3U8
  "ST LOUIS BLUES": 30,
  // Updated according to M3U8
  "ST. LOUIS BLUES": 30,
  // Alternative spelling
  "TAMPA BAY LIGHTNING": 31,
  // Updated according to M3U8
  "TORONTO MAPLE LEAFS": 32,
  // Updated according to M3U8
  "VEGAS GOLDEN KNIGHTS": 33,
  // Updated according to M3U8
  "WASHINGTON CAPITALS": 34,
  // Updated according to M3U8
  "WINNIPEG JETS": 102,
  // Updated based on M3U8 data
  "VANCOUVER CANUCKS": 98,
  // Updated based on M3U8 data
  "CAROLINA HURRICANES": 137,
  // Updated based on M3U8 data
  // NFL Teams
  "SAN FRANCISCO 49ERS": 35,
  // NFL-49ERS
  "CHICAGO BEARS": 36,
  // NFL-BEARS
  "CINCINNATI BENGALS": 37,
  // NFL-BENGALS
  "BUFFALO BILLS": 38,
  // NFL-BILLS
  "DENVER BRONCOS": 39,
  // NFL-BRONCOS
  "CLEVELAND BROWNS": 40,
  // NFL-BROWNS
  "TAMPA BAY BUCCANEERS": 41,
  // NFL-BUCCANEERS
  "ARIZONA CARDINALS": 42,
  // NFL-CARDINALS
  "LOS ANGELES CHARGERS": 43,
  // NFL-CHARGERS
  "KANSAS CITY CHIEFS": 44,
  // NFL-CHIEFS
  "INDIANAPOLIS COLTS": 45,
  // NFL-COLTS
  "MIAMI DOLPHINS": 46,
  // NFL-DOLPHINS
  "ATLANTA FALCONS": 47,
  // NFL-FALCONS
  "NEW YORK GIANTS": 48,
  // NFL-GIANTS
  "JACKSONVILLE JAGUARS": 49,
  // NFL-JAGUARS
  "NEW YORK JETS": 50,
  // NFL-JETS
  "DETROIT LIONS": 51,
  // NFL-LIONS
  "GREEN BAY PACKERS": 52,
  // NFL-PACKERS
  "CAROLINA PANTHERS": 53,
  // NFL-PANTHERS
  "NEW ENGLAND PATRIOTS": 54,
  // NFL-PATRIOTS
  "LAS VEGAS RAIDERS": 55,
  // NFL-RAIDERS
  "LOS ANGELES RAMS": 56,
  // NFL-RAMS
  "BALTIMORE RAVENS": 57,
  // NFL-RAVENS
  "NEW ORLEANS SAINTS": 58,
  // NFL-SAINTS
  "SEATTLE SEAHAWKS": 59,
  // NFL-SEAHAWKS
  "PITTSBURGH STEELERS": 60,
  // NFL-STEELERS
  "HOUSTON TEXANS": 61,
  // NFL-TEXANS
  "TENNESSEE TITANS": 62,
  // NFL-TITANS
  "MINNESOTA VIKINGS": 63,
  // NFL-VIKINGS
  "WASHINGTON COMMANDERS": 96,
  // NFL-COMMANDERS updated
  "PHILADELPHIA EAGLES": 140,
  // Updated based on M3U8 data
  "DALLAS COWBOYS": 141,
  // Updated based on M3U8 data
  // Add prefixed NFL team versions
  "NFL-49ERS": 35,
  "NFL-BEARS": 36,
  "NFL-BENGALS": 37,
  "NFL-BILLS": 38,
  "NFL-BRONCOS": 39,
  "NFL-BROWNS": 40,
  "NFL-BUCCANEERS": 41,
  "NFL-CARDINALS": 42,
  "NFL-CHARGERS": 43,
  "NFL-CHIEFS": 44,
  "NFL-COLTS": 45,
  "NFL-DOLPHINS": 46,
  "NFL-FALCONS": 47,
  "NFL-GIANTS": 48,
  "NFL-JAGUARS": 49,
  "NFL-JETS": 50,
  "NFL-LIONS": 51,
  "NFL-PACKERS": 52,
  "NFL-PANTHERS": 53,
  "NFL-PATRIOTS": 54,
  "NFL-RAIDERS": 55,
  "NFL-RAMS": 56,
  "NFL-RAVENS": 57,
  "NFL-SAINTS": 58,
  "NFL-SEAHAWKS": 59,
  "NFL-STEELERS": 60,
  "NFL-TEXANS": 61,
  "NFL-TITANS": 62,
  "NFL-VIKINGS": 63,
  "NFL-COMMANDERS": 96,
  "NFL-EAGLES": 140,
  "NFL-COWBOYS": 141,
  // NBA Teams
  "ATLANTA HAWKS": 65,
  "BOSTON CELTICS": 66,
  "BROOKLYN NETS": 67,
  "WASHINGTON WIZARDS": 68,
  "UTAH JAZZ": 69,
  "TORONTO RAPTORS": 70,
  "SAN ANTONIO SPURS": 71,
  "SACRAMENTO KINGS": 72,
  "PORTLAND TRAIL BLAZERS": 73,
  "MEMPHIS GRIZZLIES": 74,
  "MIAMI HEAT": 75,
  "MILWAUKEE BUCKS": 76,
  "MINNESOTA TIMBERWOLVES": 77,
  "NEW ORLEANS PELICANS": 78,
  "NEW YORK KNICKS": 79,
  "OKLAHOMA CITY THUNDER": 80,
  "OKLAHOMA CITY THUNDERS": 80,
  // Variation with 's'
  "ORLANDO MAGIC": 81,
  "PHILADELPHIA 76ERS": 82,
  "PHOENIX SUNS": 83,
  "DALLAS MAVERICKS": 84,
  "DENVER NUGGETS": 85,
  "DETROIT PISTONS": 86,
  "GOLDEN STATE WARRIORS": 87,
  "HOUSTON ROCKETS": 88,
  "INDIANA PACERS": 89,
  "LOS ANGELES CLIPPERS": 90,
  "LA CLIPPERS": 90,
  // Common abbreviation
  "LOS ANGELES LAKERS": 91,
  "LA LAKERS": 91,
  // Common abbreviation
  "BOSTON SELTICS": 92,
  // Typo in source
  "CHARLOTTE HORNETS": 93,
  "CHICAGO BULLS": 94,
  "CLEVELAND CAVALIERS": 95,
  "CLEVLAND CAVALIERS": 95,
  // Typo in source
  // Other NBA variations
  "LOS ANGLES CLIPPERS": 90,
  // Typo in the source
  "LOS ANGLES LAKERS": 91,
  // Typo in the source
  // MLB Teams with CORRECT IDs from your M3U8 ranges (185-214)
  "BOSTON RED SOX": 210,
  // FIXED - Updated from your M3U8
  "BALTIMORE ORIOLES": 201,
  // FIXED - Updated from your M3U8
  "LOS ANGELES ANGELS": 185,
  "HOUSTON ASTROS": 186,
  "OAKLAND ATHLETICS": 187,
  "ATLANTA BRAVES": 188,
  "MILWAUKEE BREWERS": 189,
  "TORONTO BLUE JAYS": 190,
  "CHICAGO CUBS": 191,
  "ST LOUIS CARDINALS": 192,
  "ST. LOUIS CARDINALS": 192,
  // Alternative spelling
  "LOS ANGELES DODGERS": 193,
  "ARIZONA DIAMONDBACKS": 194,
  "SAN FRANCISCO GIANTS": 195,
  "CLEVELAND GUARDIANS": 196,
  "NEW YORK METS": 197,
  "SEATTLE MARINERS": 198,
  "MIAMI MARLINS": 199,
  "WASHINGTON NATIONALS": 200,
  "PITTSBURGH PIRATES": 202,
  "PHILADELPHIA PHILLIES": 203,
  "SAN DIEGO PADRES": 204,
  "TAMPA BAY RAYS": 205,
  "CINCINNATI REDS": 206,
  "KANSAS CITY ROYALS": 207,
  "TEXAS RANGERS": 208,
  "COLORADO ROCKIES": 209,
  "MINNESOTA TWINS": 211,
  "DETROIT TIGERS": 212,
  "CHICAGO WHITE SOX": 213,
  "NEW YORK YANKEES": 214,
  // Special channels and networks
  "NHL RDS": 64,
  "NHL - 4 NATIONS 02": 97,
  "WOMEN HOCKEY - TSN 1": 99,
  "RDS 2": 100,
  "WOMEN'S HCOKEY - TSN 4": 101,
  "NHL - TVA": 103,
  "NBA - TBS": 104,
  "MLB TV": 105,
  "TSN 2": 136,
  "ESPN PLUS": 138,
  "FOX SPORT": 139,
  "MARQUEE SPORTS NETWORK": 142,
  "FIGHT NETWORK": 143,
  "TNT": 145
};
function normalizeTeamName(name) {
  let normalizedName = name.trim().toUpperCase();
  if (normalizedName === "LA CLIPPERS") {
    normalizedName = "LOS ANGELES CLIPPERS";
  } else if (normalizedName === "LA LAKERS") {
    normalizedName = "LOS ANGELES LAKERS";
  } else if (normalizedName === "OKLAHOMA CITY THUNDER") {
    normalizedName = "OKLAHOMA CITY THUNDER";
  }
  if (normalizedName === "ST. LOUIS CARDINALS") {
    normalizedName = "ST LOUIS CARDINALS";
  }
  if (normalizedName.startsWith("NFL-")) {
    return normalizedName;
  }
  const nflTeams = {
    "49ERS": "SAN FRANCISCO 49ERS",
    "BEARS": "CHICAGO BEARS",
    "BENGALS": "CINCINNATI BENGALS",
    "BILLS": "BUFFALO BILLS",
    "BRONCOS": "DENVER BRONCOS",
    "BROWNS": "CLEVELAND BROWNS",
    "BUCCANEERS": "TAMPA BAY BUCCANEERS",
    "CARDINALS": "ARIZONA CARDINALS",
    "CHARGERS": "LOS ANGELES CHARGERS",
    "CHIEFS": "KANSAS CITY CHIEFS",
    "COLTS": "INDIANAPOLIS COLTS",
    "COWBOYS": "DALLAS COWBOYS",
    "DOLPHINS": "MIAMI DOLPHINS",
    "EAGLES": "PHILADELPHIA EAGLES",
    "FALCONS": "ATLANTA FALCONS",
    "GIANTS": "NEW YORK GIANTS",
    "JAGUARS": "JACKSONVILLE JAGUARS",
    "JETS": "NEW YORK JETS",
    "LIONS": "DETROIT LIONS",
    "PACKERS": "GREEN BAY PACKERS",
    "PANTHERS": "CAROLINA PANTHERS",
    "PATRIOTS": "NEW ENGLAND PATRIOTS",
    "RAIDERS": "LAS VEGAS RAIDERS",
    "RAMS": "LOS ANGELES RAMS",
    "RAVENS": "BALTIMORE RAVENS",
    "SAINTS": "NEW ORLEANS SAINTS",
    "SEAHAWKS": "SEATTLE SEAHAWKS",
    "STEELERS": "PITTSBURGH STEELERS",
    "TEXANS": "HOUSTON TEXANS",
    "TITANS": "TENNESSEE TITANS",
    "VIKINGS": "MINNESOTA VIKINGS",
    "COMMANDERS": "WASHINGTON COMMANDERS",
    "FOOTBALL TEAM": "WASHINGTON COMMANDERS",
    // Handle old name
    "REDSKINS": "WASHINGTON COMMANDERS"
    // Handle older name
  };
  for (const [shortName, fullName] of Object.entries(nflTeams)) {
    if (normalizedName === shortName) {
      return fullName;
    }
  }
  return normalizedName;
}
function getStreamUrlForTeam(teamName) {
  if (!teamName) return null;
  const normalizedName = normalizeTeamName(teamName);
  console.log(`[StreamMapper] Looking for stream for team: "${teamName}" (normalized: "${normalizedName}")`);
  const directStreamId = DIRECT_STREAM_KEYS[normalizedName];
  if (directStreamId) {
    console.log(`[StreamMapper] Matched direct team key: ${normalizedName} \u2192 ID: ${directStreamId}`);
    const streamUrl = `${STREAM_BASE_URL}${directStreamId}.m3u8`;
    console.log(`[StreamMapper] Generated stream URL: ${streamUrl}`);
    return streamUrl;
  }
  const streamId = streamMap[normalizedName];
  if (streamId) {
    console.log(`[StreamMapper] Exact match found for: ${normalizedName} \u2192 ID: ${streamId}`);
    const streamUrl = `${STREAM_BASE_URL}${streamId}.m3u8`;
    console.log(`[StreamMapper] Generated stream URL: ${streamUrl}`);
    return streamUrl;
  }
  console.log(`[StreamMapper] No direct match found for: "${normalizedName}". Trying variations...`);
  const teamVariations = {
    // NBA Teams
    "LOS ANGELES LAKERS": ["LA LAKERS", "LAKERS", "LAL"],
    "LOS ANGELES CLIPPERS": ["LA CLIPPERS", "CLIPPERS", "LAC"],
    "GOLDEN STATE WARRIORS": ["WARRIORS", "GSW"],
    "SAN ANTONIO SPURS": ["SPURS", "SAS"],
    "OKLAHOMA CITY THUNDER": ["OKC THUNDER", "OKC", "THUNDER"],
    "NEW YORK KNICKS": ["KNICKS", "NYK"],
    "BROOKLYN NETS": ["NETS", "BKN"],
    "MILWAUKEE BUCKS": ["BUCKS", "MIL"],
    "PHILADELPHIA 76ERS": ["76ERS", "SIXERS", "PHI"],
    "TORONTO RAPTORS": ["RAPTORS", "TOR"],
    "WASHINGTON WIZARDS": ["WIZARDS", "WAS"],
    // NHL Teams
    "FLORIDA PANTHERS": ["PANTHERS", "FLA"],
    "TORONTO MAPLE LEAFS": ["MAPLE LEAFS", "LEAFS", "TOR"],
    "BOSTON BRUINS": ["BRUINS", "BOS"],
    "CAROLINA HURRICANES": ["HURRICANES", "CANES", "CAR"],
    "NEW YORK RANGERS": ["RANGERS", "NYR"],
    "DALLAS STARS": ["STARS", "DAL"],
    "COLORADO AVALANCHE": ["AVALANCHE", "AVS", "COL"],
    "EDMONTON OILERS": ["OILERS", "EDM"],
    "WINNIPEG JETS": ["JETS", "WPG"],
    "VANCOUVER CANUCKS": ["CANUCKS", "VAN"],
    "VEGAS GOLDEN KNIGHTS": ["GOLDEN KNIGHTS", "KNIGHTS", "VGK"],
    "TAMPA BAY LIGHTNING": ["LIGHTNING", "BOLTS", "TBL"],
    "WASHINGTON CAPITALS": ["CAPITALS", "CAPS", "WSH"],
    "NASHVILLE PREDATORS": ["PREDATORS", "PREDS", "NSH"],
    "NEW YORK ISLANDERS": ["ISLANDERS", "ISLES", "NYI"],
    "PITTSBURGH PENGUINS": ["PENGUINS", "PENS", "PIT"],
    "DETROIT RED WINGS": ["RED WINGS", "WINGS", "DET"],
    "CHICAGO BLACKHAWKS": ["BLACKHAWKS", "HAWKS", "CHI"],
    "LOS ANGELES KINGS": ["KINGS", "LAK"],
    "MONTREAL CANADIENS": ["CANADIENS", "HABS", "MTL"],
    "OTTAWA SENATORS": ["SENATORS", "SENS", "OTT"],
    "PHILADELPHIA FLYERS": ["FLYERS", "PHI"],
    "SAN JOSE SHARKS": ["SHARKS", "SJS"],
    "SEATTLE KRAKEN": ["KRAKEN", "SEA"],
    "ST LOUIS BLUES": ["BLUES", "STL"],
    "NEW JERSEY DEVILS": ["DEVILS", "NJD"],
    "BUFFALO SABRES": ["SABRES", "BUF"],
    "ANAHEIM DUCKS": ["DUCKS", "ANA"],
    "CALGARY FLAMES": ["FLAMES", "CGY"],
    "COLUMBUS BLUE JACKETS": ["BLUE JACKETS", "JACKETS", "CBJ"],
    "MINNESOTA WILD": ["WILD", "MIN"],
    // MLB Teams
    "ARIZONA DIAMONDBACKS": ["DIAMONDBACKS", "DBACKS", "ARI"],
    "ATLANTA BRAVES": ["BRAVES", "ATL"],
    "BALTIMORE ORIOLES": ["ORIOLES", "BAL"],
    "BOSTON RED SOX": ["RED SOX", "SOX", "BOS"],
    "CHICAGO CUBS": ["CUBS", "CHC"],
    "CHICAGO WHITE SOX": ["WHITE SOX", "CWS"],
    "CINCINNATI REDS": ["REDS", "CIN"],
    "CLEVELAND GUARDIANS": ["GUARDIANS", "CLE", "INDIANS"],
    // Include former name
    "COLORADO ROCKIES": ["ROCKIES", "COL"],
    "DETROIT TIGERS": ["TIGERS", "DET"],
    "HOUSTON ASTROS": ["ASTROS", "HOU"],
    "KANSAS CITY ROYALS": ["ROYALS", "KC"],
    "LOS ANGELES ANGELS": ["ANGELS", "LAA"],
    "LOS ANGELES DODGERS": ["DODGERS", "LAD"],
    "MIAMI MARLINS": ["MARLINS", "MIA"],
    "MILWAUKEE BREWERS": ["BREWERS", "MIL"],
    "MINNESOTA TWINS": ["TWINS", "MIN"],
    "NEW YORK METS": ["METS", "NYM"],
    "NEW YORK YANKEES": ["YANKEES", "NYY"],
    "OAKLAND ATHLETICS": ["ATHLETICS", "A'S", "OAK"],
    "PHILADELPHIA PHILLIES": ["PHILLIES", "PHI"],
    "PITTSBURGH PIRATES": ["PIRATES", "PIT"],
    "SAN DIEGO PADRES": ["PADRES", "SD"],
    "SAN FRANCISCO GIANTS": ["GIANTS", "SF"],
    "SEATTLE MARINERS": ["MARINERS", "SEA"],
    "ST LOUIS CARDINALS": ["CARDINALS", "STL"],
    "TAMPA BAY RAYS": ["RAYS", "TB"],
    "TEXAS RANGERS": ["RANGERS", "TEX"],
    "TORONTO BLUE JAYS": ["BLUE JAYS", "JAYS", "TOR"],
    "WASHINGTON NATIONALS": ["NATIONALS", "NATS", "WSH"],
    // MLB prefix format
    "MLB - ARIZONA DIAMONDBACKS": ["MLB - DIAMONDBACKS", "MLB - ARI"],
    "MLB - ATLANTA BRAVES": ["MLB - BRAVES", "MLB - ATL"],
    "MLB - BALTIMORE ORIOLES": ["MLB - ORIOLES", "MLB - BAL"],
    "MLB - BOSTON RED SOX": ["MLB - RED SOX", "MLB - BOS"],
    "MLB - CHICAGO CUBS": ["MLB - CUBS", "MLB - CHC"],
    "MLB - CHICAGO WHITE SOX": ["MLB - WHITE SOX", "MLB - CWS"],
    "MLB - CINCINNATI REDS": ["MLB - REDS", "MLB - CIN"],
    "MLB - CLEVELAND GUARDIANS": ["MLB - GUARDIANS", "MLB - CLE"],
    "MLB - COLORADO ROCKIES": ["MLB - ROCKIES", "MLB - COL"],
    "MLB - DETROIT TIGERS": ["MLB - TIGERS", "MLB - DET"],
    "MLB - HOUSTON ASTROS": ["MLB - ASTROS", "MLB - HOU"],
    "MLB - KANSAS CITY ROYALS": ["MLB - ROYALS", "MLB - KC"],
    "MLB - LOS ANGELES ANGELS": ["MLB - ANGELS", "MLB - LAA"],
    "MLB - LOS ANGELES DODGERS": ["MLB - DODGERS", "MLB - LAD"],
    "MLB - MIAMI MARLINS": ["MLB - MARLINS", "MLB - MIA"],
    "MLB - MILWAUKEE BREWERS": ["MLB - BREWERS", "MLB - MIL"],
    "MLB - MINNESOTA TWINS": ["MLB - TWINS", "MLB - MIN"],
    "MLB - NEW YORK METS": ["MLB - METS", "MLB - NYM"],
    "MLB - NEW YORK YANKEES": ["MLB - YANKEES", "MLB - NYY"],
    "MLB - OAKLAND ATHLETICS": ["MLB - ATHLETICS", "MLB - A'S", "MLB - OAK"],
    "MLB - PHILADELPHIA PHILLIES": ["MLB - PHILLIES", "MLB - PHI"],
    "MLB - PITTSBURGH PIRATES": ["MLB - PIRATES", "MLB - PIT"],
    "MLB - SAN DIEGO PADRES": ["MLB - PADRES", "MLB - SD"],
    "MLB - SAN FRANCISCO GIANTS": ["MLB - GIANTS", "MLB - SF"],
    "MLB - SEATTLE MARINERS": ["MLB - MARINERS", "MLB - SEA"],
    "MLB - ST LOUIS CARDINALS": ["MLB - CARDINALS", "MLB - STL"],
    "MLB - TAMPA BAY RAYS": ["MLB - RAYS", "MLB - TB"],
    "MLB - TEXAS RANGERS": ["MLB - RANGERS", "MLB - TEX"],
    "MLB - TORONTO BLUE JAYS": ["MLB - BLUE JAYS", "MLB - JAYS", "MLB - TOR"],
    "MLB - WASHINGTON NATIONALS": ["MLB - NATIONALS", "MLB - NATS", "MLB - WSH"]
  };
  for (const [fullName, variations] of Object.entries(teamVariations)) {
    if (variations.includes(normalizedName) && streamMap[fullName]) {
      console.log(`[StreamMapper] Matched team variation: ${normalizedName} \u2192 ${fullName} (ID: ${streamMap[fullName]})`);
      return `${STREAM_BASE_URL}${streamMap[fullName]}.m3u8`;
    }
  }
  for (const [fullName, variations] of Object.entries(teamVariations)) {
    for (const variation of variations) {
      if ((normalizedName.includes(variation) || variation.includes(normalizedName)) && variation.length > 3 && normalizedName.length > 3 && streamMap[fullName]) {
        console.log(`[StreamMapper] Matched partial variation: "${normalizedName}" contains/within "${variation}" \u2192 ${fullName} (ID: ${streamMap[fullName]})`);
        return `${STREAM_BASE_URL}${streamMap[fullName]}.m3u8`;
      }
    }
  }
  console.log(`[StreamMapper] No variations matched for "${normalizedName}", trying partial key matches...`);
  const streamMapKeys = Object.keys(streamMap);
  for (const key2 of streamMapKeys) {
    if ((key2.includes(normalizedName) || normalizedName.includes(key2)) && key2.length > 4 && normalizedName.length > 3) {
      console.log(`[StreamMapper] Partial key match: "${normalizedName}" matches with "${key2}" (ID: ${streamMap[key2]})`);
      return `${STREAM_BASE_URL}${streamMap[key2]}.m3u8`;
    }
  }
  if (teamName.length > 3) {
    for (const key2 of streamMapKeys) {
      if (key2.startsWith("NFL-") && key2.substring(4).includes(normalizedName)) {
        console.log(`[StreamMapper] Matched NFL team format: '${normalizedName}' \u2192 '${key2}' (ID: ${streamMap[key2]})`);
        return `${STREAM_BASE_URL}${streamMap[key2]}.m3u8`;
      }
    }
    if (normalizedName.includes("NFL") || normalizedName.includes("FOOTBALL")) {
      for (const key2 of streamMapKeys) {
        if (key2.startsWith("NFL-") && (normalizedName.includes(key2.substring(4)) || key2.substring(4).includes(normalizedName))) {
          console.log(`[StreamMapper] Loose NFL team match: '${normalizedName}' \u2192 '${key2}' (ID: ${streamMap[key2]})`);
          return `${STREAM_BASE_URL}${streamMap[key2]}.m3u8`;
        }
      }
    }
  }
  console.log(`[StreamMapper] No stream ID found for team: ${teamName} (normalized: ${normalizedName})`);
  return null;
}
function extractTeamsFromGameName(game) {
  const name = game.name;
  if (game.homeTeam?.name && game.awayTeam?.name) {
    return {
      homeTeam: game.homeTeam.name,
      awayTeam: game.awayTeam.name
    };
  }
  let homeTeam = "";
  let awayTeam = "";
  if (name.includes(" at ")) {
    [awayTeam, homeTeam] = name.split(" at ").map((s) => s.trim());
  } else if (name.includes(" vs ")) {
    const parts = name.split(" vs ").map((s) => s.trim());
    if (name.toLowerCase().includes("home") || name.toLowerCase().includes("away")) {
      if (parts[0].includes(game.homeTeam?.name || "")) {
        homeTeam = parts[0];
        awayTeam = parts[1];
      } else {
        homeTeam = parts[1];
        awayTeam = parts[0];
      }
    } else {
      awayTeam = parts[0];
      homeTeam = parts[1];
    }
  } else if (name.includes(" @ ")) {
    [awayTeam, homeTeam] = name.split(" @ ").map((s) => s.trim());
  } else if (name.includes(" - ")) {
    const parts = name.split(" - ").map((s) => s.trim());
    homeTeam = parts[0];
    awayTeam = parts[1];
  } else {
    if (game.shortName) {
      const parts = game.shortName.split(" @ ").map((s) => s.trim());
      if (parts.length === 2) {
        [awayTeam, homeTeam] = parts;
      } else {
        const vsParts = game.shortName.split(" vs ").map((s) => s.trim());
        if (vsParts.length === 2) {
          awayTeam = vsParts[0];
          homeTeam = vsParts[1];
        }
      }
    }
  }
  if (!homeTeam && !awayTeam && game.homeTeam?.abbreviation && game.awayTeam?.abbreviation) {
    homeTeam = game.homeTeam.name;
    awayTeam = game.awayTeam.name;
  }
  if (!homeTeam || !awayTeam) {
    console.warn(`Could not parse teams from game name: ${name}`);
    return {
      homeTeam: game.homeTeam?.name || "",
      awayTeam: game.awayTeam?.name || ""
    };
  }
  return { homeTeam, awayTeam };
}
function getStreamUrlsForGame(game) {
  try {
    const { homeTeam, awayTeam } = extractTeamsFromGameName(game);
    if (!homeTeam || !awayTeam) {
      console.warn(`Missing team information for game: ${game.id}`);
      return { homeTeamStreamUrl: null, awayTeamStreamUrl: null };
    }
    console.log(`[StreamMapper] Looking up streams for: ${awayTeam} @ ${homeTeam} (${game.league.toUpperCase()} game)`);
    let homeTeamStreamUrl = getStreamUrlForTeam(homeTeam);
    let awayTeamStreamUrl = getStreamUrlForTeam(awayTeam);
    if (!homeTeamStreamUrl && game.homeTeam?.name) {
      console.log(`[StreamMapper] Trying alternative name for home team: ${game.homeTeam.name}`);
      homeTeamStreamUrl = getStreamUrlForTeam(game.homeTeam.name);
      if (!homeTeamStreamUrl && game.homeTeam?.abbreviation) {
        console.log(`[StreamMapper] Trying abbreviation for home team: ${game.homeTeam.abbreviation}`);
        homeTeamStreamUrl = getStreamUrlForTeam(game.homeTeam.abbreviation);
      }
    }
    if (!awayTeamStreamUrl && game.awayTeam?.name) {
      console.log(`[StreamMapper] Trying alternative name for away team: ${game.awayTeam.name}`);
      awayTeamStreamUrl = getStreamUrlForTeam(game.awayTeam.name);
      if (!awayTeamStreamUrl && game.awayTeam?.abbreviation) {
        console.log(`[StreamMapper] Trying abbreviation for away team: ${game.awayTeam.abbreviation}`);
        awayTeamStreamUrl = getStreamUrlForTeam(game.awayTeam.abbreviation);
      }
    }
    if (!homeTeamStreamUrl && game.league === "nhl") {
      console.log(`[StreamMapper] Trying NHL prefix for home team: VIP NHL ${homeTeam}`);
      homeTeamStreamUrl = getStreamUrlForTeam(`VIP NHL ${homeTeam}`);
    }
    if (!awayTeamStreamUrl && game.league === "nhl") {
      console.log(`[StreamMapper] Trying NHL prefix for away team: VIP NHL ${awayTeam}`);
      awayTeamStreamUrl = getStreamUrlForTeam(`VIP NHL ${awayTeam}`);
    }
    if (!homeTeamStreamUrl && game.league === "nfl") {
      const normalizedName = normalizeTeamName(homeTeam);
      const lastSegment = normalizedName.split(" ").pop();
      if (lastSegment) {
        console.log(`[StreamMapper] Trying NFL format for home team: NFL-${lastSegment}`);
        homeTeamStreamUrl = getStreamUrlForTeam(`NFL-${lastSegment}`);
      }
    }
    if (!awayTeamStreamUrl && game.league === "nfl") {
      const normalizedName = normalizeTeamName(awayTeam);
      const lastSegment = normalizedName.split(" ").pop();
      if (lastSegment) {
        console.log(`[StreamMapper] Trying NFL format for away team: NFL-${lastSegment}`);
        awayTeamStreamUrl = getStreamUrlForTeam(`NFL-${lastSegment}`);
      }
    }
    if (!homeTeamStreamUrl && game.league === "nba") {
      console.log(`[StreamMapper] Trying NBA prefix for home team: VIP NBA ${homeTeam}`);
      homeTeamStreamUrl = getStreamUrlForTeam(`VIP NBA ${homeTeam}`);
    }
    if (!awayTeamStreamUrl && game.league === "nba") {
      console.log(`[StreamMapper] Trying NBA prefix for away team: VIP NBA ${awayTeam}`);
      awayTeamStreamUrl = getStreamUrlForTeam(`VIP NBA ${awayTeam}`);
    }
    if (!homeTeamStreamUrl && game.league === "mlb") {
      console.log(`[StreamMapper] Trying MLB prefix for home team: MLB - ${homeTeam}`);
      homeTeamStreamUrl = getStreamUrlForTeam(`MLB - ${homeTeam}`);
      if (!homeTeamStreamUrl && game.homeTeam?.abbreviation) {
        const abbreviation = game.homeTeam.abbreviation;
        console.log(`[StreamMapper] Trying MLB prefix with abbreviation for home team: MLB - ${abbreviation}`);
        homeTeamStreamUrl = getStreamUrlForTeam(`MLB - ${abbreviation}`);
      }
    }
    if (!awayTeamStreamUrl && game.league === "mlb") {
      console.log(`[StreamMapper] Trying MLB prefix for away team: MLB - ${awayTeam}`);
      awayTeamStreamUrl = getStreamUrlForTeam(`MLB - ${awayTeam}`);
      if (!awayTeamStreamUrl && game.awayTeam?.abbreviation) {
        const abbreviation = game.awayTeam.abbreviation;
        console.log(`[StreamMapper] Trying MLB prefix with abbreviation for away team: MLB - ${abbreviation}`);
        awayTeamStreamUrl = getStreamUrlForTeam(`MLB - ${abbreviation}`);
      }
    }
    console.log(`[StreamMapper] Results - Home team (${homeTeam}): ${homeTeamStreamUrl ? "Found" : "Not found"}, Away team (${awayTeam}): ${awayTeamStreamUrl ? "Found" : "Not found"}`);
    return { homeTeamStreamUrl, awayTeamStreamUrl };
  } catch (error) {
    console.error("[StreamMapper] Error getting stream URLs for game:", error);
    return { homeTeamStreamUrl: null, awayTeamStreamUrl: null };
  }
}

// server/routes.ts
import fetch3 from "node-fetch";

// server/routes/streamUrlEditor.ts
init_supabaseAuth();
init_adminMiddleware();
init_db();
init_streamSourcesLatestFixed();
import { Router } from "express";
var router2 = Router();
router2.patch("/:id", isAuthenticated, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { url } = req.body;
    if (!url || typeof url !== "string") {
      return res.status(400).json({ error: "Valid URL is required" });
    }
    console.log(`Updating stream URL for ID ${id} to ${url}`);
    try {
      const standardizedUrl = standardizeStreamUrl(url);
      const { data, error } = await supabase2.from("stream_sources").update({
        url: standardizedUrl,
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }).eq("id", parseInt(id, 10)).select();
      if (error) {
        console.error("Error updating stream source:", error);
        return res.status(500).json({ error: "Failed to update stream URL" });
      }
      if (!data || data.length === 0) {
        console.error("Error updating stream source: No result returned");
        return res.status(500).json({ error: "Failed to update stream URL" });
      }
    } catch (updateError) {
      console.error("Error updating stream source:", updateError);
      return res.status(500).json({ error: "Failed to update stream URL" });
    }
    const globalObj = global;
    if (globalObj.cachedStreamSources) {
      console.log("Clearing global stream sources cache");
      globalObj.cachedStreamSources = null;
    }
    console.log(`Stream URL updated for ID ${id}: ${url}`);
    res.json({
      success: true,
      message: "Stream URL updated and cache refreshed",
      data: { id, url: standardizeStreamUrl(url) }
    });
  } catch (error) {
    console.error("Error updating stream source URL:", error);
    res.status(500).json({ error: "Failed to update stream source URL" });
  }
});
var streamUrlEditor_default = router2;

// server/routes/directStreamUrl.js
import { Router as Router2 } from "express";

// server/services/streamUrlService.js
init_db();

// server/services/persistentStorage.js
import fs2 from "fs";
import path2 from "path";
var STORAGE_FILE = path2.join(process.cwd(), "stream-url-storage.json");
var PersistentStorage = class {
  constructor() {
    this.data = {};
    this.loadFromDisk();
    setInterval(() => this.saveToDisk(), 3e4);
  }
  // Load data from persistent storage
  loadFromDisk() {
    try {
      if (fs2.existsSync(STORAGE_FILE)) {
        const fileContents = fs2.readFileSync(STORAGE_FILE, "utf8");
        this.data = JSON.parse(fileContents);
        console.log(`Loaded ${Object.keys(this.data).length} items from persistent storage`);
      } else {
        console.log("No persistent storage file found, starting with empty storage");
      }
    } catch (error) {
      console.error("Error loading from persistent storage:", error);
      this.data = {};
    }
  }
  // Save data to persistent storage
  saveToDisk() {
    try {
      if (Object.keys(this.data).length > 0) {
        fs2.writeFileSync(STORAGE_FILE, JSON.stringify(this.data, null, 2), "utf8");
      }
    } catch (error) {
      console.error("Error saving to persistent storage:", error);
    }
  }
  // Synchronous version to force immediate saving without waiting for the interval
  saveToDiskSync() {
    try {
      if (Object.keys(this.data).length > 0) {
        fs2.writeFileSync(STORAGE_FILE, JSON.stringify(this.data, null, 2), "utf8");
        console.log(`Successfully saved ${Object.keys(this.data).length} items to persistent storage file`);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error in synchronous save to persistent storage:", error);
      return false;
    }
  }
  // Get an item from storage
  get(key2) {
    return this.data[key2];
  }
  // Set an item in storage
  set(key2, value) {
    this.data[key2] = value;
    this.saveToDisk();
    return value;
  }
  // Get all items as an object
  getAll() {
    return this.data;
  }
  // Get all keys
  getKeys() {
    return Object.keys(this.data);
  }
  // Check if an item exists
  has(key2) {
    return key2 in this.data;
  }
  // Remove an item
  remove(key2) {
    if (this.has(key2)) {
      delete this.data[key2];
      this.saveToDisk();
      return true;
    }
    return false;
  }
  // Clear all items
  clear() {
    this.data = {};
    this.saveToDisk();
  }
};
var persistentStorage = new PersistentStorage();

// server/services/loadStreamSources.js
import fs3 from "fs";
import path3 from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
function loadStreamSources() {
  try {
    const jsonFilePath = path3.resolve(process.cwd(), "stream-url-storage.json");
    if (!fs3.existsSync(jsonFilePath)) {
      console.error("Stream sources file not found:", jsonFilePath);
      return [];
    }
    const jsonData = fs3.readFileSync(jsonFilePath, "utf8");
    const sources = JSON.parse(jsonData);
    const sourcesList = Object.values(sources).map((source) => {
      let url = source.stream_url || source.url;
      if (url && url.includes("pixelsport.to")) {
        url = url.replace("vp.pixelsport.to", "vpt.pixelsport.to");
      }
      return {
        id: source.id,
        name: source.name,
        url,
        teamName: source.teamName || source.name,
        leagueId: source.leagueId || "other",
        isActive: true,
        priority: 1
      };
    });
    console.log(`Loaded ${sourcesList.length} stream sources from local JSON file`);
    return sourcesList;
  } catch (error) {
    console.error("Error loading stream sources from JSON file:", error);
    return [];
  }
}
function getStreamSourceById(id) {
  const allSources = loadStreamSources();
  return allSources.find((source) => source.id === parseInt(id, 10)) || null;
}
function getStreamUrlByTeamName(teamName) {
  if (!teamName) return null;
  const allSources = loadStreamSources();
  const matchingSource = allSources.find((source) => {
    const sourceTeamName = source.teamName || source.name || "";
    const normalizedSourceName = sourceTeamName.toLowerCase().trim();
    const normalizedSearchName = teamName.toLowerCase().trim();
    return normalizedSourceName === normalizedSearchName || normalizedSourceName.includes(normalizedSearchName) || normalizedSearchName.includes(normalizedSourceName);
  });
  return matchingSource ? matchingSource.url : null;
}
var loadStreamSources_default = {
  loadStreamSources,
  getStreamSourceById,
  getStreamUrlByTeamName
};

// server/services/streamUrlService.js
var StreamUrlService = class {
  /**
   * Ensure the stream_sources table exists
   * @returns {Promise<boolean>} Whether the table exists
   */
  async ensureTableExists() {
    try {
      console.log("Checking if stream_sources table exists...");
      const { data, error } = await supabase2.from("stream_sources").select("id").limit(1);
      if (error && error.code === "42P01") {
        console.log("Table not found, creating it directly");
        const { data: streams2, error: streamsError } = await supabase2.from("streams").select("*").limit(20);
        if (streamsError) {
          console.error("Error fetching streams:", streamsError);
          return false;
        }
        if (streams2 && streams2.length > 0) {
          console.log(`Creating stream_sources from ${streams2.length} existing streams`);
          const sourcesToInsert = streams2.map((stream, index2) => ({
            name: `Stream Source ${index2 + 1}`,
            team_name: `Team ${index2 + 1}`,
            url: stream.stream_url || "https://vp.pixelsport.to:443/psportsgate/psportsgate100/1.m3u8",
            league_id: "nba",
            is_active: true,
            priority: 1,
            description: `Stream source created from stream ID ${stream.id}`
          }));
          const { error: insertError } = await supabase2.from("stream_sources").insert(sourcesToInsert);
          if (insertError) {
            console.error("Error inserting initial stream sources:", insertError);
            return false;
          }
          console.log("Successfully created stream_sources table with initial data");
          return true;
        } else {
          const defaultSources = [\
            {\
              name: "NBA TV",\
              team_name: "NBA TV",\
              url: "https://vpt.pixelsport.to:443/psportsgate/psportsgate100/1.m3u8",\
              league_id: "special",\
              is_active: true,\
              priority: 1,\
              description: "NBA TV Network"\
            },\
            {\
              name: "NFL Network",\
              team_name: "NFL Network",\
              url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/2.m3u8",\
              league_id: "special",\
              is_active: true,\
              priority: 1,\
              description: "NFL Network"\
            }\
          ];
          const { error: insertError } = await supabase2.from("stream_sources").insert(defaultSources);
          if (insertError) {
            console.error("Error inserting default stream sources:", insertError);
            return false;
          }
          console.log("Successfully created stream_sources table with default data");
          return true;
        }
      }
      console.log("stream_sources table already exists");
      return true;
    } catch (error) {
      console.error("Error ensuring table exists:", error);
      return false;
    }
  }
  /**
   * Update a stream URL by ID using streams table instead of stream_sources
   * @param {number} id - Stream source ID
   * @param {string} url - New stream URL
   * @returns {Promise<Object|null>} Updated stream source or null if failed
   */
  async updateStreamUrl(id, url) {
    try {
      console.log(`StreamUrlService: Updating stream URL for ID ${id} to ${url}`);
      if (!id || !url) {
        console.error("Invalid ID or URL provided");
        return null;
      }
      let name = `Stream ${id}`;
      let teamName = `Team ${id}`;
      let leagueId = "other";
      if (id >= 1 && id <= 5) {
        const specialNames = {
          1: "NBA TV",
          2: "NFL Network",
          3: "MLB Network",
          4: "NHL Network",
          5: "ESPN"
        };
        name = specialNames[id] || `Special Channel ${id}`;
        teamName = name;
        leagueId = "special";
      } else if (id >= 6 && id <= 35) {
        name = `NHL - Team ${id}`;
        teamName = `NHL Team ${id}`;
        leagueId = "nhl";
      } else if (id >= 185 && id <= 214) {
        name = `MLB - Team ${id}`;
        teamName = `MLB Team ${id}`;
        leagueId = "mlb";
      } else if (id >= 66 && id <= 97) {
        name = `NFL - Team ${id}`;
        teamName = `NFL Team ${id}`;
        leagueId = "nfl";
      } else if (id >= 98 && id <= 127) {
        name = `NBA - Team ${id}`;
        teamName = `NBA Team ${id}`;
        leagueId = "nba";
      }
      const existingSource = this.inMemoryStreamUrls?.[id] || (persistentStorage.has(`stream_source_${id}`) ? persistentStorage.get(`stream_source_${id}`) : null);
      let predefinedTeam = null;
      if (!existingSource) {
        const allPredefinedSources = this.getPredefinedStreamSources();
        predefinedTeam = allPredefinedSources.find((source) => source.id === id);
      }
      const updatedSource = {
        id,
        name: existingSource?.name || predefinedTeam?.name || name,
        url,
        // Always use the new URL
        description: existingSource?.description || predefinedTeam?.description || `Stream source ID ${id}`,
        isActive: existingSource?.isActive !== void 0 ? existingSource.isActive : predefinedTeam?.isActive || true,
        leagueId: existingSource?.leagueId || predefinedTeam?.leagueId || leagueId,
        priority: existingSource?.priority || predefinedTeam?.priority || 1,
        teamName: existingSource?.teamName || predefinedTeam?.teamName || teamName,
        createdAt: existingSource?.createdAt || predefinedTeam?.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        // Always update the timestamp
      };
      console.log(`Successfully processed stream URL update for ID ${id}`);
      const storageKey = `stream_source_${id}`;
      persistentStorage.set(storageKey, updatedSource);
      console.log(`Stream source ${id} saved to persistent storage`);
      persistentStorage.saveToDiskSync();
      console.log("Force-saved all stream sources to disk to prevent data loss");
      if (!this.inMemoryStreamUrls) {
        this.inMemoryStreamUrls = {};
      }
      this.inMemoryStreamUrls[id] = updatedSource;
      try {
        console.log(`Updating stream source in database for ID ${id}`);
        const dbRecord = {
          id,
          name: updatedSource.name,
          team_name: updatedSource.teamName,
          url: updatedSource.url,
          description: updatedSource.description || "",
          is_active: updatedSource.isActive,
          league_id: updatedSource.leagueId,
          priority: updatedSource.priority || 1,
          updated_at: /* @__PURE__ */ new Date()
        };
        const { error } = await supabase2.from("stream_sources").upsert(dbRecord, { onConflict: "id" });
        if (error) {
          console.error("Error updating stream source in database:", error);
          console.log("Continuing with local cache update only. Changes will be temporary until database is synced.");
        } else {
          console.log(`Successfully updated stream source ${id} in database`);
        }
      } catch (dbError) {
        console.error("Database update failed, but local cache is updated:", dbError);
      }
      return updatedSource;
    } catch (error) {
      console.error("Exception in updateStreamUrl:", error);
      return null;
    }
  }
  /**
   * Delete a stream source by ID
   * @param {number} id - The ID of the stream source to delete
   * @returns {Promise<boolean>} - Whether the deletion was successful
   */
  async deleteStreamSource(id) {
    try {
      console.log("Deleting stream source with ID:", id);
      const { error } = await supabase2.from("stream_sources").delete().eq("id", id);
      if (error) {
        console.error("Error deleting stream source from database:", error);
        return false;
      }
      persistentStorage.remove(id.toString());
      if (this.inMemoryStreamUrls && this.inMemoryStreamUrls[id]) {
        delete this.inMemoryStreamUrls[id];
      }
      console.log("Successfully deleted stream source with ID:", id);
      return true;
    } catch (error) {
      console.error("Exception in deleteStreamSource:", error);
      return false;
    }
  }
  /**
   * Create a new stream source
   * This can be used to ensure the table exists
   */
  async createStreamSource(streamSource) {
    try {
      const { data, error } = await supabase2.from("stream_sources").insert({
        name: streamSource.name,
        url: streamSource.url,
        description: streamSource.description || "",
        is_active: streamSource.isActive !== void 0 ? streamSource.isActive : true,
        league_id: streamSource.leagueId,
        priority: streamSource.priority || 1,
        team_name: streamSource.teamName
      }).select().single();
      if (error) {
        console.error("Error creating stream source:", error);
        return null;
      }
      return data;
    } catch (error) {
      console.error("Exception in createStreamSource:", error);
      return null;
    }
  }
  /**
   * Get all stream sources - returns predefined sources plus any updates
   * with robust handling of data merging and validation
   */
  async getAllStreamSources() {
    try {
      console.log("Loading stream sources from local file first");
      const localSources = loadStreamSources_default.loadStreamSources();
      if (localSources && localSources.length > 0) {
        console.log(`Using ${localSources.length} stream sources from local file`);
        return localSources;
      }
      try {
        const { data, error } = await supabase2.from("stream_sources").select("*").limit(1);
        if (!error && data && data.length > 0) {
          console.log("Using stream_sources table data as fallback");
          const { data: allData, error: fetchError } = await supabase2.from("stream_sources").select("*").order("id", { ascending: true });
          if (fetchError) {
            console.error("Error fetching stream sources from database:", fetchError);
            return this.getStreamSourcesWithFallback();
          }
          return allData.map((source) => ({
            id: source.id,
            name: source.name,
            url: source.url,
            description: source.description,
            isActive: source.is_active,
            leagueId: source.league_id,
            priority: source.priority,
            teamName: source.team_name,
            createdAt: source.created_at,
            updatedAt: source.updated_at
          }));
        }
      } catch (dbError) {
        console.error("Database error, using fallback:", dbError);
      }
      return this.getStreamSourcesWithFallback();
    } catch (error) {
      console.error("Exception in getAllStreamSources:", error);
      return this.getStreamSourcesWithFallback();
    }
  }
  /**
   * Advanced stream sources retrieval with multiple fallback mechanisms
   * to ensure all 159 stream sources are always available
   */
  getStreamSourcesWithFallback() {
    console.log("Using enhanced stream sources retrieval with fallbacks");
    const predefinedSources = this.getPredefinedStreamSources();
    const completeSourcesById = {};
    predefinedSources.forEach((source) => {
      completeSourcesById[source.id] = { ...source };
    });
    const predefinedTeamNames = {};
    const predefinedNames = {};
    predefinedSources.forEach((source) => {
      if (source.teamName) {
        predefinedTeamNames[source.id] = source.teamName;
      }
      if (source.name) {
        predefinedNames[source.id] = source.name;
      }
    });
    if (this.inMemoryStreamUrls) {
      Object.values(this.inMemoryStreamUrls).forEach((source) => {
        if (source && source.id) {
          if (completeSourcesById[source.id]) {
            completeSourcesById[source.id] = {
              ...completeSourcesById[source.id],
              ...source,
              // Ensure these critical fields use predefined values when available
              name: predefinedNames[source.id] || source.name || completeSourcesById[source.id].name,
              teamName: predefinedTeamNames[source.id] || source.teamName || completeSourcesById[source.id].teamName
            };
          } else {
            completeSourcesById[source.id] = { ...source };
          }
        }
      });
    }
    const storedKeys = persistentStorage.getKeys().filter((key2) => key2.startsWith("stream_source_"));
    if (storedKeys.length > 0) {
      console.log(`Applying ${storedKeys.length} persistent updates to stream sources, preserving predefined team names`);
      storedKeys.forEach((key2) => {
        const storedSource = persistentStorage.get(key2);
        if (storedSource && storedSource.id) {
          const id = storedSource.id;
          if (completeSourcesById[id]) {
            completeSourcesById[id] = {
              ...completeSourcesById[id],
              ...storedSource,
              // Always use predefined team names when available
              name: predefinedNames[id] || storedSource.name || completeSourcesById[id].name,
              teamName: predefinedTeamNames[id] || storedSource.teamName || completeSourcesById[id].teamName
            };
          } else {
            completeSourcesById[id] = { ...storedSource };
          }
        }
      });
    }
    let resultSources = Object.values(completeSourcesById);
    const expectedIds = Array.from({ length: 159 }, (_, i) => i + 1);
    const missingIds = expectedIds.filter((id) => !completeSourcesById[id]);
    if (missingIds.length > 0) {
      console.warn(`Found ${missingIds.length} missing stream sources, restoring from defaults`);
      missingIds.forEach((id) => {
        let name = `Stream ${id}`;
        let teamName = `Team ${id}`;
        let leagueId = "other";
        if (id >= 1 && id <= 5) {
          const specialNames = {
            1: "NBA TV",
            2: "NFL Network",
            3: "MLB Network",
            4: "NHL Network",
            5: "ESPN"
          };
          name = specialNames[id] || `Special Channel ${id}`;
          teamName = name;
          leagueId = "special";
        } else if (id >= 6 && id <= 35) {
          name = `NHL - Team ${id}`;
          teamName = `NHL Team ${id}`;
          leagueId = "nhl";
        } else if (id >= 36 && id <= 65) {
          name = `MLB - Team ${id}`;
          teamName = `MLB Team ${id}`;
          leagueId = "mlb";
        } else if (id >= 66 && id <= 97) {
          name = `NFL - Team ${id}`;
          teamName = `NFL Team ${id}`;
          leagueId = "nfl";
        } else if (id >= 98 && id <= 127) {
          name = `NBA - Team ${id}`;
          teamName = `NBA Team ${id}`;
          leagueId = "nba";
        } else {
          name = `Additional Channel ${id}`;
          teamName = name;
          leagueId = "other";
        }
        resultSources.push({
          id,
          name,
          teamName,
          leagueId,
          url: `https://vp.pixelsport.to:443/psportsgate/psportsgate100/${id}.m3u8`,
          isActive: true,
          priority: 1,
          description: `Stream source ${id}`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      });
      resultSources.sort((a, b) => a.id - b.id);
    }
    console.log(`Returning ${resultSources.length} total stream sources`);
    return resultSources;
  }
  /**
   * Get predefined stream sources with any persistent updates applied
   */
  getPredefinedStreamSources() {
    const streamSources2 = [];
    const specialChannels = [\
      { id: 1, name: "NBA TV", teamName: "NBA TV", leagueId: "special" },\
      { id: 2, name: "NFL Network", teamName: "NFL Network", leagueId: "special" },\
      { id: 3, name: "MLB Network", teamName: "MLB Network", leagueId: "special" },\
      { id: 4, name: "NHL Network", teamName: "NHL Network", leagueId: "special" },\
      { id: 5, name: "ESPN", teamName: "ESPN", leagueId: "special" }\
    ];
    const nhlTeams = [];
    for (let i = 6; i <= 35; i++) {
      nhlTeams.push({
        id: i,
        name: `NHL - Team ${i}`,
        teamName: `NHL Team ${i}`,
        leagueId: "nhl"
      });
    }
    const realNhlTeams = [\
      { id: 6, name: "NHL - Anaheim Ducks", teamName: "Anaheim Ducks", leagueId: "nhl" },\
      { id: 7, name: "NHL - Arizona Coyotes", teamName: "Arizona Coyotes", leagueId: "nhl" },\
      { id: 8, name: "NHL - Boston Bruins", teamName: "Boston Bruins", leagueId: "nhl" },\
      { id: 9, name: "NHL - Buffalo Sabres", teamName: "Buffalo Sabres", leagueId: "nhl" },\
      { id: 10, name: "NHL - Calgary Flames", teamName: "Calgary Flames", leagueId: "nhl" },\
      { id: 11, name: "NHL - Carolina Hurricanes", teamName: "Carolina Hurricanes", leagueId: "nhl" },\
      { id: 12, name: "NHL - Chicago Blackhawks", teamName: "Chicago Blackhawks", leagueId: "nhl" },\
      { id: 13, name: "NHL - Colorado Avalanche", teamName: "Colorado Avalanche", leagueId: "nhl" },\
      { id: 14, name: "NHL - Columbus Blue Jackets", teamName: "Columbus Blue Jackets", leagueId: "nhl" },\
      { id: 15, name: "NHL - Dallas Stars", teamName: "Dallas Stars", leagueId: "nhl" },\
      { id: 16, name: "NHL - Detroit Red Wings", teamName: "Detroit Red Wings", leagueId: "nhl" },\
      { id: 17, name: "NHL - Edmonton Oilers", teamName: "Edmonton Oilers", leagueId: "nhl" },\
      { id: 18, name: "NHL - Florida Panthers", teamName: "Florida Panthers", leagueId: "nhl" },\
      { id: 19, name: "NHL - Los Angeles Kings", teamName: "Los Angeles Kings", leagueId: "nhl" },\
      { id: 20, name: "NHL - Minnesota Wild", teamName: "Minnesota Wild", leagueId: "nhl" },\
      { id: 21, name: "NHL - Montreal Canadiens", teamName: "Montreal Canadiens", leagueId: "nhl" },\
      { id: 22, name: "NHL - Nashville Predators", teamName: "Nashville Predators", leagueId: "nhl" },\
      { id: 23, name: "NHL - New Jersey Devils", teamName: "New Jersey Devils", leagueId: "nhl" },\
      { id: 24, name: "NHL - New York Islanders", teamName: "New York Islanders", leagueId: "nhl" },\
      { id: 25, name: "NHL - New York Rangers", teamName: "New York Rangers", leagueId: "nhl" },\
      { id: 26, name: "NHL - Ottawa Senators", teamName: "Ottawa Senators", leagueId: "nhl" },\
      { id: 27, name: "NHL - Philadelphia Flyers", teamName: "Philadelphia Flyers", leagueId: "nhl" },\
      { id: 28, name: "NHL - Pittsburgh Penguins", teamName: "Pittsburgh Penguins", leagueId: "nhl" },\
      { id: 29, name: "NHL - San Jose Sharks", teamName: "San Jose Sharks", leagueId: "nhl" },\
      { id: 30, name: "NHL - Seattle Kraken", teamName: "Seattle Kraken", leagueId: "nhl" },\
      { id: 31, name: "NHL - St. Louis Blues", teamName: "St. Louis Blues", leagueId: "nhl" },\
      { id: 32, name: "NHL - Tampa Bay Lightning", teamName: "Tampa Bay Lightning", leagueId: "nhl" },\
      { id: 33, name: "NHL - Toronto Maple Leafs", teamName: "Toronto Maple Leafs", leagueId: "nhl" },\
      { id: 34, name: "NHL - Vancouver Canucks", teamName: "Vancouver Canucks", leagueId: "nhl" },\
      { id: 35, name: "NHL - Vegas Golden Knights", teamName: "Vegas Golden Knights", leagueId: "nhl" },\
      { id: 21, name: "NHL - Washington Capitals", teamName: "Washington Capitals", leagueId: "nhl" },\
      { id: 22, name: "NHL - Winnipeg Jets", teamName: "Winnipeg Jets", leagueId: "nhl" }\
    ];
    realNhlTeams.forEach((team) => {
      const index2 = nhlTeams.findIndex((t) => t.id === team.id);
      if (index2 !== -1) {
        nhlTeams[index2] = team;
      }
    });
    const mlbTeams = [];
    for (let i = 36; i <= 65; i++) {
      mlbTeams.push({
        id: i,
        name: `MLB - Team ${i}`,
        teamName: `MLB Team ${i}`,
        leagueId: "mlb"
      });
    }
    const realMlbTeams = [\
      { id: 36, name: "MLB - Atlanta Braves", teamName: "Atlanta Braves", leagueId: "mlb" },\
      { id: 37, name: "MLB - Boston Red Sox", teamName: "Boston Red Sox", leagueId: "mlb" },\
      { id: 38, name: "MLB - Chicago Cubs", teamName: "Chicago Cubs", leagueId: "mlb" },\
      { id: 39, name: "MLB - Chicago White Sox", teamName: "Chicago White Sox", leagueId: "mlb" },\
      { id: 40, name: "MLB - Cleveland Guardians", teamName: "Cleveland Guardians", leagueId: "mlb" },\
      { id: 41, name: "MLB - Colorado Rockies", teamName: "Colorado Rockies", leagueId: "mlb" },\
      { id: 42, name: "MLB - Detroit Tigers", teamName: "Detroit Tigers", leagueId: "mlb" },\
      { id: 43, name: "MLB - Houston Astros", teamName: "Houston Astros", leagueId: "mlb" },\
      { id: 44, name: "MLB - Kansas City Royals", teamName: "Kansas City Royals", leagueId: "mlb" },\
      { id: 45, name: "MLB - Los Angeles Angels", teamName: "Los Angeles Angels", leagueId: "mlb" }\
    ];
    realMlbTeams.forEach((team) => {
      const index2 = mlbTeams.findIndex((t) => t.id === team.id);
      if (index2 !== -1) {
        mlbTeams[index2] = team;
      }
    });
    const nflTeams = [];
    for (let i = 66; i <= 97; i++) {
      nflTeams.push({
        id: i,
        name: `NFL - Team ${i}`,
        teamName: `NFL Team ${i}`,
        leagueId: "nfl"
      });
    }
    const realNflTeams = [\
      { id: 66, name: "NFL - Arizona Cardinals", teamName: "Arizona Cardinals", leagueId: "nfl" },\
      { id: 67, name: "NFL - Atlanta Falcons", teamName: "Atlanta Falcons", leagueId: "nfl" },\
      { id: 68, name: "NFL - Baltimore Ravens", teamName: "Baltimore Ravens", leagueId: "nfl" },\
      { id: 69, name: "NFL - Buffalo Bills", teamName: "Buffalo Bills", leagueId: "nfl" },\
      { id: 70, name: "NFL - Carolina Panthers", teamName: "Carolina Panthers", leagueId: "nfl" },\
      { id: 71, name: "NFL - Chicago Bears", teamName: "Chicago Bears", leagueId: "nfl" },\
      { id: 72, name: "NFL - Cincinnati Bengals", teamName: "Cincinnati Bengals", leagueId: "nfl" },\
      { id: 73, name: "NFL - Cleveland Browns", teamName: "Cleveland Browns", leagueId: "nfl" },\
      { id: 74, name: "NFL - Dallas Cowboys", teamName: "Dallas Cowboys", leagueId: "nfl" },\
      { id: 75, name: "NFL - Denver Broncos", teamName: "Denver Broncos", leagueId: "nfl" }\
    ];
    realNflTeams.forEach((team) => {
      const index2 = nflTeams.findIndex((t) => t.id === team.id);
      if (index2 !== -1) {
        nflTeams[index2] = team;
      }
    });
    const nbaTeams = [];
    for (let i = 98; i <= 127; i++) {
      nbaTeams.push({
        id: i,
        name: `NBA - Team ${i}`,
        teamName: `NBA Team ${i}`,
        leagueId: "nba"
      });
    }
    const realNbaTeams = [\
      { id: 98, name: "NBA - Atlanta Hawks", teamName: "Atlanta Hawks", leagueId: "nba" },\
      { id: 99, name: "NBA - Boston Celtics", teamName: "Boston Celtics", leagueId: "nba" },\
      { id: 100, name: "NBA - Brooklyn Nets", teamName: "Brooklyn Nets", leagueId: "nba" },\
      { id: 101, name: "NBA - Charlotte Hornets", teamName: "Charlotte Hornets", leagueId: "nba" },\
      { id: 102, name: "NBA - Chicago Bulls", teamName: "Chicago Bulls", leagueId: "nba" },\
      { id: 103, name: "NBA - Cleveland Cavaliers", teamName: "Cleveland Cavaliers", leagueId: "nba" },\
      { id: 104, name: "NBA - Dallas Mavericks", teamName: "Dallas Mavericks", leagueId: "nba" },\
      { id: 105, name: "NBA - Denver Nuggets", teamName: "Denver Nuggets", leagueId: "nba" },\
      { id: 106, name: "NBA - Detroit Pistons", teamName: "Detroit Pistons", leagueId: "nba" },\
      { id: 107, name: "NBA - Golden State Warriors", teamName: "Golden State Warriors", leagueId: "nba" }\
    ];
    realNbaTeams.forEach((team) => {
      const index2 = nbaTeams.findIndex((t) => t.id === team.id);
      if (index2 !== -1) {
        nbaTeams[index2] = team;
      }
    });
    [...specialChannels, ...nhlTeams, ...mlbTeams, ...nflTeams, ...nbaTeams].forEach((team) => {
      streamSources2.push({
        id: team.id,
        name: team.name,
        teamName: team.teamName,
        url: `https://vp.pixelsport.to:443/psportsgate/psportsgate100/${team.id}.m3u8`,
        description: `${team.teamName} stream`,
        isActive: true,
        leagueId: team.leagueId,
        priority: 1,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    });
    for (let i = 128; i <= 159; i++) {
      if (!streamSources2.find((s) => s.id === i)) {
        streamSources2.push({
          id: i,
          name: `Additional Channel ${i}`,
          teamName: `Channel ${i}`,
          leagueId: "misc",
          url: `https://vp.pixelsport.to:443/psportsgate/psportsgate100/${i}.m3u8`,
          description: `Miscellaneous Channel ${i}`,
          isActive: true,
          priority: 1,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    }
    if (!this.inMemoryStreamUrls) {
      this.inMemoryStreamUrls = {};
      const storedKeys = persistentStorage.getKeys().filter((key2) => key2.startsWith("stream_source_"));
      if (storedKeys.length > 0) {
        console.log(`Loading ${storedKeys.length} stream sources from persistent storage`);
        storedKeys.forEach((key2) => {
          const storedSource = persistentStorage.get(key2);
          if (storedSource && storedSource.id) {
            this.inMemoryStreamUrls[storedSource.id] = storedSource;
          }
        });
      }
    }
    if (this.inMemoryStreamUrls) {
      Object.values(this.inMemoryStreamUrls).forEach((updatedSource) => {
        const existingIndex = streamSources2.findIndex((s) => s.id === updatedSource.id);
        if (existingIndex >= 0) {
          streamSources2[existingIndex] = updatedSource;
        } else {
          streamSources2.push(updatedSource);
        }
      });
    }
    return streamSources2.sort((a, b) => a.id - b.id);
  }
};
var streamUrlService = new StreamUrlService();

// server/routes/directStreamUrl.js
var isAuthenticated2 = (req, res, next) => next();
var isAdmin2 = (req, res, next) => next();
var router3 = Router2();
router3.delete("/:id", isAuthenticated2, isAdmin2, async (req, res) => {
  try {
    console.log("Stream source deletion request received for ID:", req.params.id);
    await streamUrlService.ensureTableExists();
    const { id } = req.params;
    const streamId = parseInt(id, 10);
    const success = await streamUrlService.deleteStreamSource(streamId);
    if (!success) {
      console.error("Failed to delete stream source with ID:", id);
      return res.status(500).json({ error: "Failed to delete stream source" });
    }
    console.log("Stream source successfully deleted for ID:", id);
    res.json({ success: true, message: "Stream source deleted successfully" });
  } catch (error) {
    console.error("Error in stream source deletion:", error);
    res.status(500).json({ error: "Failed to delete stream source" });
  }
});
router3.patch("/:id", isAuthenticated2, isAdmin2, async (req, res) => {
  try {
    console.log("Direct stream URL update request received:", req.params.id, req.body.url);
    await streamUrlService.ensureTableExists();
    const { id } = req.params;
    const { url } = req.body;
    if (!url || typeof url !== "string") {
      console.error("Invalid URL provided in request");
      return res.status(400).json({ error: "Valid URL is required" });
    }
    const streamId = parseInt(id, 10);
    const updatedSource = await streamUrlService.updateStreamUrl(streamId, url);
    if (!updatedSource) {
      console.error("Failed to update stream URL for ID:", id);
      return res.status(500).json({ error: "Failed to update stream URL" });
    }
    const allSources = await streamUrlService.getAllStreamSources();
    const verifiedSource = allSources.find((source) => source.id === streamId);
    if (!verifiedSource || verifiedSource.url !== url) {
      console.warn("Update may not have been fully applied - refreshing the cache");
      await streamUrlService.updateStreamUrl(streamId, url);
    }
    console.log("Stream URL successfully updated for ID:", id, "New URL:", url);
    res.json(updatedSource);
  } catch (error) {
    console.error("Error in direct stream URL update:", error);
    res.status(500).json({ error: "Failed to update stream URL" });
  }
});
router3.get("/", async (req, res) => {
  try {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Methods", "GET");
    await streamUrlService.ensureTableExists();
    const sources = await streamUrlService.getAllStreamSources();
    res.json(sources);
  } catch (error) {
    console.error("Error fetching stream sources:", error);
    res.status(500).json({ error: "Failed to fetch stream sources" });
  }
});
router3.post("/init", isAuthenticated2, isAdmin2, async (req, res) => {
  try {
    console.log("Initializing stream sources table...");
    const tableExists = await streamUrlService.ensureTableExists();
    if (!tableExists) {
      console.log("Failed to create the stream_sources table");
      return res.status(500).json({
        error: "Failed to create stream_sources table"
      });
    }
    const existingSources = await streamUrlService.getAllStreamSources();
    if (existingSources.length > 0) {
      console.log("Stream sources table already has data with", existingSources.length, "records");
      return res.json({
        message: "Stream sources table already initialized",
        count: existingSources.length,
        sources: existingSources.slice(0, 5)
        // Return first 5 for verification
      });
    }
    console.log("No existing sources found, creating sample data");
    const sampleSources = [\
      {\
        name: "Toronto Blue Jays",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/64.m3u8",\
        leagueId: "mlb",\
        teamName: "Toronto Blue Jays",\
        isActive: true,\
        priority: 1,\
        description: "Toronto Blue Jays stream"\
      },\
      {\
        name: "New York Yankees",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/65.m3u8",\
        leagueId: "mlb",\
        teamName: "New York Yankees",\
        isActive: true,\
        priority: 1,\
        description: "New York Yankees stream"\
      },\
      {\
        name: "NBA TV",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/127.m3u8",\
        leagueId: "special",\
        teamName: "NBA TV",\
        isActive: true,\
        priority: 1,\
        description: "NBA TV stream"\
      },\
      {\
        name: "NFL Network",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/2.m3u8",\
        leagueId: "special",\
        teamName: "NFL Network",\
        isActive: true,\
        priority: 1,\
        description: "NFL Network stream"\
      }\
    ];
    const results = [];
    for (const source of sampleSources) {
      console.log("Creating stream source:", source.name);
      const result = await streamUrlService.createStreamSource(source);
      if (result) {
        console.log("Successfully created stream source:", source.name);
        results.push(result);
      } else {
        console.error("Failed to create stream source:", source.name);
      }
    }
    console.log("Initialization complete, created", results.length, "sources");
    res.json({
      message: "Stream sources table initialized with sample data",
      created: results.length,
      sources: results
    });
  } catch (error) {
    console.error("Error initializing stream sources:", error);
    res.status(500).json({ error: "Failed to initialize stream sources", details: error.message });
  }
});
var directStreamUrl_default = router3;

// server/routes/redisTest.ts
init_redis();
import { Router as Router3 } from "express";
var router4 = Router3();
router4.get("/redis-test", async (req, res) => {
  try {
    console.log("\u{1F9EA} Testing Redis connection via API endpoint...");
    const pingResult = await redis.ping();
    console.log("\u2705 Redis PING result:", pingResult);
    const testKey = `test-${Date.now()}`;
    await redis.set(testKey, "VeloPlay Redis Test!", "EX", 60);
    const getValue = await redis.get(testKey);
    console.log("\u2705 Redis SET/GET result:", getValue);
    const info = await redis.info("server");
    console.log("\u2705 Redis server info available");
    res.json({
      success: true,
      message: "Redis is working perfectly!",
      tests: {
        ping: pingResult,
        setGet: getValue,
        serverInfo: "Available"
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.log("\u274C Redis test failed:", error.message);
    res.status(500).json({
      success: false,
      message: "Redis connection failed",
      error: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
});
var redisTest_default = router4;

// server/routes/dynamicStreamMapping.ts
function parseM3U8ToStreamMap(m3u8Content) {
  const streamMap2 = {};
  const lines = m3u8Content.split("\n");
  let currentName = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.startsWith("#EXTINF:")) {
      const nameMatch = line.match(/#EXTINF:-?\d+,(.+)/);
      if (nameMatch) {
        currentName = nameMatch[1].trim();
      }
    }
    if (line.startsWith("https://") && currentName) {
      const urlMatch = line.match(/\/(\d+)\.m3u8$/);
      if (urlMatch) {
        const streamId = parseInt(urlMatch[1], 10);
        const normalizedName = normalizeStreamName(currentName);
        streamMap2[normalizedName] = streamId;
        addAlternativeNames(streamMap2, normalizedName, streamId);
      }
      currentName = "";
    }
  }
  console.log(`[DynamicStreamMapping] Parsed ${Object.keys(streamMap2).length} stream mappings from M3U8`);
  return streamMap2;
}
function normalizeStreamName(name) {
  return name.replace(/^USA:\s*VIP\s*/i, "").replace(/^USA:\s*/i, "").replace(/^VIP\s*/i, "").replace(/^NBA\s*/i, "").replace(/^NFL\s*/i, "").replace(/^NHL\s*/i, "").replace(/^MLB\s*-?\s*/i, "").replace(/\s*-\s*/g, " ").trim().toUpperCase();
}
function addAlternativeNames(streamMap2, name, streamId) {
  streamMap2[name] = streamId;
  if (name.includes("NBA")) {
    const teamName = name.replace(/NBA\s*/i, "").trim();
    streamMap2[`VIP NBA ${teamName}`] = streamId;
    streamMap2[teamName] = streamId;
  }
  if (name.includes("NFL")) {
    const teamName = name.replace(/NFL\s*-?\s*/i, "").trim();
    streamMap2[`NFL-${teamName}`] = streamId;
    streamMap2[`VIP NFL ${teamName}`] = streamId;
    streamMap2[teamName] = streamId;
  }
  if (name.includes("NHL")) {
    const teamName = name.replace(/NHL\s*/i, "").trim();
    streamMap2[`VIP NHL ${teamName}`] = streamId;
    streamMap2[teamName] = streamId;
  }
  const teamWords = name.split(" ");
  if (teamWords.length > 1) {
    const nickname = teamWords[teamWords.length - 1];
    if (nickname.length > 3) {
      streamMap2[nickname] = streamId;
    }
  }
  if (name === "NBA TV") streamMap2["NBATV"] = streamId;
  if (name === "NFL NETWORK") streamMap2["NFLNETWORK"] = streamId;
  if (name === "NHL NETWORK") streamMap2["NHLNETWORK"] = streamId;
  if (name === "ESPN US") streamMap2["ESPN"] = streamId;
}
async function updateDynamicStreamMapping() {
  try {
    const m3u8Content = await fetchLatestM3U8();
    return parseM3U8ToStreamMap(m3u8Content);
  } catch (error) {
    console.error("[DynamicStreamMapping] Error updating stream mapping:", error);
    return {};
  }
}
async function fetchLatestM3U8() {
  try {
    const response = await fetch("https://vpt.pixelsport.to:443/psportsgate/psportsgate100/playlist.m3u8");
    if (!response.ok) {
      throw new Error(`Failed to fetch M3U8: ${response.status}`);
    }
    return await response.text();
  } catch (error) {
    console.error("[DynamicStreamMapping] Error fetching M3U8:", error);
    throw error;
  }
}
var DYNAMIC_STREAM_MAP = {};
async function initializeDynamicMapping() {
  DYNAMIC_STREAM_MAP = await updateDynamicStreamMapping();
  console.log("[DynamicStreamMapping] Dynamic stream mapping initialized");
}

// server/routes.ts
init_alerts();
init_streamSourcesLatestFixed();
async function initializeSubscriptionPlans() {
  try {
    const existingPlans = await storage.getAllSubscriptionPlans();
    if (existingPlans.length === 0) {
      console.log("Creating default subscription plans...");
      await storage.createSubscriptionPlan({
        name: "Free",
        price: 0,
        // Free
        description: "Browse games and schedules",
        durationDays: 365,
        features: [\
          "Browse game schedules",\
          "View team information",\
          "Game alerts and notifications",\
          "No streaming access"\
        ],
        isPopular: false
      });
      await storage.createSubscriptionPlan({
        name: "Monthly",
        price: 1999,
        // $19.99 as specified
        description: "Full streaming access with HD quality",
        durationDays: 30,
        features: [\
          "Live game streaming",\
          "High definition (HD) quality",\
          "Access to game replays",\
          "Multiple device support",\
          "Ad-free experience",\
          "Home and away feeds"\
        ],
        isPopular: true
      });
      await storage.createSubscriptionPlan({
        name: "Annual",
        price: 14999,
        // $149.99 as specified
        description: "Our best value plan with all premium features at a discounted annual rate",
        durationDays: 365,
        features: [\
          "Live game streaming",\
          "High definition (HD) quality",\
          "Access to game replays",\
          "Detailed game statistics",\
          "Multiple device support",\
          "Ad-free experience",\
          "Early access to new features",\
          "Save over 15% compared to monthly"\
        ],
        isPopular: false
      });
      console.log("Default subscription plans created successfully");
    }
  } catch (error) {
    console.error("Error initializing subscription plans:", error);
  }
}
async function registerRoutes(app2) {
  await storage.initializeLeagues();
  await initEmailService();
  await initializeDynamicMapping();
  const streamSourcesRoutes = await Promise.resolve().then(() => (init_streamSources(), streamSources_exports)).then((m) => m.default);
  const initStreamSourcesRoutes = await Promise.resolve().then(() => (init_initStreamSources(), initStreamSources_exports)).then((m) => m.default);
  const streamsRoutes = await Promise.resolve().then(() => (init_streams(), streams_exports)).then((m) => m.default);
  app2.use("/api/stream-sources/latest", streamSourcesLatestFixed_default);
  app2.use("/api/init-stream-sources", initStreamSourcesRoutes);
  app2.use("/api/streams", streamsRoutes);
  app2.use("/api/direct-stream-url", directStreamUrl_default);
  app2.post("/api/update-stream-url", async (req, res) => {
    try {
      const { id, url } = req.body;
      if (!id || !url) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: id and url"
        });
      }
      console.log(`Processing stream URL update request for ID ${id} to ${url}`);
      const supabase4 = await Promise.resolve().then(() => (init_db(), db_exports)).then((m) => m.supabase);
      const { data: existingData, error: checkError } = await supabase4.from("stream_sources").select("*").eq("id", parseInt(id, 10)).maybeSingle();
      if (checkError) {
        console.error("Error checking if stream source exists:", checkError);
      }
      if (!existingData) {
        console.log(`Creating new stream source record for ID ${id}`);
        const { data: insertData, error: insertError } = await supabase4.from("stream_sources").insert([{\
          // Required fields according to the schema\
          id: parseInt(id, 10),\
          name: `Stream ${id}`,\
          team_name: `Team ${id}`,\
          // Matches schema's teamName\
          url: url.trim(),\
          league_id: "other",\
          // Matches schema's leagueId\
          // Optional fields with defaults\
          is_active: true,\
          // Matches schema's isActive\
          priority: 1,\
          // Default from schema is 1\
          description: `Auto-created stream ${id}`\
        }]).select();
        if (insertError) {
          console.error("Error creating stream source:", insertError);
          return res.status(500).json({
            success: false,
            message: "Failed to create stream source",
            error: insertError.message
          });
        }
        console.log("Successfully created stream source:", insertData);
        return res.json({
          success: true,
          message: "Stream source created successfully",
          data: insertData[0]
        });
      }
      const { data, error } = await supabase4.from("stream_sources").update({ url: url.trim() }).eq("id", parseInt(id, 10)).select();
      if (error) {
        console.error("Error updating stream URL:", error);
        return res.status(500).json({
          success: false,
          message: "Failed to update stream URL",
          error: error.message
        });
      }
      console.log("Stream URL updated successfully:", data);
      return res.json({
        success: true,
        message: "Stream URL updated successfully",
        data: data[0]
      });
    } catch (error) {
      console.error("Unexpected error in update-stream-url endpoint:", error);
      return res.status(500).json({
        success: false,
        message: "An unexpected error occurred",
        error: error?.message || "Unknown error"
      });
    }
  });
  app2.post("/api/game/alert", async (req, res) => {
    try {
      console.log("\u{1F4C5} SCHEDULER: Alert endpoint hit with data:", req.body);
      const { gameId, email, notifyMinutesBefore } = req.body;
      if (!gameId || !email || !notifyMinutesBefore) {
        return res.status(400).json({ message: "Game ID, email, and notification timing are required" });
      }
      const game = await getGameById(gameId);
      if (!game) {
        return res.status(404).json({ message: "Game not found" });
      }
      const { alertScheduler: alertScheduler2 } = await Promise.resolve().then(() => (init_alertScheduler(), alertScheduler_exports));
      const gameTime = new Date(game.date);
      try {
        console.log("\u{1F4C5} SCHEDULER: About to schedule alert for:", { gameId, email, notifyMinutesBefore, gameTime });
        const alertId = alertScheduler2.scheduleAlert(gameId, email, notifyMinutesBefore, gameTime);
        console.log("\u{1F4C5} SCHEDULER: Alert scheduled successfully with ID:", alertId);
        res.json({
          success: true,
          message: `Alert scheduled! You'll be notified ${notifyMinutesBefore} minutes before the game starts.`,
          alertId
        });
      } catch (schedulingError) {
        console.log("\u{1F4C5} SCHEDULER ERROR:", schedulingError.message);
        res.status(400).json({
          success: false,
          message: schedulingError.message || "Failed to schedule alert"
        });
      }
    } catch (error) {
      console.error("Error scheduling game alert:", error);
      res.status(500).json({ success: false, message: "Failed to schedule game alert" });
    }
  });
  app2.post("/api/game-alerts/simple", async (req, res) => {
    try {
      const { gameId, email, notifyMinutesBefore } = req.body;
      if (!gameId || !email || !notifyMinutesBefore) {
        return res.status(400).json({ message: "Game ID, email, and notification time are required" });
      }
      const game = await getGameById(gameId);
      if (!game) {
        return res.status(404).json({ message: "Game not found" });
      }
      const gameTime = new Date(game.date);
      const now = /* @__PURE__ */ new Date();
      const minutesUntilGame = Math.floor((gameTime.getTime() - now.getTime()) / (1e3 * 60));
      if (notifyMinutesBefore > minutesUntilGame) {
        return res.status(400).json({
          message: `Cannot set ${notifyMinutesBefore}-minute alert when only ${minutesUntilGame} minutes remain until game time.`
        });
      }
      try {
        const { data, error } = await supabaseClient.from("game_alerts").insert({
          game_id: gameId,
          email,
          notify_minutes_before: notifyMinutesBefore,
          is_notified: false,
          created_at: (/* @__PURE__ */ new Date()).toISOString()
        }).select();
        if (error) {
          console.error("Database error creating alert:", error);
          return res.status(500).json({ message: "Failed to create game alert" });
        }
        console.log(`\u2705 Scheduled alert created: ${email} will be notified ${notifyMinutesBefore} minutes before ${game.shortName}`);
        res.json({
          success: true,
          message: `Game alert scheduled! You'll receive an email ${notifyMinutesBefore} minutes before the game starts.`,
          alert: data[0]
        });
      } catch (error) {
        console.error("Error creating scheduled alert:", error);
        res.status(500).json({ success: false, message: "Failed to schedule game alert" });
      }
    } catch (error) {
      console.error("Error in scheduled game alert:", error);
      res.status(500).json({ success: false, message: "Failed to set scheduled game alert" });
    }
  });
  app2.post("/api/test-alert", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const success = await sendTestAlert(email);
      if (success) {
        res.json({ success: true, message: "Test alert sent successfully!" });
      } else {
        res.status(500).json({ success: false, message: "Failed to send test alert" });
      }
    } catch (error) {
      console.error("Error sending test alert:", error);
      res.status(500).json({ success: false, message: "Failed to send test alert" });
    }
  });
  app2.post("/api/auth/request-otp", async (req, res) => {
    try {
      const { email, userId } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const otpCode = Math.floor(1e5 + Math.random() * 9e5).toString();
      req.session.otpCode = otpCode;
      req.session.otpUserId = userId;
      req.session.otpEmail = email;
      req.session.otpExpires = Date.now() + 10 * 60 * 1e3;
      console.log(`Generated OTP code for ${email}: ${otpCode}`);
      const userName = email.split("@")[0] || "User";
      try {
        const emailService = await Promise.resolve().then(() => (init_emailService2(), emailService_exports2));
        const result = await emailService.sendOtpEmail(email, userName, otpCode);
        if (!result.success) {
          console.error("Failed to send OTP email:", result.error);
          return res.status(500).json({ message: "Failed to send verification code" });
        }
      } catch (emailError) {
        console.error("Error sending email with Resend:", emailError);
        console.log(`IMPORTANT: Verification code for ${email} is: ${otpCode}`);
      }
      return res.json({
        success: true,
        message: "Verification code sent to your email"
      });
    } catch (error) {
      console.error("Error generating OTP:", error);
      res.status(500).json({ message: "Failed to generate verification code" });
    }
  });
  app2.post("/api/auth/verify-otp", async (req, res) => {
    try {
      const { code, userId } = req.body;
      if (!code) {
        return res.status(400).json({ message: "Verification code is required" });
      }
      const storedCode = req.session.otpCode;
      const storedUserId = req.session.otpUserId;
      const expiryTime = req.session.otpExpires || 0;
      if (Date.now() > expiryTime) {
        return res.status(400).json({ message: "Verification code has expired" });
      }
      if (!storedCode || storedCode !== code || userId && storedUserId !== userId) {
        return res.status(400).json({ message: "Invalid verification code" });
      }
      try {
        if (userId) {
          await storage.updateUser({
            id: userId,
            verificationComplete: true,
            emailVerified: true
          });
        }
      } catch (dbError) {
        console.error("Warning: Could not update user verification status:", dbError);
      }
      req.session.otpCode = void 0;
      req.session.otpUserId = void 0;
      req.session.otpExpires = void 0;
      return res.json({
        success: true,
        message: "Email verified successfully"
      });
    } catch (error) {
      console.error("Error verifying OTP:", error);
      res.status(500).json({ message: "Failed to verify code" });
    }
  });
  await initializeSubscriptionPlans();
  app2.get("/api/setup-stream-sources", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { setupStreamSourcesTable: setupStreamSourcesTable2 } = (init_db_setup(), __toCommonJS(db_setup_exports));
      const result = await setupStreamSourcesTable2();
      res.json(result);
    } catch (error) {
      console.error("Error setting up stream sources table:", error);
      res.status(500).json({ error: "Failed to set up stream sources table" });
    }
  });
  app2.get("/auth/callback", async (req, res) => {
    try {
      const { token_hash, type, error_description, returnTo, email, code } = req.query;
      const currentUrl = `${req.protocol}://${req.get("host")}`;
      const returnUrl = returnTo ? decodeURIComponent(returnTo) : "/";
      console.log(`[AUTH] Callback received with type: ${type}, email: ${email}, returnTo: ${returnUrl}`);
      if (error_description) {
        console.error("Verification error:", error_description);
        return res.redirect(`/login?verification=error&message=${encodeURIComponent(error_description)}`);
      }
      if (code) {
        try {
          console.log("[AUTH] Auth code found, exchanging for session");
          try {
            const { data, error } = await supabaseClient.auth.exchangeCodeForSession(code);
            if (error) {
              console.error("[AUTH] Error exchanging code for session:", error);
              return res.redirect("/login?error=verification_failed");
            }
            const session2 = data?.session;
            if (!session2) {
              console.error("[AUTH] No session returned from code exchange");
              return res.redirect("/login?error=no_session");
            }
            const expiresDate = new Date((session2.expires_at || Date.now() / 1e3 + 3600) * 1e3);
            res.cookie("sb-session", session2.access_token || "", {
              httpOnly: false,
              expires: expiresDate,
              path: "/"
            });
            const redirectPath = returnUrl.includes("?") ? `${returnUrl}&verification=success&t=${Date.now()}` : `${returnUrl}?verification=success&t=${Date.now()}`;
            console.log("[AUTH] Verification successful, redirecting to:", redirectPath);
            return res.send(`
              <!DOCTYPE html>
              <html>
              <head>
                <title>Verification Complete</title>
                <style>
                  body {
                    font-family: Arial, sans-serif;
                    background-color: #0d021f;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    height: 100vh;
                    margin: 0;
                  }
                  .container {
                    text-align: center;
                    max-width: 500px;
                    padding: 2rem;
                  }
                  .spinner {
                    width: 40px;
                    height: 40px;
                    margin: 0 auto 1rem;
                    border: 4px solid rgba(127, 0, 255, 0.3);
                    border-radius: 50%;
                    border-top-color: #7f00ff;
                    animation: spin 1s ease infinite;
                  }
                  @keyframes spin {
                    to { transform: rotate(360deg); }
                  }
                </style>
              </head>
              <body>
                <div class="container">
                  <div class="spinner"></div>
                  <h2>Verification Complete!</h2>
                  <p>Your email has been verified successfully. Redirecting you back to the app...</p>
                </div>
                <script>
                  // Only set email_verified flag but don't store session tokens
                  // This ensures user has to log in again after verification
                  localStorage.setItem('email_verified', 'true');

                  // Clear any saved game URL
                  localStorage.removeItem('gameUrlBeforeVerification');

                  // Redirect to dashboard after successful verification
                  setTimeout(() => {
                    window.location.href = '/dashboard?verified=true';
                  }, 1500);
                </script>
              </body>
              </html>
            `);
          } catch (serverError) {
            console.error("[AUTH] Server error during verification code exchange:", serverError);
            return res.redirect("/login?error=server_error");
          }
        } catch (codeError) {
          console.error("[AUTH] Error exchanging code for session:", codeError);
          return res.redirect("/login?error=session_exchange_failed");
        }
      }
      if (type === "email_confirmation" || type === "signup") {
        console.log("[AUTH] Email verification callback received! Auto-logging in user...");
        try {
          const { data: sessionData, error: sessionError } = await supabase.auth.exchangeCodeForSession(code);
          if (sessionError) {
            console.error("[AUTH] Error creating session after verification:", sessionError);
            return res.redirect("/login?verification=success&auto_login=failed");
          }
          if (sessionData?.session?.access_token) {
            console.log("[AUTH] Successfully created session for verified user");
            const user = sessionData.session.user;
            if (user?.email) {
              try {
                const dbUser = await storage.getUserByEmail(user.email);
                if (dbUser) {
                  await storage.updateUserVerificationStatus(dbUser.id, true);
                  console.log("[AUTH] Updated database verification status for:", user.email);
                }
              } catch (dbError) {
                console.error("[AUTH] Error updating database verification:", dbError);
              }
            }
            return res.send(`
              <!DOCTYPE html>
              <html>
              <head>
                <title>Email Verified - VeloPlay</title>
                <style>
                  body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; margin: 0; padding: 40px; text-align: center; }
                  .container { max-width: 500px; margin: 0 auto; }
                  .success { color: #4ade80; font-size: 24px; margin-bottom: 20px; }
                </style>
              </head>
              <body>
                <div class="container">
                  <div class="success">\u2705 Email Verified Successfully!</div>
                  <p>You're now logged in and being redirected to your dashboard...</p>
                </div>
                <script>
                  // Set the session token for auto-login
                  localStorage.setItem('supabase.auth.token', JSON.stringify({
                    access_token: '${sessionData.session.access_token}',
                    refresh_token: '${sessionData.session.refresh_token}',
                    expires_at: ${sessionData.session.expires_at}
                  }));

                  // Mark email as verified
                  localStorage.setItem('email_verified', 'true');

                  // Clear any saved verification URLs
                  localStorage.removeItem('gameUrlBeforeVerification');

                  // Redirect to dashboard
                  setTimeout(() => {
                    window.location.href = '/dashboard?verified=true&auto_login=true';
                  }, 2000);
                </script>
              </body>
              </html>
            `);
          }
        } catch (autoLoginError) {
          console.error("[AUTH] Auto-login after verification failed:", autoLoginError);
        }
        return res.redirect("/login?verification=success");
      }
      if (type === "recovery") {
        return res.redirect("/reset-password");
      }
      return res.redirect(returnUrl);
    } catch (error) {
      console.error("Error in auth callback:", error);
      return res.redirect("/login?error=callback_error");
    }
  });
  app2.post("/api/verify-email", async (req, res) => {
    try {
      const { email, autoLogin } = req.body;
      if (!email) {
        return res.status(400).json({
          message: "Email is required",
          success: false
        });
      }
      console.log(`[AUTO-VERIFY] Processing auto-verification for email: ${email}, autoLogin: ${autoLogin}`);
      try {
        console.log(`[AUTO-VERIFY] Email verified for: ${email}`);
        if (autoLogin) {
          try {
            const user = await storage.getUserByEmail(email);
            if (user) {
              console.log(`[AUTO-VERIFY] Found user for auto-login: ${email}`);
              return res.status(200).json({
                message: "Email successfully verified. Logging you in automatically...",
                success: true,
                autoLogin: true,
                redirectToPricing: !user.isVerified,
                // Redirect to pricing if this is their first verification
                userId: user.id
              });
            } else {
              console.log(`[AUTO-VERIFY] User not found for auto-login: ${email}`);
              return res.status(200).json({
                message: "Email successfully verified. Please log in to continue.",
                success: true,
                redirectToPricing: true
              });
            }
          } catch (userError) {
            console.error("[AUTO-VERIFY] Error getting user for auto-login:", userError);
            return res.status(200).json({
              message: "Email successfully verified. Please log in to continue.",
              success: true,
              redirectToPricing: true
            });
          }
        } else {
          return res.status(200).json({
            message: "Email successfully verified. Please visit the pricing page to choose a subscription plan.",
            success: true,
            redirectToPricing: true
          });
        }
      } catch (error) {
        console.error("[AUTO-VERIFY] Error marking email as verified:", error);
        return res.status(500).json({
          message: "Failed to verify email",
          success: false
        });
      }
    } catch (error) {
      console.error("[AUTO-VERIFY] Error in auto-verification process:", error);
      return res.status(500).json({
        message: "Server error during verification",
        success: false
      });
    }
  });
  app2.post("/api/auth/send-verification", async (req, res) => {
    try {
      const { email, firstName, useDirectMethod, returnUrl } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      console.log(`[VERIFICATION] Sending verification email to: ${email}`);
      const emailService = await Promise.resolve().then(() => (init_emailService2(), emailService_exports2));
      if (!process.env.RESEND_API_KEY) {
        console.error("[VERIFICATION] RESEND_API_KEY not configured!");
        return res.status(500).json({
          message: "Email service not properly configured. Please contact support.",
          success: false
        });
      }
      const host = req.get("host") || "veloplay.tv";
      const isLocalhost = host.includes("localhost") || host.includes("127.0.0.1") || host.includes("replit");
      const protocol = isLocalhost ? "http" : "https";
      const baseUrl = `${protocol}://${host}`;
      console.log(`[VERIFICATION] Using base URL: ${baseUrl}`);
      const userReturnUrl = returnUrl || "/";
      const redirectTo = `${baseUrl}/auth/callback?returnTo=${encodeURIComponent(userReturnUrl)}`;
      console.log(`[VERIFICATION] Redirect URL: ${redirectTo} (will return to: ${userReturnUrl})`);
      try {
        console.log("[VERIFICATION] Getting verification code from Supabase...");
        const { data: resendData, error: resendError } = await supabaseClient.auth.resend({
          type: "signup",
          email,
          options: {
            emailRedirectTo: redirectTo
          }
        });
        if (resendError) {
          console.error("[VERIFICATION] Supabase verification prep error:", resendError);
          return res.status(500).json({
            message: "Failed to prepare verification. Please try again later.",
            success: false
          });
        }
        let verificationUrl = "";
        try {
          await new Promise((resolve) => setTimeout(resolve, 500));
          verificationUrl = `${baseUrl}/auth/callback?returnTo=${encodeURIComponent(userReturnUrl)}&email=${encodeURIComponent(email)}&autoVerify=true`;
          console.log("[VERIFICATION] Using backup verification URL:", verificationUrl);
        } catch (error) {
          console.error("[VERIFICATION] Error extracting verification URL:", error);
          return res.status(500).json({
            message: "Failed to generate verification link. Please try again.",
            success: false
          });
        }
        console.log("[VERIFICATION] Using Supabase verification system only");
      } catch (directError) {
        console.error("[VERIFICATION] Error with direct email method:", directError);
      }
      console.log("[VERIFICATION] All custom VeloPlay emails disabled - relying on Supabase only");
      return res.status(200).json({
        message: "Verification handled by Supabase. Please check your inbox for the verification email.",
        success: true
      });
    } catch (error) {
      console.error("[VERIFICATION] Error in verification email endpoint:", error);
      return res.status(500).json({ message: "Failed to send verification email" });
    }
  });
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      res.json({
        ...user,
        emailVerified: user?.isVerified || false
      });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.get("/api/user/profile", isAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const createdAt = new Date(user.createdAt);
      const trialDurationDays = 15;
      const trialExpiresAt = new Date(createdAt);
      trialExpiresAt.setDate(trialExpiresAt.getDate() + trialDurationDays);
      const now = /* @__PURE__ */ new Date();
      const isTrialActive = now <= trialExpiresAt || user.isAdmin;
      const msPerDay = 24 * 60 * 60 * 1e3;
      const daysRemaining = Math.max(0, Math.ceil((trialExpiresAt.getTime() - now.getTime()) / msPerDay));
      const profile = {
        id: user.id,
        email: user.email,
        isAdmin: user.isAdmin || false,
        createdAt: user.createdAt,
        trialExpiresAt: trialExpiresAt.toISOString(),
        isTrialActive,
        daysRemaining: user.isAdmin ? 999 : daysRemaining
      };
      res.json(profile);
    } catch (error) {
      console.error("Error fetching user profile:", error);
      res.status(500).json({ message: "Failed to fetch user profile" });
    }
  });
  app2.get("/api/auth/check-verification-status", async (req, res) => {
    try {
      const session2 = req.headers.authorization?.split(" ")[1];
      if (!session2) {
        return res.status(401).json({ verified: false, message: "Unauthorized" });
      }
      const { data: { user }, error } = await supabaseClient.auth.getUser(session2);
      if (error || !user) {
        console.error("Error getting user for verification check:", error);
        return res.status(400).json({ verified: false, message: error?.message || "Failed to get user" });
      }
      const verified = user.email_confirmed_at !== null;
      return res.json({
        verified,
        email: user.email,
        confirmedAt: user.email_confirmed_at
      });
    } catch (error) {
      console.error("Error checking verification status:", error);
      return res.status(500).json({ verified: false, message: "Internal server error" });
    }
  });
  app2.post("/api/auth/request-otp", async (req, res) => {
    try {
      const { email, userId } = req.body;
      if (!email && !userId) {
        return res.status(400).json({ message: "Email or User ID is required" });
      }
      let user;
      if (email) {
        user = await storage.getUserByEmail(email);
      } else if (userId) {
        user = await storage.getUser(userId);
      }
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { success, error } = await createAndSendOtp(user.id, user.email, user.firstName || "User");
      if (!success || error) {
        console.error("Error generating OTP:", error);
        return res.status(500).json({ message: "Failed to generate verification code" });
      }
      return res.status(200).json({
        message: "Verification code sent",
        userId: user.id
      });
    } catch (error) {
      console.error("Error in OTP request:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/auth/verify-otp", async (req, res) => {
    try {
      const { userId, code } = req.body;
      if (!userId || !code) {
        return res.status(400).json({ message: "User ID and verification code are required" });
      }
      const { success, message } = await verifyOtp(userId, code);
      if (!success) {
        return res.status(400).json({ message: message || "Invalid verification code" });
      }
      return res.status(200).json({
        message: "Verification successful",
        verified: true
      });
    } catch (error) {
      console.error("Error verifying OTP:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/auth/check-email", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      return res.status(200).json({
        exists: true,
        // We don't actually know but for security don't reveal this
        verified: true,
        // We'll check this after login on the client
        message: "Please proceed with login"
      });
    } catch (error) {
      console.error("Error in login check:", error);
      return res.status(200).json({
        exists: true,
        verified: true,
        message: "Proceed with login attempt"
      });
    }
  });
  app2.get("/api/auth/check-email", async (req, res) => {
    try {
      const email = req.query.email;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(200).json({ exists: true });
      }
      try {
        const { error } = await supabaseClient.auth.signInWithPassword({
          email,
          password: `ThisIsDefinitelyNotTheRightPassword${Date.now()}`
        });
        if (error && (error.message.includes("Invalid login credentials") || error.message.includes("Invalid email") === false)) {
          return res.status(200).json({ exists: true });
        }
        if (error && (error.message.includes("Email not confirmed") || error.message.includes("Invalid email"))) {
          return res.status(200).json({ exists: false });
        }
      } catch (authError) {
        console.error("Error checking auth:", authError);
      }
      return res.status(200).json({ exists: false });
    } catch (error) {
      console.error("Error checking email:", error);
      return res.status(200).json({ exists: false });
    }
  });
  app2.post("/api/auth/pre-signup", async (req, res) => {
    try {
      const { email, firstName, lastName } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      console.log(`[PRE-SIGNUP] Processing pre-signup verification for: ${email}`);
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({ message: "Invalid email format" });
      }
      return res.status(200).json({
        message: "Pre-signup check successful",
        emailVerified: true
      });
    } catch (error) {
      console.error("[PRE-SIGNUP] Error in pre-signup endpoint:", error);
      return res.status(500).json({ message: "Failed to process pre-signup check" });
    }
  });
  app2.post("/api/auth/signup", async (req, res) => {
    try {
      const { email, password, firstName, lastName } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const { data, error } = await supabaseClient.auth.signUp({
        email,
        password,
        options: {
          data: {
            first_name: firstName,
            last_name: lastName
          },
          emailRedirectTo: `${req.protocol}://${req.get("host")}/auth/callback?autoVerify=true&email=${encodeURIComponent(email)}`
        }
      });
      if (error) {
        console.error("Signup error:", error);
        if (error.message && error.message.includes("security purposes") || error.status === 429 || error.code === "over_email_send_rate_limit") {
          return res.status(429).json({
            message: "Rate limit reached. Please wait a minute before trying again or use a different email address."
          });
        }
        if (error.message && (error.message.includes("already registered") || error.message.includes("already exists") || error.code === "user_already_exists")) {
          const existingUser = await storage.getUserByEmail(email);
          if (existingUser) {
            return res.status(409).json({
              message: "User already registered",
              code: "user_already_exists",
              userExists: true
            });
          }
          return res.status(409).json({
            message: "User already registered",
            code: "user_already_exists",
            userExists: true
          });
        }
        return res.status(400).json({ message: error.message });
      }
      const userId = data.user?.id;
      if (!userId) {
        return res.status(400).json({ message: "Failed to get user ID from signup response" });
      }
      console.log(`New user ${userId} created successfully`);
      await storage.upsertUser({
        id: userId,
        email,
        firstName: firstName || "",
        lastName: lastName || "",
        profileImageUrl: null,
        isAdmin: false
      });
      console.log(`[SIGNUP] User created successfully. Supabase will send verification email to ${email}`);
      return res.status(201).json({
        message: "Signup successful! Please check your email to verify your account.",
        user: data.user,
        session: data.session,
        redirectToPricing: true
      });
    } catch (error) {
      console.error("Signup error:", error);
      res.status(500).json({ message: "Failed to create account" });
    }
  });
  app2.post("/api/auth/verify-otp", async (req, res) => {
    try {
      const { userId, code } = req.body;
      if (!userId || !code) {
        return res.status(400).json({ message: "User ID and verification code are required" });
      }
      const { success, message, error } = await verifyOtp(userId, code);
      if (!success) {
        return res.status(400).json({
          message: message || "Invalid verification code",
          error
        });
      }
      const user = await storage.getUserById(userId);
      if (user) {
        await storage.updateUserVerificationStatus(userId, true);
      }
      return res.json({
        success: true,
        message: "Verification successful"
      });
    } catch (error) {
      console.error("OTP verification error:", error);
      res.status(500).json({ message: "Failed to verify code" });
    }
  });
  app2.post("/api/auth/request-otp", async (req, res) => {
    try {
      const { userId, email } = req.body;
      if (!userId || !email) {
        return res.status(400).json({ message: "User ID and email are required" });
      }
      const { hasActive, count } = await hasActiveOtps(userId);
      if (hasActive && count >= 3) {
        return res.status(429).json({
          message: "Too many verification attempts. Please wait a few minutes before requesting a new code."
        });
      }
      const { success, error } = await createAndSendOtp(userId, email, "User");
      if (!success || error) {
        console.error("Error generating new OTP:", error);
        return res.status(500).json({ message: "Failed to send verification code. Please try again." });
      }
      return res.json({
        success: true,
        message: "New verification code sent to your email"
      });
    } catch (error) {
      console.error("Request OTP error:", error);
      res.status(500).json({ message: "Failed to send verification code" });
    }
  });
  app2.post("/api/auth/signin", async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const { data, error } = await supabaseClient.auth.signInWithPassword({
        email,
        password
      });
      if (error) {
        console.error("Signin error:", error);
        if (error.message && error.message.includes("security purposes") || error.status === 429 || error.code === "too_many_attempts") {
          return res.status(429).json({
            message: "Too many login attempts. Please wait a moment before trying again."
          });
        }
        return res.status(401).json({ message: error.message });
      }
      if (data.user?.email_confirmed_at === null) {
        return res.status(403).json({
          message: "Email not verified",
          code: "email_not_verified",
          userId: data.user.id
        });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        console.log(`First-time login for user ${data.user.id} (${email}). Creating user record and sending OTP verification.`);
        const isAdmin3 = email.endsWith("@admin.com") || email === "admin@veloplay.tv";
        const newUser = await storage.upsertUser({
          id: data.user.id,
          email,
          firstName: "",
          lastName: "",
          profileImageUrl: null,
          isAdmin: isAdmin3
        });
        if (isAdmin3) {
          console.log(`Admin user detected (${email}). Skipping OTP verification.`);
          return res.json({
            message: "Signin successful",
            session: data.session,
            user: data.user,
            isAdmin: true
          });
        }
        const { success, error: otpError } = await createAndSendOtp(data.user.id, email, "User");
        if (!success || otpError) {
          console.error("Error generating OTP:", otpError);
          return res.status(500).json({ message: "Failed to send verification code. Please try again." });
        }
        console.log(`OTP verification code sent to ${email} for first-time login`);
        return res.json({
          message: "Since this is your first login, please verify with the code sent to your email",
          session: data.session,
          user: data.user,
          requiresOtp: true,
          userId: data.user.id
        });
      }
      if (user.isAdmin) {
        console.log(`Admin user detected (${email}). Skipping OTP verification.`);
        return res.json({
          message: "Signin successful",
          session: data.session,
          user: data.user,
          isAdmin: true
        });
      }
      res.json({
        message: "Signin successful",
        session: data.session,
        user: data.user
      });
    } catch (error) {
      console.error("Signin error:", error);
      res.status(500).json({ message: "Failed to sign in" });
    }
  });
  app2.post("/api/auth/signout", async (req, res) => {
    try {
      const { error } = await supabaseClient.auth.signOut();
      if (error) {
        console.error("Signout error:", error);
        return res.status(400).json({ message: error.message });
      }
      res.json({ message: "Signout successful" });
    } catch (error) {
      console.error("Signout error:", error);
      res.status(500).json({ message: "Failed to sign out" });
    }
  });
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(user);
    } catch (error) {
      console.error("Error fetching user data:", error);
      res.status(500).json({ message: "Failed to fetch user data" });
    }
  });
  app2.get("/api/games", async (req, res) => {
    try {
      const dateParam = req.query.date;
      const includeTomorrowParam = req.query.includeTomorrow;
      const includeTomorrow = includeTomorrowParam === "true";
      let date2;
      if (dateParam) {
        const [year, month, day] = dateParam.split("-").map(Number);
        date2 = new Date(Date.UTC(year, month - 1, day, 16, 0, 0));
        if (isNaN(date2.getTime())) {
          return res.status(400).json({ message: "Invalid date format. Use ISO format (YYYY-MM-DD)" });
        }
        console.log(`Fetching games for date: ${date2.toISOString()}, for calendar date: ${month}/${day}/${year}, including tomorrow: ${includeTomorrow}`);
      }
      const games = await getAllGames(date2, includeTomorrow);
      res.json(games);
    } catch (error) {
      console.error("Error fetching games:", error);
      res.status(500).json({ message: "Failed to fetch games" });
    }
  });
  app2.get("/api/games/:leagueId", async (req, res) => {
    try {
      const { leagueId } = req.params;
      const validLeagues = ["nba", "nfl", "nhl", "mlb"];
      if (!validLeagues.includes(leagueId)) {
        return res.status(400).json({ message: "Invalid league ID" });
      }
      const dateParam = req.query.date;
      const includeTomorrowParam = req.query.includeTomorrow;
      const includeTomorrow = includeTomorrowParam === "true";
      let date2;
      if (dateParam) {
        const [year, month, day] = dateParam.split("-").map(Number);
        date2 = new Date(Date.UTC(year, month - 1, day, 16, 0, 0));
        if (isNaN(date2.getTime())) {
          return res.status(400).json({ message: "Invalid date format. Use ISO format (YYYY-MM-DD)" });
        }
        console.log(`Fetching ${leagueId} games for date: ${date2.toISOString()}, for calendar date: ${month}/${day}/${year}, including tomorrow: ${includeTomorrow}`);
      }
      const todayGames = await getLeagueGames(leagueId, date2);
      if (!includeTomorrow) {
        return res.json(todayGames);
      }
      const tomorrow = new Date(date2 || /* @__PURE__ */ new Date());
      tomorrow.setDate(tomorrow.getDate() + 1);
      console.log(`Also fetching ${leagueId} games for tomorrow: ${tomorrow.toISOString()}`);
      const tomorrowGames = await getLeagueGames(leagueId, tomorrow);
      let allGames = [...todayGames, ...tomorrowGames];
      const upcomingGames = allGames.filter((game) => game.state === "pre");
      if (upcomingGames.length === 0) {
        console.log(`No upcoming ${leagueId} games found for current dates. Searching for upcoming games in next 7 days.`);
        let foundUpcomingGames = [];
        for (let i = 2; i <= 7; i++) {
          const futureDate = new Date(date2 || /* @__PURE__ */ new Date());
          futureDate.setDate(futureDate.getDate() + i);
          const futureDateFormatted = new Date(futureDate).toLocaleDateString();
          console.log(`Looking for upcoming ${leagueId} games on: ${futureDateFormatted}`);
          const futureGames = await getLeagueGames(leagueId, futureDate);
          const upcomingFutureGames = futureGames.filter((game) => game.state === "pre");
          upcomingFutureGames.forEach((game) => {
            game.isFuture = true;
          });
          if (upcomingFutureGames.length > 0) {
            console.log(`Found ${upcomingFutureGames.length} upcoming ${leagueId} games for ${futureDateFormatted}`);
            foundUpcomingGames = upcomingFutureGames;
            break;
          }
        }
        if (foundUpcomingGames.length > 0) {
          console.log(`Adding ${foundUpcomingGames.length} upcoming future games to the results for ${leagueId}`);
          allGames = [...allGames, ...foundUpcomingGames];
        }
      }
      console.log(`Returning ${allGames.length} games for ${leagueId} directly from ESPN API`);
      const gamesWithLeague = allGames.map((game) => ({
        ...game,
        league: game.league || leagueId
      }));
      res.json(gamesWithLeague);
    } catch (error) {
      console.error(`Error fetching ${req.params.leagueId} games:`, error);
      res.status(500).json({ message: "Failed to fetch league games" });
    }
  });
  app2.get("/api/game/:gameId", async (req, res) => {
    try {
      const { gameId } = req.params;
      const game = await getGameById(gameId);
      if (!game) {
        return res.status(404).json({ message: "Game not found" });
      }
      console.log(`Fetched game data for ID ${gameId}:`, game.homeTeam.name, "vs", game.awayTeam.name);
      res.json(game);
    } catch (error) {
      console.error("Error fetching game:", error);
      res.status(500).json({ message: "Failed to fetch game" });
    }
  });
  app2.get("/api/direct-stream-info", async (req, res) => {
    try {
      const streamUrl = req.query.url;
      if (!streamUrl) {
        return res.status(400).json({ error: "Missing stream URL parameter" });
      }
      console.log(`Stream proxy request for: ${streamUrl}`);
      try {
        const response = await fetch3(streamUrl, {
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Referer": "https://www.hlsplayer.org/",
            "Origin": "https://www.hlsplayer.org"
          }
        });
        if (!response.ok) {
          console.error(`Proxy stream error: ${response.status} ${response.statusText}`);
          return res.status(response.status).json({
            error: "Failed to fetch stream",
            status: response.status,
            message: response.statusText
          });
        }
        const contentType = response.headers.get("content-type");
        if (contentType) {
          res.setHeader("Content-Type", contentType);
        } else if (streamUrl.endsWith(".m3u8")) {
          res.setHeader("Content-Type", "application/vnd.apple.mpegurl");
        }
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Range");
        const isBinary = streamUrl.endsWith(".ts") || streamUrl.endsWith(".m4s") || streamUrl.endsWith(".mp4") || streamUrl.endsWith(".aac");
        if (isBinary) {
          console.log(`Proxying binary data from: ${streamUrl}`);
          const buffer = await response.arrayBuffer();
          res.send(Buffer.from(buffer));
          return;
        }
        let streamData = await response.text();
        if (streamUrl.endsWith(".m3u8")) {
          const baseUrl = new URL(streamUrl).href.substring(0, streamUrl.lastIndexOf("/") + 1);
          const lines = streamData.split("\n");
          const processedLines = lines.map((line) => {
            if (line.startsWith("#") || line.trim() === "") {
              return line;
            }
            if (line.endsWith(".ts") || line.endsWith(".m4s") || line.endsWith(".mp4") || line.endsWith(".aac")) {
              if (!line.startsWith("http")) {
                const absoluteUrl = new URL(line, baseUrl).href;
                return absoluteUrl;
              }
              return line;
            }
            if (line.endsWith(".m3u8")) {
              if (!line.startsWith("http")) {
                const absoluteUrl = new URL(line, baseUrl).href;
                return `/api/proxy-stream?url=${encodeURIComponent(absoluteUrl)}`;
              }
              return `/api/proxy-stream?url=${encodeURIComponent(line)}`;
            }
            return line;
          });
          streamData = processedLines.join("\n");
          console.log("Rewrote m3u8 content to use proxy for all referenced files");
        }
        res.send(streamData);
      } catch (error) {
        console.error("Error proxying stream:", error.message);
        res.status(500).json({ error: "Failed to proxy stream", message: error.message });
      }
    } catch (error) {
      console.error("Stream proxy error:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/stream/:gameId", async (req, res) => {
    try {
      const { gameId } = req.params;
      const feed2 = req.query.feed;
      res.header("Access-Control-Allow-Origin", "*");
      res.header("Access-Control-Allow-Methods", "GET, OPTIONS");
      res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization");
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ message: "Unauthorized", redirectTo: "/login" });
      }
      const token = authHeader.split("Bearer ")[1];
      if (!token) {
        console.log("\u274C No token found in authorization header");
        return res.status(401).json({ message: "Unauthorized", redirectTo: "/login" });
      }
      console.log("\u{1F511} Attempting to verify Supabase token...");
      let decoded;
      try {
        const parts = token.split(".");
        if (parts.length !== 3) {
          throw new Error("Invalid token format");
        }
        const payload = JSON.parse(Buffer.from(parts[1], "base64").toString());
        console.log("\u2705 Supabase token decoded, email:", payload.email);
        const user = await storage.getUserByEmail(payload.email);
        if (!user) {
          console.log("\u274C User not found for email:", payload.email);
          return res.status(401).json({ message: "User not found", redirectTo: "/login" });
        }
        console.log("\u2705 User found:", user.email, "isAdmin:", user.isAdmin);
        decoded = user;
      } catch (supabaseError) {
        console.log("\u274C Supabase token decode failed, error:", supabaseError.message);
        return res.status(401).json({ message: "Invalid token", redirectTo: "/login" });
      }
      const now = /* @__PURE__ */ new Date();
      const createdAt = new Date(decoded.createdAt || /* @__PURE__ */ new Date());
      const trialEndDate = new Date(createdAt.getTime() + 15 * 24 * 60 * 60 * 1e3);
      const hasValidTrial = now <= trialEndDate;
      const isAdmin3 = decoded.isAdmin;
      console.log("\u{1F50D} Access check:", {
        email: decoded.email,
        isAdmin: isAdmin3,
        hasValidTrial,
        trialEndDate: trialEndDate.toISOString(),
        currentTime: now.toISOString()
      });
      if (!hasValidTrial && !isAdmin3) {
        return res.status(403).json({
          message: "Trial expired. Please upgrade to continue streaming.",
          redirectTo: "/pricing",
          trialExpired: true
        });
      }
      const dbStream = await storage.getStreamByGameId(gameId);
      if (dbStream && (dbStream.streamUrl || dbStream.awayStreamUrl)) {
        console.log(`\u{1F3AF} [CentralizedStream] Using database stream for game ${gameId}`);
        if (feed2 === "away" && dbStream.awayStreamUrl) {
          return res.json({
            streamUrl: dbStream.awayStreamUrl,
            hasAwayFeed: true,
            hasHomeFeed: !!dbStream.streamUrl,
            currentFeed: "away"
          });
        }
        return res.json({
          streamUrl: dbStream.streamUrl,
          hasAwayFeed: !!dbStream.awayStreamUrl,
          hasHomeFeed: true,
          currentFeed: "home"
        });
      }
      console.log(`\u{1F3AF} [CentralizedStream] No database stream found for game ${gameId}, using centralized stream mapping`);
      try {
        const { getGameById: getGameById2 } = await Promise.resolve().then(() => (init_espnApi(), espnApi_exports));
        const game = await getGameById2(gameId);
        if (!game) {
          return res.status(404).json({
            message: `Game not found: ${gameId}`,
            gameId
          });
        }
        const { getStreamUrlForTeam: getStreamUrlForTeam2 } = await import("./centralizedStreamManager");
        const homeTeamStreamUrl = await getStreamUrlForTeam2(game.homeTeam.name);
        const awayTeamStreamUrl = await getStreamUrlForTeam2(game.awayTeam.name);
        console.log(`\u{1F3AF} [DynamicCentralizedStream] Dynamic team lookup results:`, {
          gameId,
          homeTeam: game.homeTeam.name,
          awayTeam: game.awayTeam.name,
          homeStreamUrl: homeTeamStreamUrl ? "Found" : "Not found",
          awayStreamUrl: awayTeamStreamUrl ? "Found" : "Not found",
          requestedFeed: feed2
        });
        const hasHomeFeed = !!homeTeamStreamUrl;
        const hasAwayFeed = !!awayTeamStreamUrl;
        let selectedStreamUrl = null;
        let actualFeed = "home";
        if (feed2 === "away" && awayTeamStreamUrl) {
          selectedStreamUrl = awayTeamStreamUrl;
          actualFeed = "away";
        } else if (feed2 === "home" && homeTeamStreamUrl) {
          selectedStreamUrl = homeTeamStreamUrl;
          actualFeed = "home";
        } else if (homeTeamStreamUrl) {
          selectedStreamUrl = homeTeamStreamUrl;
          actualFeed = "home";
        } else if (awayTeamStreamUrl) {
          selectedStreamUrl = awayTeamStreamUrl;
          actualFeed = "away";
        }
        if (selectedStreamUrl) {
          return res.json({
            streamUrl: selectedStreamUrl,
            hasAwayFeed,
            hasHomeFeed,
            currentFeed: actualFeed,
            awayStreamUrl: awayTeamStreamUrl,
            homeStreamUrl: homeTeamStreamUrl,
            source: "dynamic_centralized_mapping"
          });
        }
        return res.status(404).json({
          message: `No stream available for teams: ${game.homeTeam.name} vs ${game.awayTeam.name}`,
          gameId,
          homeTeam: game.homeTeam.name,
          awayTeam: game.awayTeam.name
        });
      } catch (streamError) {
        console.error(`\u{1F6A8} [CentralizedStream] Error with centralized stream mapping:`, streamError);
        return res.status(404).json({
          message: `No stream available for game ID: ${gameId}`,
          gameId
        });
      }
    } catch (error) {
      console.error("Error fetching stream:", error);
      res.status(500).json({ message: "Failed to fetch stream" });
    }
  });
  app2.get("/api/admin/streams", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const streams2 = await storage.getAllStreams();
      res.json(streams2);
    } catch (error) {
      console.error("Error fetching streams:", error);
      res.status(500).json({ message: "Failed to fetch streams" });
    }
  });
  app2.post("/api/admin/streams", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const userId = req.user?.id;
      const streamData = insertStreamSchema.parse({
        ...req.body,
        addedById: userId
      });
      const stream = await storage.createStream(streamData);
      res.status(201).json(stream);
    } catch (error) {
      console.error("Error creating stream:", error);
      res.status(500).json({ message: "Failed to create stream" });
    }
  });
  app2.put("/api/admin/streams/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { streamUrl, awayStreamUrl } = req.body;
      if (!streamUrl && !awayStreamUrl) {
        return res.status(400).json({ message: "At least one stream URL is required" });
      }
      const updateData = {};
      if (streamUrl) {
        updateData.streamUrl = streamUrl;
      }
      if (awayStreamUrl !== void 0) {
        updateData.awayStreamUrl = awayStreamUrl;
      }
      const stream = await storage.updateStream(parseInt(id), updateData);
      res.json(stream);
    } catch (error) {
      console.error("Error updating stream:", error);
      res.status(500).json({ message: "Failed to update stream" });
    }
  });
  app2.delete("/api/admin/streams/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteStream(parseInt(id));
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting stream:", error);
      res.status(500).json({ message: "Failed to delete stream" });
    }
  });
  app2.post("/api/admin/auto-stream", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { gameId } = req.body;
      if (!gameId) {
        return res.status(400).json({ message: "Game ID is required" });
      }
      const game = await getGameById(gameId);
      if (!game) {
        return res.status(404).json({ message: "Game not found" });
      }
      const existingStreamRecord = await storage.getStreamByGameId(gameId);
      if (existingStreamRecord && (existingStreamRecord.streamUrl || existingStreamRecord.awayStreamUrl)) {
        console.log(`\u{1F3AF} Using database stream URLs for game ${gameId}`);
        return res.json({
          streamUrl: existingStreamRecord.streamUrl || null,
          awayStreamUrl: existingStreamRecord.awayStreamUrl || null,
          hasAwayFeed: !!existingStreamRecord.awayStreamUrl,
          hasHomeFeed: !!existingStreamRecord.streamUrl,
          currentFeed: feed === "away" ? "away" : "home"
        });
      }
      const { getStreamUrlForTeam: getStreamUrlForTeam2 } = await import("./centralizedStreamManager");
      const homeTeamStreamUrl = await getStreamUrlForTeam2(game.homeTeam.name);
      const awayTeamStreamUrl = await getStreamUrlForTeam2(game.awayTeam.name);
      if (!homeTeamStreamUrl && !awayTeamStreamUrl) {
        return res.status(404).json({
          message: "Could not find stream URLs for this game's teams",
          homeTeam: game.homeTeam.name,
          awayTeam: game.awayTeam.name
        });
      }
      const userId = req.user?.id;
      const existingStream = await storage.getStreamByGameId(gameId);
      if (existingStream) {
        const updatedStream = await storage.updateStream(existingStream.id, {
          streamUrl: homeTeamStreamUrl || existingStream.streamUrl,
          awayStreamUrl: awayTeamStreamUrl || existingStream.awayStreamUrl
        });
        return res.json({
          message: "Stream URLs updated automatically",
          stream: updatedStream,
          homeTeam: game.homeTeam.name,
          awayTeam: game.awayTeam.name
        });
      } else {
        const newStream = await storage.createStream({
          gameId,
          streamUrl: homeTeamStreamUrl || "",
          awayStreamUrl: awayTeamStreamUrl || null,
          isActive: true,
          addedById: userId
        });
        return res.status(201).json({
          message: "Stream URLs created automatically",
          stream: newStream,
          homeTeam: game.homeTeam.name,
          awayTeam: game.awayTeam.name
        });
      }
    } catch (error) {
      console.error("Error auto-generating stream URLs:", error);
      res.status(500).json({ message: "Failed to auto-generate stream URLs", error: String(error) });
    }
  });
  app2.post("/api/admin/auto-generate-all-streams", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const allGames = await getAllGames(void 0, true);
      if (!allGames || allGames.length === 0) {
        return res.status(404).json({ message: "No games found to create streams for" });
      }
      const userId = req.user?.id;
      let successCount = 0;
      let failedCount = 0;
      for (const game of allGames) {
        try {
          if (game.state === "post") {
            const detailText = game.status?.detail || "";
            if (!detailText.includes("Postponed") && !detailText.includes("Delayed")) {
              continue;
            }
          }
          const { homeTeamStreamUrl, awayTeamStreamUrl } = getStreamUrlsForGame(game);
          const existingStream = await storage.getStreamByGameId(game.id);
          if (existingStream) {
            if (homeTeamStreamUrl || awayTeamStreamUrl) {
              await storage.updateStream(existingStream.id, {
                streamUrl: homeTeamStreamUrl || existingStream.streamUrl,
                awayStreamUrl: awayTeamStreamUrl || existingStream.awayStreamUrl
              });
              successCount++;
            }
          } else {
            if (homeTeamStreamUrl || awayTeamStreamUrl) {
              await storage.createStream({
                gameId: game.id,
                streamUrl: homeTeamStreamUrl || "",
                awayStreamUrl: awayTeamStreamUrl || null,
                isActive: true,
                addedById: userId
              });
              successCount++;
            }
          }
        } catch (error) {
          console.error(`Error processing game ${game.id}:`, error);
          failedCount++;
        }
      }
      let cleanupCount = 0;
      try {
        const allStreams = await storage.getAllStreams();
        const currentGameIds = new Set(allGames.map((game) => game.id));
        const now = /* @__PURE__ */ new Date();
        for (const stream of allStreams) {
          try {
            if (!currentGameIds.has(stream.gameId)) {
              const gameData = await getGameById(stream.gameId);
              if (gameData) {
                const gameDate = new Date(gameData.date);
                const daysSinceGame = Math.floor((now.getTime() - gameDate.getTime()) / (1e3 * 60 * 60 * 24));
                if (gameData.state === "post" && daysSinceGame > 2) {
                  const gameDetailText = gameData.status?.detail || "";
                  if (!gameDetailText.includes("Postponed") && !gameDetailText.includes("Delayed")) {
                    await storage.deleteStream(stream.id);
                    cleanupCount++;
                  }
                }
              } else {
                await storage.deleteStream(stream.id);
                cleanupCount++;
              }
            }
          } catch (error) {
            console.error(`Error cleaning up stream ${stream.id}:`, error);
          }
        }
      } catch (error) {
        console.error("Error during stream cleanup:", error);
      }
      return res.status(200).json({
        message: "Auto-generation of stream URLs completed with cleanup",
        results: {
          totalGames: allGames.length,
          success: successCount,
          failed: failedCount,
          cleanedUp: cleanupCount
        }
      });
    } catch (error) {
      console.error("Error in auto-generate-all-streams:", error);
      res.status(500).json({ message: "Failed to auto-generate stream URLs", error: String(error) });
    }
  });
  app2.get("/api/admin/users", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const users2 = await storage.getAllUsers();
      res.json(users2);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.get("/api/admin/stream-mappings", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { getDeduplicatedTeamMappings } = __require("./centralizedStreamManager");
      const streamMappings = await getDeduplicatedTeamMappings();
      res.json(streamMappings);
    } catch (error) {
      console.error("Error fetching stream mappings:", error);
      res.status(500).json({ message: "Failed to fetch stream mappings" });
    }
  });
  app2.delete("/api/admin/users/:userId", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const adminUserId = req.user?.id;
      const targetUser = await storage.getUserById(userId);
      if (!targetUser) {
        return res.status(404).json({ error: "User not found" });
      }
      if (userId === adminUserId) {
        return res.status(400).json({ error: "Cannot delete your own admin account" });
      }
      try {
        const userSubscriptions = await storage.getSubscriptionsByUserId?.(userId);
        if (userSubscriptions) {
          for (const subscription of userSubscriptions) {
            await storage.deleteSubscription(subscription.id);
          }
        }
      } catch (subError) {
        console.log("No subscriptions to delete for user:", userId);
      }
      try {
        await storage.deleteUserAlerts?.(userId);
      } catch (alertError) {
        console.log("No alerts to delete for user:", userId);
      }
      await storage.deleteUser(userId);
      return res.json({
        success: true,
        message: `User ${targetUser.email || targetUser.firstName || "Unknown"} permanently deleted from database`,
        deletedUserId: userId
      });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ error: error.message || "Failed to delete user from database" });
    }
  });
  app2.delete("/api/admin/users/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      if (!id) {
        return res.status(400).json({ message: "User ID is required" });
      }
      console.log(`[USER DELETION] Admin initiated deletion of user ID: ${id}`);
      const userToDelete = await storage.getUser(id);
      if (!userToDelete) {
        return res.status(404).json({ message: "User not found" });
      }
      console.log(`[USER DELETION] Deleting user: ${userToDelete.email}`);
      try {
        await storage.deleteSubscriptionsByUserId(id);
        console.log(`[USER DELETION] Removed user subscriptions: ${id}`);
      } catch (subError) {
        console.error(`[USER DELETION] Error removing subscriptions:`, subError);
      }
      await storage.deleteUser(id);
      console.log(`[USER DELETION] Removed user from application database: ${id}`);
      try {
        if (process.env.DATABASE_URL) {
          console.log(`[USER DELETION] Using direct database connection for user ${id}`);
          const { Pool } = __require("pg");
          const pool = new Pool({
            connectionString: process.env.DATABASE_URL,
            ssl: { rejectUnauthorized: false }
          });
          await pool.query("DELETE FROM auth.users WHERE id = $1", [id]);
          await pool.end();
          console.log(`[USER DELETION] Successfully deleted user from Supabase database using direct SQL: ${id}`);
        } else {
          try {
            const { error } = await supabaseClient.auth.admin.deleteUser(id);
            if (error) {
              console.error(`[USER DELETION] Supabase auth deletion error:`, error);
            } else {
              console.log(`[USER DELETION] Successfully deleted user from Supabase Auth: ${id}`);
            }
          } catch (authError) {
            console.error(`[USER DELETION] Supabase auth API error:`, authError);
          }
        }
      } catch (sqlError) {
        console.error(`[USER DELETION] SQL deletion error:`, sqlError);
      }
      return res.status(200).json({
        message: `User ${userToDelete.email} has been deleted successfully`,
        success: true
      });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user", error: String(error) });
    }
  });
  app2.get("/api/admin/users/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.put("/api/admin/users/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { firstName, lastName, email, isAdmin: setAdmin } = req.body;
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const updatedUser = await storage.updateUser(id, {
        firstName: firstName || existingUser.firstName,
        lastName: lastName || existingUser.lastName,
        email: email || existingUser.email,
        isAdmin: setAdmin !== void 0 ? setAdmin : existingUser.isAdmin
      });
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });
  app2.get("/api/admin/subscription-plans", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const plans = await storage.getAllSubscriptionPlans();
      res.json(plans);
    } catch (error) {
      console.error("Error fetching subscription plans:", error);
      res.status(500).json({ message: "Failed to fetch subscription plans" });
    }
  });
  app2.post("/api/admin/subscription-plans", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { name, price, description, durationDays, features } = req.body;
      if (!name || !price || !durationDays) {
        return res.status(400).json({ message: "Name, price and duration are required" });
      }
      const plan = await storage.createSubscriptionPlan({
        name,
        price: parseInt(price),
        description,
        durationDays: parseInt(durationDays),
        features: features || []
      });
      res.status(201).json(plan);
    } catch (error) {
      console.error("Error creating subscription plan:", error);
      res.status(500).json({ message: "Failed to create subscription plan" });
    }
  });
  app2.put("/api/admin/subscription-plans/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, price, description, durationDays, features } = req.body;
      const plan = await storage.updateSubscriptionPlan(parseInt(id), {
        name,
        price: price ? parseInt(price) : void 0,
        description,
        durationDays: durationDays ? parseInt(durationDays) : void 0,
        features
      });
      res.json(plan);
    } catch (error) {
      console.error("Error updating subscription plan:", error);
      res.status(500).json({ message: "Failed to update subscription plan" });
    }
  });
  app2.delete("/api/admin/subscription-plans/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteSubscriptionPlan(parseInt(id));
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting subscription plan:", error);
      res.status(500).json({ message: "Failed to delete subscription plan" });
    }
  });
  app2.get("/api/admin/subscriptions", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const subscriptions2 = await storage.getAllSubscriptions();
      res.json(subscriptions2);
    } catch (error) {
      console.error("Error fetching subscriptions:", error);
      res.status(500).json({ message: "Failed to fetch subscriptions" });
    }
  });
  app2.put("/api/admin/subscriptions/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive, endDate } = req.body;
      const subscription = await storage.adminUpdateSubscription(parseInt(id), {
        isActive: isActive !== void 0 ? Boolean(isActive) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      res.json(subscription);
    } catch (error) {
      console.error("Error updating subscription:", error);
      res.status(500).json({ message: "Failed to update subscription" });
    }
  });
  app2.get("/api/subscription-plans", async (req, res) => {
    try {
      const plans = await storage.getAllSubscriptionPlans();
      res.json(plans);
    } catch (error) {
      console.error("Error fetching subscription plans:", error);
      res.status(500).json({ message: "Failed to fetch subscription plans" });
    }
  });
  app2.get("/api/subscription", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      const subscription = await storage.getSubscriptionByUserId(userId);
      res.json(subscription || null);
    } catch (error) {
      console.error("Error fetching subscription:", error);
      res.status(500).json({ message: "Failed to fetch subscription" });
    }
  });
  app2.get("/api/subscription/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      const subscription = await storage.getSubscriptionByUserId(userId);
      const hasActiveSubscription = subscription && subscription.isActive && new Date(subscription.endDate) > /* @__PURE__ */ new Date();
      return res.json({
        hasActiveSubscription,
        subscription: subscription || null
      });
    } catch (error) {
      console.error("Error checking subscription status:", error);
      res.status(500).json({
        message: "Failed to check subscription status",
        hasActiveSubscription: false
      });
    }
  });
  app2.post("/api/subscription", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      const { planId } = req.body;
      if (!planId) {
        return res.status(400).json({ message: "Plan ID is required" });
      }
      const plans = await storage.getAllSubscriptionPlans();
      const selectedPlan = plans.find((plan) => plan.id === parseInt(planId));
      if (!selectedPlan) {
        return res.status(404).json({ message: "Subscription plan not found" });
      }
      console.log("DEVELOPMENT MODE: Auto-approving subscription without payment processing");
      const startDate = /* @__PURE__ */ new Date();
      const endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + selectedPlan.durationDays);
      const existingSubscription = await storage.getSubscriptionByUserId(userId);
      let subscription;
      if (existingSubscription) {
        await storage.adminUpdateSubscription(existingSubscription.id, {
          isActive: true,
          endDate
        });
        subscription = await storage.getSubscriptionByUserId(userId);
      } else {
        const subscriptionData = insertSubscriptionSchema.parse({
          userId,
          planId: parseInt(planId),
          startDate,
          endDate,
          isActive: true
        });
        subscription = await storage.createSubscription(subscriptionData);
      }
      res.status(201).json(subscription);
    } catch (error) {
      console.error("Error creating subscription:", error);
      res.status(500).json({ message: "Failed to create subscription" });
    }
  });
  app2.post("/api/subscription/cancel", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      const subscription = await storage.getSubscriptionByUserId(userId);
      if (!subscription) {
        return res.status(404).json({ message: "No active subscription found" });
      }
      await storage.cancelSubscription(subscription.id);
      res.status(200).json({ message: "Subscription canceled successfully" });
    } catch (error) {
      console.error("Error canceling subscription:", error);
      res.status(500).json({ message: "Failed to cancel subscription" });
    }
  });
  app2.post("/api/admin/auto-generate-all-streams", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const today = /* @__PURE__ */ new Date();
      const allGames = await getAllGames(today);
      if (!allGames || allGames.length === 0) {
        return res.status(404).json({
          message: "No games found for today",
          date: today.toISOString()
        });
      }
      const results = {
        totalGames: allGames.length,
        success: 0,
        failed: 0,
        gamesProcessed: []
      };
      const userId = req.user?.id;
      for (const game of allGames) {
        try {
          const { homeTeamStreamUrl, awayTeamStreamUrl } = getStreamUrlsForGame(game);
          const streamsFound = !!homeTeamStreamUrl || !!awayTeamStreamUrl;
          const existingStream = await storage.getStreamByGameId(game.id);
          let streamResult;
          if (existingStream) {
            if (streamsFound) {
              streamResult = await storage.updateStream(existingStream.id, {
                streamUrl: homeTeamStreamUrl || existingStream.streamUrl,
                awayStreamUrl: awayTeamStreamUrl || existingStream.awayStreamUrl
              });
            } else {
              streamResult = existingStream;
            }
          } else if (streamsFound) {
            streamResult = await storage.createStream({
              gameId: game.id,
              streamUrl: homeTeamStreamUrl || "",
              awayStreamUrl: awayTeamStreamUrl || null,
              isActive: true,
              addedById: userId
            });
          }
          results.gamesProcessed.push({
            id: game.id,
            name: game.name,
            homeTeam: game.homeTeam.name,
            awayTeam: game.awayTeam.name,
            homeStreamFound: !!homeTeamStreamUrl,
            awayStreamFound: !!awayTeamStreamUrl,
            status: streamResult ? "success" : "no_streams_found"
          });
          if (streamResult) {
            results.success++;
          } else {
            results.failed++;
          }
        } catch (error) {
          console.error(`Error processing game ${game.id}:`, error);
          results.failed++;
          results.gamesProcessed.push({
            id: game.id,
            name: game.name,
            status: "error",
            error: String(error)
          });
        }
      }
      return res.json({
        message: `Processed ${results.totalGames} games: ${results.success} succeeded, ${results.failed} failed`,
        results
      });
    } catch (error) {
      console.error("Error auto-generating all stream URLs:", error);
      return res.status(500).json({
        message: "Failed to auto-generate stream URLs",
        error: String(error)
      });
    }
  });
  app2.post("/api/auto-update-streams", async (req, res) => {
    try {
      const apiKey = req.headers["x-api-key"];
      if (apiKey !== process.env.AUTO_UPDATE_API_KEY) {
        return res.status(401).json({ message: "Invalid API key" });
      }
      const today = /* @__PURE__ */ new Date();
      const allGames = await getAllGames(today);
      if (!allGames || allGames.length === 0) {
        return res.status(404).json({
          message: "No games found for today",
          date: today.toISOString()
        });
      }
      const results = {
        totalGames: allGames.length,
        success: 0,
        failed: 0,
        created: 0,
        updated: 0,
        unchanged: 0
      };
      for (const game of allGames) {
        try {
          const { homeTeamStreamUrl, awayTeamStreamUrl } = getStreamUrlsForGame(game);
          const streamsFound = !!homeTeamStreamUrl || !!awayTeamStreamUrl;
          const existingStream = await storage.getStreamByGameId(game.id);
          if (existingStream) {
            if (streamsFound) {
              const needsUpdate = homeTeamStreamUrl && homeTeamStreamUrl !== existingStream.streamUrl || awayTeamStreamUrl && awayTeamStreamUrl !== existingStream.awayStreamUrl;
              if (needsUpdate) {
                await storage.updateStream(existingStream.id, {
                  streamUrl: homeTeamStreamUrl || existingStream.streamUrl,
                  awayStreamUrl: awayTeamStreamUrl || existingStream.awayStreamUrl
                });
                results.updated++;
              } else {
                results.unchanged++;
              }
            } else {
              results.unchanged++;
            }
          } else if (streamsFound) {
            await storage.createStream({
              gameId: game.id,
              streamUrl: homeTeamStreamUrl || "",
              awayStreamUrl: awayTeamStreamUrl || null,
              isActive: true,
              // Use the first admin user ID as creator
              addedById: "system-auto-update"
            });
            results.created++;
          } else {
            results.unchanged++;
          }
          results.success++;
        } catch (error) {
          console.error(`Error processing game ${game.id}:`, error);
          results.failed++;
        }
      }
      return res.json({
        message: `Auto-update complete. Processed ${results.totalGames} games.`,
        stats: `${results.created} created, ${results.updated} updated, ${results.unchanged} unchanged, ${results.failed} failed.`,
        results
      });
    } catch (error) {
      console.error("Error in auto-update streams:", error);
      return res.status(500).json({
        message: "Failed to auto-update streams",
        error: String(error)
      });
    }
  });
  app2.post("/api/email/welcome", (req, res) => {
    try {
      const { email, displayName } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      handleWelcomeEmail(email, displayName || email.split("@")[0]).then((result) => {
        if (result.success) {
          return res.json({ success: true, message: "Welcome email sent successfully" });
        } else {
          return res.status(500).json({ error: "Failed to send welcome email", details: result.error });
        }
      }).catch((error) => {
        console.error("Error sending welcome email:", error);
        return res.status(500).json({ error: "Failed to send welcome email" });
      });
    } catch (error) {
      console.error("Error in welcome email endpoint:", error);
      return res.status(500).json({ error: "Failed to process welcome email request" });
    }
  });
  app2.post("/api/email/subscription-expiration", isAuthenticated, (req, res) => {
    try {
      const { email, displayName, daysRemaining } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      if (!daysRemaining || isNaN(daysRemaining)) {
        return res.status(400).json({ error: "Valid daysRemaining is required" });
      }
      const targetEmail = email || req.user.email;
      const targetName = displayName || req.user.firstName || req.user.email;
      const { handleSubscriptionExpirationEmail: handleSubscriptionExpirationEmail3 } = (init_emailService(), __toCommonJS(emailService_exports));
      handleSubscriptionExpirationEmail3(targetEmail, targetName, daysRemaining).then((result) => {
        if (result.success) {
          return res.json({ success: true, message: "Subscription expiration email sent successfully" });
        } else {
          return res.status(500).json({ error: "Failed to send subscription expiration email", details: result.error });
        }
      }).catch((error) => {
        console.error("Error sending subscription expiration email:", error);
        return res.status(500).json({ error: "Failed to send subscription expiration email" });
      });
    } catch (error) {
      console.error("Error in subscription expiration email endpoint:", error);
      return res.status(500).json({ error: "Failed to process subscription expiration email request" });
    }
  });
  app2.post("/api/email/game-alert", isAuthenticated, async (req, res) => {
    try {
      console.log("\u{1F6A8} OLD ROUTE HIT: Redirecting /api/email/game-alert to scheduler");
      const { email, displayName, gameDetails } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      if (!gameDetails || !gameDetails.homeTeam || !gameDetails.awayTeam || !gameDetails.time || !gameDetails.league) {
        return res.status(400).json({ error: "Complete game details are required" });
      }
      const { alertScheduler: alertScheduler2 } = await Promise.resolve().then(() => (init_alertScheduler(), alertScheduler_exports));
      const gameTime = new Date(gameDetails.time);
      const targetEmail = email || req.user.email;
      const notifyMinutesBefore = 30;
      try {
        console.log("\u{1F4C5} SCHEDULER: Scheduling alert via old route for:", { gameId: gameDetails.gameId, email: targetEmail, notifyMinutesBefore, gameTime });
        const alertId = alertScheduler2.scheduleAlert(gameDetails.gameId || "unknown", targetEmail, notifyMinutesBefore, gameTime);
        console.log("\u{1F4C5} SCHEDULER: Alert scheduled successfully with ID:", alertId);
        return res.json({
          success: true,
          message: `Alert scheduled! You'll be notified ${notifyMinutesBefore} minutes before the game starts.`,
          alertId
        });
      } catch (schedulingError) {
        console.log("\u{1F4C5} SCHEDULER ERROR via old route:", schedulingError.message);
        return res.status(400).json({
          success: false,
          message: schedulingError.message || "Failed to schedule alert"
        });
      }
    } catch (error) {
      console.error("Error in game alert email endpoint:", error);
      return res.status(500).json({ error: "Failed to process game alert email request" });
    }
  });
  app2.post("/api/admin/email/test", isAuthenticated, isAdmin, (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const { handleTestEmail } = (init_emailService(), __toCommonJS(emailService_exports));
      handleTestEmail(email).then((result) => {
        if (result.success) {
          return res.json({ success: true, message: "Test email sent successfully" });
        } else {
          return res.status(500).json({ error: "Failed to send test email", details: result.error });
        }
      }).catch((error) => {
        console.error("Error sending test email:", error);
        return res.status(500).json({ error: "Failed to send test email" });
      });
    } catch (error) {
      console.error("Error in test email endpoint:", error);
      return res.status(500).json({ error: "Failed to process test email request" });
    }
  });
  app2.post("/api/create-checkout-session", isAuthenticated, async (req, res) => {
    try {
      const { planId } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      if (!planId) {
        return res.status(400).json({ message: "Plan ID is required" });
      }
      const baseUrl = req.headers.origin || "http://localhost:5000";
      const successUrl = `${baseUrl}/payment-success?session_id={CHECKOUT_SESSION_ID}`;
      const cancelUrl = `${baseUrl}/pricing?canceled=true`;
      const session2 = { success: false, message: "Checkout system not available" };
      res.json({
        url: session2.url,
        sessionId: session2.sessionId
      });
    } catch (error) {
      console.error("Error creating checkout session:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/create-subscription", isAuthenticated, async (req, res) => {
    try {
      const { planId, amount } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      if (!planId || !amount) {
        return res.status(400).json({ message: "Missing required parameters" });
      }
      const result = { success: false, message: "Subscription system not available" };
      res.json({ clientSecret: result.clientSecret });
    } catch (error) {
      console.error("Error creating subscription:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/process-payment", isAuthenticated, async (req, res) => {
    try {
      const { paymentMethodId, planId, amount } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!paymentMethodId || !planId || !amount) {
        return res.status(400).json({ error: "Missing required parameters" });
      }
      const plan = await storage.getSubscriptionPlanById(planId);
      if (!plan) {
        return res.status(404).json({ error: "Plan not found" });
      }
      const { default: Stripe } = await import("stripe");
      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || "");
      try {
        const paymentIntent = await stripe.paymentIntents.create({
          amount,
          currency: "usd",
          payment_method: paymentMethodId,
          confirm: true,
          // Confirm the payment immediately
          description: `VeloPlay Subscription - ${plan.name}`,
          automatic_payment_methods: {
            enabled: true,
            allow_redirects: "always"
          },
          return_url: `${req.protocol}://${req.get("host")}/payment-success`,
          metadata: {
            userId,
            planId: planId.toString()
          }
        });
        if (paymentIntent.status === "succeeded") {
          return res.json({ success: true, paymentIntentId: paymentIntent.id });
        } else if (paymentIntent.status === "requires_action") {
          return res.json({
            requires_action: true,
            clientSecret: paymentIntent.client_secret,
            paymentIntentId: paymentIntent.id
          });
        } else {
          return res.status(400).json({ error: `Payment failed with status: ${paymentIntent.status}` });
        }
      } catch (stripeError) {
        console.error("Stripe error:", stripeError);
        return res.status(400).json({ error: stripeError.message });
      }
    } catch (error) {
      console.error("Error processing payment:", error);
      res.status(500).json({ error: error.message || "An unexpected error occurred" });
    }
  });
  app2.post("/api/activate-subscription", isAuthenticated, async (req, res) => {
    try {
      const { planId } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!planId) {
        return res.status(400).json({ error: "Missing plan ID" });
      }
      const plan = await storage.getSubscriptionPlanById(planId);
      if (!plan) {
        return res.status(404).json({ error: "Plan not found" });
      }
      const startDate = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(startDate.getDate() + plan.durationDays);
      const subscription = await storage.createSubscription({
        userId,
        planId,
        startDate,
        endDate,
        isActive: true
      });
      return res.json({ success: true, subscription });
    } catch (error) {
      console.error("Error activating subscription:", error);
      res.status(500).json({ error: error.message || "Failed to activate subscription" });
    }
  });
  app2.post("/api/admin-activate-subscription", isAuthenticated, async (req, res) => {
    try {
      const { planId, activationCode } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!planId) {
        return res.status(400).json({ error: "Missing plan ID" });
      }
      if (activationCode !== "VELOPLAY-ADMIN") {
        return res.status(403).json({ error: "Invalid activation code" });
      }
      const plan = await storage.getSubscriptionPlanById(planId);
      if (!plan) {
        return res.status(404).json({ error: "Plan not found" });
      }
      const existingSubscription = await storage.getSubscriptionByUserId(userId);
      if (existingSubscription && existingSubscription.isActive) {
        const endDate2 = /* @__PURE__ */ new Date();
        endDate2.setDate(endDate2.getDate() + plan.durationDays);
        const updatedSubscription = await storage.updateSubscription(existingSubscription.id, {
          planId,
          endDate: endDate2,
          isActive: true
        });
        return res.json({
          success: true,
          subscription: updatedSubscription,
          message: "Existing subscription updated"
        });
      }
      const startDate = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(startDate.getDate() + plan.durationDays);
      const subscription = await storage.createSubscription({
        userId,
        planId,
        startDate,
        endDate,
        isActive: true
      });
      return res.json({
        success: true,
        subscription,
        message: "Subscription activated successfully"
      });
    } catch (error) {
      console.error("Error activating admin subscription:", error);
      res.status(500).json({ error: error.message || "Failed to activate subscription" });
    }
  });
  app2.post("/api/admin/users/:userId/subscription", isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const { planId, extensionDays, action } = req.body;
      const adminUserId = req.user?.id;
      const adminUser = await storage.getUserById(adminUserId);
      if (!adminUser || adminUser.email !== "main@admin.com") {
        return res.status(403).json({ error: "Admin access required" });
      }
      if (action === "grant" && planId) {
        const plan = await storage.getSubscriptionPlanById(planId);
        if (!plan) {
          return res.status(404).json({ error: "Plan not found" });
        }
        const existingSubscription = await storage.getSubscriptionByUserId(userId);
        if (existingSubscription && existingSubscription.isActive) {
          const endDate = /* @__PURE__ */ new Date();
          endDate.setDate(endDate.getDate() + plan.durationDays);
          const updatedSubscription = await storage.updateSubscriptionPlan(existingSubscription.id, {
            planId,
            endDate,
            isActive: true
          });
          return res.json({
            success: true,
            subscription: updatedSubscription,
            message: `Updated to ${plan.name} plan`
          });
        } else {
          const startDate = /* @__PURE__ */ new Date();
          const endDate = /* @__PURE__ */ new Date();
          endDate.setDate(startDate.getDate() + plan.durationDays);
          const subscription = await storage.createSubscription({
            userId,
            planId,
            startDate,
            endDate,
            isActive: true
          });
          return res.json({
            success: true,
            subscription,
            message: `Granted ${plan.name} plan`
          });
        }
      } else if (action === "extend" && extensionDays) {
        const existingSubscription = await storage.getSubscriptionByUserId(userId);
        if (!existingSubscription) {
          return res.status(404).json({ error: "No subscription found to extend" });
        }
        const currentEndDate = new Date(existingSubscription.endDate);
        const newEndDate = new Date(currentEndDate);
        newEndDate.setDate(currentEndDate.getDate() + parseInt(extensionDays));
        const updatedSubscription = await storage.updateSubscriptionPlan(existingSubscription.id, {
          endDate: newEndDate,
          isActive: true
        });
        return res.json({
          success: true,
          subscription: updatedSubscription,
          message: `Extended subscription by ${extensionDays} days`
        });
      } else if (action === "revoke") {
        const existingSubscription = await storage.getSubscriptionByUserId(userId);
        if (!existingSubscription) {
          return res.status(404).json({ error: "No subscription found to revoke" });
        }
        const updatedSubscription = await storage.updateSubscriptionPlan(existingSubscription.id, {
          isActive: false,
          endDate: /* @__PURE__ */ new Date()
          // Set end date to now
        });
        return res.json({
          success: true,
          subscription: updatedSubscription,
          message: "Subscription revoked"
        });
      } else {
        return res.status(400).json({ error: "Invalid action or missing parameters" });
      }
    } catch (error) {
      console.error("Error managing user subscription:", error);
      res.status(500).json({ error: error.message || "Failed to manage subscription" });
    }
  });
  app2.post("/api/admin/users/:userId/reset-password", isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const adminUserId = req.user?.id;
      const adminUser = await storage.getUserById(adminUserId);
      if (!adminUser || adminUser.email !== "main@admin.com") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const targetUser = await storage.getUserById(userId);
      if (!targetUser) {
        return res.status(404).json({ error: "User not found" });
      }
      try {
        const response = await fetch3("/api/send-password-reset", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            email: targetUser.email,
            isAdminReset: true
          })
        });
        if (response.ok) {
          return res.json({
            success: true,
            message: `Password reset email sent to ${targetUser.email}`
          });
        } else {
          throw new Error("Failed to send reset email");
        }
      } catch (emailError) {
        console.error("Error sending password reset email:", emailError);
        return res.status(500).json({ error: "Failed to send password reset email" });
      }
    } catch (error) {
      console.error("Error resetting user password:", error);
      res.status(500).json({ error: error.message || "Failed to reset password" });
    }
  });
  app2.post("/api/confirm-payment", isAuthenticated, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!paymentIntentId) {
        return res.status(400).json({ error: "Missing payment intent ID" });
      }
      const { default: Stripe } = await import("stripe");
      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || "");
      try {
        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        if (paymentIntent.metadata.userId !== userId) {
          return res.status(403).json({ error: "Payment intent does not belong to this user" });
        }
        if (paymentIntent.status !== "succeeded") {
          if (paymentIntent.status === "requires_capture") {
            await stripe.paymentIntents.capture(paymentIntentId);
          } else {
            return res.status(400).json({ error: `Payment is not successful: ${paymentIntent.status}` });
          }
        }
        return res.json({ success: true });
      } catch (stripeError) {
        console.error("Stripe error during confirmation:", stripeError);
        return res.status(400).json({ error: stripeError.message });
      }
    } catch (error) {
      console.error("Error confirming payment:", error);
      res.status(500).json({ error: error.message || "Failed to confirm payment" });
    }
  });
  app2.post("/api/verify-payment", isAuthenticated, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      if (!paymentIntentId) {
        return res.status(400).json({
          success: false,
          message: "Missing payment_intent parameter"
        });
      }
      const result = { success: false, message: "Payment system not available" };
      res.json(result);
    } catch (error) {
      console.error("Error verifying payment:", error);
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  });
  app2.post("/api/webhook/stripe", express3.raw({ type: "application/json" }), async (req, res) => {
    try {
      const signature = req.headers["stripe-signature"];
      if (!signature) {
        return res.status(400).json({ message: "Missing stripe-signature header" });
      }
      const result = { success: false, message: "Stripe webhooks not available" };
      res.json(result);
    } catch (error) {
      console.error("Error processing webhook:", error);
      res.status(400).json({ message: error.message });
    }
  });
  app2.get("/auth/callback", (req, res) => {
    try {
      const { code } = req.query;
      if (!code) {
        return res.redirect("/login?error=missing_code");
      }
      console.log(`Auth callback received with code: ${String(code).substring(0, 5)}...`);
      res.redirect(`/auth-callback?code=${code}`);
    } catch (error) {
      console.error("Auth callback error:", error.message);
      res.redirect("/login?error=verification_failed");
    }
  });
  app2.get("/api/game-alerts", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const alerts = await storage.getGameAlertsByUserId(userId);
      return res.json(alerts);
    } catch (error) {
      console.error("Error fetching game alerts:", error);
      return res.status(500).json({ error: "Failed to fetch game alerts" });
    }
  });
  app2.get("/api/game-alerts/:gameId", async (req, res) => {
    try {
      const userId = req.session?.passport?.user || "e72ece9e-11e3-452b-ab22-e0a4c52facb0";
      const gameId = req.params.gameId;
      console.log("\u{1F50D} Checking alert for user:", userId, "game:", gameId);
      const alert = await storage.getGameAlertByUserAndGame(userId, gameId);
      console.log("\u{1F3AF} Alert found:", alert);
      return res.json({ exists: !!alert, alert: alert || null });
    } catch (error) {
      console.error("Error checking game alert:", error);
      return res.status(500).json({ error: "Failed to check game alert" });
    }
  });
  app2.get("/api/test-routing", (req, res) => {
    console.log("\u2705 TEST ROUTE WORKING!");
    res.json({ message: "Routing works!" });
  });
  app2.post("/api/game-alerts-temp", isAuthenticated, async (req, res) => {
    console.log("\u{1F3AF} ALERT ROUTE HIT! Request received:", req.method, req.url);
    console.log("\u{1F4E6} Request body:", req.body);
    try {
      const userId = req.user?.id;
      const { gameId, notifyMinutesBefore } = req.body;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!gameId) {
        return res.status(400).json({ error: "Game ID is required" });
      }
      console.log("\u{1F6A8} Creating game alert:", { userId, gameId, notifyMinutesBefore });
      const minutesBefore = notifyMinutesBefore || 30;
      console.log("\u{1F4CB} Checking for existing alert...");
      const existingAlert = await storage.getGameAlertByUserAndGame(userId, gameId);
      console.log("\u{1F50D} Existing alert check result:", existingAlert);
      if (existingAlert) {
        return res.status(409).json({
          message: "Alert already exists for this game",
          alert: existingAlert
        });
      }
      const newAlert = await storage.createGameAlert({
        userId,
        gameId,
        notifyMinutesBefore: minutesBefore
      });
      console.log("\u2705 Game alert created successfully:", newAlert);
      return res.status(201).json({
        message: "Game alert created successfully",
        alert: newAlert
      });
    } catch (error) {
      console.error("Error creating game alert:", error);
      return res.status(500).json({ error: "Failed to create game alert" });
    }
  });
  app2.delete("/api/game-alerts/:alertId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      const alertId = parseInt(req.params.alertId);
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      await storage.deleteGameAlert(alertId);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deleting game alert:", error);
      return res.status(500).json({ error: "Failed to delete game alert" });
    }
  });
  app2.get("/api/game-alerts/:gameId", isAuthenticated, async (req, res) => {
    try {
      const { gameId } = req.params;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({
          exists: false,
          error: "User not authenticated"
        });
      }
      const alert = await storage.getGameAlertByUserAndGame(userId, gameId);
      return res.json({
        exists: !!alert,
        alert: alert || null
      });
    } catch (error) {
      console.error("Error checking game alert:", error);
      return res.status(500).json({ error: "Failed to check game alert" });
    }
  });
  app2.delete("/api/game-alerts/:id", isAuthenticated, async (req, res) => {
    try {
      const alertId = parseInt(req.params.id);
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (isNaN(alertId)) {
        return res.status(400).json({ error: "Invalid alert ID" });
      }
      const alerts = await storage.getGameAlertsByUserId(userId);
      const userAlert = alerts.find((alert) => alert.id === alertId);
      if (!userAlert) {
        return res.status(404).json({ error: "Alert not found or does not belong to user" });
      }
      await storage.deleteGameAlert(alertId);
      return res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error deleting game alert:", error);
      return res.status(500).json({ error: "Failed to delete game alert" });
    }
  });
  app2.get("/api/game-alerts/:gameId", isAuthenticated, async (req, res) => {
    try {
      const gameId = req.params.gameId;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!gameId) {
        return res.status(400).json({ error: "Game ID is required" });
      }
      const alert = await storage.getGameAlertByUserAndGame(userId, gameId);
      if (!alert) {
        return res.status(404).json({
          exists: false,
          message: "No alert found for this game"
        });
      }
      return res.status(200).json({
        exists: true,
        alert
      });
    } catch (error) {
      console.error("Error checking game alert:", error);
      return res.status(500).json({ error: "Failed to check game alert" });
    }
  });
  app2.get("/api/user/dashboard-stats", isAuthenticated, async (req, res) => {
    try {
      console.log("\u{1F4CA} [API] Fetching user dashboard statistics");
      const supabase4 = (await Promise.resolve().then(() => (init_supabaseClient(), supabaseClient_exports))).default;
      const userId = req.user?.id;
      const { data: subscription } = await supabase4.from("subscriptions").select("*, subscription_plans(*)").eq("user_id", userId).eq("is_active", true).single();
      const { data: gameAlerts2 } = await supabase4.from("game_alerts").select("*").eq("user_id", userId).limit(10);
      const watchTime = gameAlerts2?.length ? gameAlerts2.length * 45 : 15;
      const userStats = {
        watchTime,
        favoriteTeams: gameAlerts2?.length > 0 ? ["Based on your alerts", "Game preferences"] : ["No preferences yet"],
        subscriptionStatus: subscription?.subscription_plans?.name || "Free",
        nextBilling: subscription?.end_date || null,
        alertsSet: gameAlerts2?.length || 0,
        watchHistory: gameAlerts2?.slice(0, 3).map((alert, index2) => ({
          game: `Alert ${index2 + 1}`,
          date: new Date(alert.created_at).toLocaleDateString(),
          duration: 2.5 + index2 * 0.5
        })) || []
      };
      return res.status(200).json(userStats);
    } catch (error) {
      console.error("Error fetching user dashboard stats:", error);
      return res.status(500).json({ error: "Failed to fetch user dashboard stats" });
    }
  });
  app2.get("/api/admin/dashboard-stats", isAuthenticated, isAdmin, async (req, res) => {
    try {
      console.log("\u{1F4CA} [API] Fetching dashboard statistics");
      const supabase4 = (await Promise.resolve().then(() => (init_supabaseClient(), supabaseClient_exports))).default;
      const { data: subscriptions2 } = await supabase4.from("subscriptions").select("*").eq("is_active", true);
      const { data: plans } = await supabase4.from("subscription_plans").select("*");
      const { data: users2 } = await supabase4.from("users").select("id, email, created_at");
      const activeSubscriptions = subscriptions2?.length || 0;
      const totalUsers = users2?.length || 0;
      let totalSales = 0;
      if (subscriptions2 && plans) {
        subscriptions2.forEach((sub) => {
          const plan = plans.find((p) => p.id === sub.plan_id);
          if (plan) {
            totalSales += plan.price;
          }
        });
      }
      const monthlyRevenue = [\
        { month: "Jan", revenue: 12e3 },\
        { month: "Feb", revenue: 15e3 },\
        { month: "Mar", revenue: 18e3 },\
        { month: "Apr", revenue: 22e3 },\
        { month: "May", revenue: totalSales || 25e3 }\
      ];
      const planDistribution = plans?.map((plan, index2) => ({
        name: plan.name,
        value: subscriptions2?.filter((s) => s.plan_id === plan.id).length || 0,
        color: ["#7f00ff", "#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4"][index2 % 5]
      })) || [];
      const recentActivity = [\
        {\
          id: "1",\
          type: "subscription",\
          description: "New Premium subscription activated",\
          timestamp: "2 hours ago"\
        },\
        {\
          id: "2",\
          type: "user",\
          description: "New user registered",\
          timestamp: "4 hours ago"\
        },\
        {\
          id: "3",\
          type: "payment",\
          description: "Payment processed successfully",\
          timestamp: "6 hours ago"\
        }\
      ];
      const stats = {
        totalSales,
        totalRefunds: 0,
        // Add real refund calculation if needed
        activeSubscriptions,
        onlineUsers: Math.floor(Math.random() * 50) + 10,
        // Mock online users
        totalUsers,
        monthlyRevenue,
        planDistribution,
        recentActivity
      };
      return res.status(200).json(stats);
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      return res.status(500).json({ error: "Failed to fetch dashboard statistics" });
    }
  });
  app2.get("/api/admin/stream-mappings", isAuthenticated, isAdmin, async (req, res) => {
    try {
      console.log("\u{1F3AF} [API] Fetching stream mappings for admin panel");
      const supabase4 = (await Promise.resolve().then(() => (init_supabaseClient(), supabaseClient_exports))).default;
      const { data: streamSources2, error } = await supabase4.from("stream_sources").select("*").eq("is_active", true);
      if (error) {
        console.error("Supabase error:", error);
        return res.status(500).json({ error: "Database error", details: error.message });
      }
      console.log(`\u{1F3AF} [AdminMappings] Found ${streamSources2?.length || 0} stream sources in database`);
      const teamMap = /* @__PURE__ */ new Map();
      for (const source of streamSources2 || []) {
        const teamName = source.team_name || "Unknown";
        const standardKey = teamName.toUpperCase().trim();
        if (!teamMap.has(standardKey) || teamMap.get(standardKey).team_name.length < teamName.length) {
          const urlMatch = source.url?.match(/\/(\d+)\.m3u8$/) || [];
          const streamId = urlMatch[1] ? parseInt(urlMatch[1]) : 0;
          let league = source.league_id?.toUpperCase() || "UNKNOWN";
          if (league === "AUTO-DETECTED" || league === "UNKNOWN") {
            if (streamId >= 185 && streamId <= 214) league = "MLB";
            else if (streamId >= 65 && streamId <= 95) league = "NBA";
            else if (streamId >= 219 && streamId <= 222) league = "NBA";
            else if (streamId >= 35 && streamId <= 63) league = "NFL";
            else if (streamId >= 6 && streamId <= 35) league = "NHL";
            else if (streamId >= 215 && streamId <= 218) league = "NHL";
          }
          teamMap.set(standardKey, {
            team: teamName,
            streamId,
            league,
            url: source.url || ""
          });
        }
      }
      const mappings = Array.from(teamMap.values()).sort((a, b) => a.team.localeCompare(b.team));
      console.log(`\u{1F3AF} [AdminMappings] Returning ${mappings.length} deduplicated mappings`);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching stream mappings:", error);
      res.status(500).json({ error: "Failed to fetch stream mappings", details: String(error) });
    }
  });
  app2.put("/api/admin/update-stream-url", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { teamName, newUrl } = req.body;
      if (!teamName || !newUrl) {
        return res.status(400).json({ error: "Team name and new URL are required" });
      }
      const urlMatch = newUrl.match(/\/(\d+)\.m3u8$/);
      if (!urlMatch) {
        return res.status(400).json({ error: "Invalid M3U8 URL format" });
      }
      const newStreamId = parseInt(urlMatch[1]);
      const { updateStreamUrlForTeam } = await import("./centralizedStreamManager");
      const success = await updateStreamUrlForTeam(teamName, newUrl);
      if (success) {
        console.log(`\u{1F3AF} [CentralizedUpdate] Updated ${teamName} M3U8 URL to ${newUrl} (Stream ID: ${newStreamId}) in Supabase`);
        res.json({
          success: true,
          message: `Successfully updated ${teamName} stream URL`,
          teamName,
          newUrl,
          newStreamId,
          source: "centralized_supabase"
        });
      } else {
        console.error(`\u{1F6A8} [CentralizedUpdate] Failed to update ${teamName} in Supabase`);
        res.status(500).json({
          error: `Failed to update stream URL for ${teamName}`,
          teamName
        });
      }
    } catch (error) {
      console.error("Error updating stream URL:", error);
      res.status(500).json({ error: "Failed to update stream URL" });
    }
  });
  app2.get("/api/channels", async (req, res) => {
    try {
      const channels = await storage.getNetworkChannels();
      const channelsWithUrls = channels.map((channel) => ({
        ...channel,
        streamUrl: `${STREAM_BASE_URL}${channel.id}.m3u8`
      }));
      res.json(channelsWithUrls);
    } catch (error) {
      console.error("Error fetching network channels:", error);
      res.status(500).json({ message: "Error fetching network channels" });
    }
  });
  app2.get("/api/channels/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const channel = await storage.getNetworkChannelById(id);
      if (!channel) {
        return res.status(404).json({ message: "Channel not found" });
      }
      const channelWithUrl = {
        ...channel,
        streamUrl: `${STREAM_BASE_URL}${channel.id}.m3u8`
      };
      res.json(channelWithUrl);
    } catch (error) {
      console.error("Error fetching network channel:", error);
      res.status(500).json({ message: "Error fetching network channel" });
    }
  });
  app2.post("/api/channels", isAuthenticated, async (req, res) => {
    if (!req.user?.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    try {
      const { name, icon, description, streamId, isActive, isPremium } = req.body;
      if (!name || !icon || !description || !streamId) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const newChannel = await storage.createNetworkChannel({
        id: parseInt(streamId),
        // The ID will be used as the stream ID for URL generation
        name,
        icon,
        description,
        isActive: isActive !== void 0 ? isActive : true,
        isPremium: isPremium !== void 0 ? isPremium : false
      });
      const channelWithUrl = {
        ...newChannel,
        streamUrl: `${STREAM_BASE_URL}${newChannel.id}.m3u8`
      };
      res.status(201).json(channelWithUrl);
    } catch (error) {
      console.error("Error creating network channel:", error);
      res.status(500).json({ message: "Error creating network channel" });
    }
  });
  app2.put("/api/channels/:id", isAuthenticated, async (req, res) => {
    if (!req.user?.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    try {
      const id = parseInt(req.params.id);
      const { name, icon, description, streamId, isActive, isPremium } = req.body;
      const existingChannel = await storage.getNetworkChannelById(id);
      if (!existingChannel) {
        return res.status(404).json({ message: "Channel not found" });
      }
      const updatedChannel = await storage.updateNetworkChannel(id, {
        name,
        icon,
        description,
        id: streamId ? parseInt(streamId) : void 0,
        // Allow updating the stream ID
        isActive,
        isPremium
      });
      const channelWithUrl = {
        ...updatedChannel,
        streamUrl: `${STREAM_BASE_URL}${updatedChannel.id}.m3u8`
      };
      res.json(channelWithUrl);
    } catch (error) {
      console.error("Error updating network channel:", error);
      res.status(500).json({ message: "Error updating network channel" });
    }
  });
  app2.delete("/api/channels/:id", isAuthenticated, async (req, res) => {
    if (!req.user?.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    try {
      const id = parseInt(req.params.id);
      const existingChannel = await storage.getNetworkChannelById(id);
      if (!existingChannel) {
        return res.status(404).json({ message: "Channel not found" });
      }
      await storage.deleteNetworkChannel(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting network channel:", error);
      res.status(500).json({ message: "Error deleting network channel" });
    }
  });
  app2.use("/api/stream-sources", isAuthenticated, streamSourcesRoutes);
  app2.use("/api/stream-sources/latest", streamSourcesLatestFixed_default);
  app2.use("/api/stream-url-editor", streamUrlEditor_default);
  app2.use("/api/direct-stream-url", directStreamUrl_default);
  app2.get("/api/init-stream-sources", isAuthenticated, isAdmin, async (req, res) => {
    try {
      res.redirect(307, "/api/direct-stream-url/init");
    } catch (error) {
      console.error("Error initializing stream sources:", error);
      res.status(500).json({ error: "Failed to initialize stream sources" });
    }
  });
  app2.get("/api/setup-stream-sources", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { setupStreamSourcesTable: setupStreamSourcesTable2 } = await Promise.resolve().then(() => (init_db_setup(), db_setup_exports));
      const result = await setupStreamSourcesTable2();
      res.json(result);
    } catch (error) {
      console.error("Error setting up stream sources:", error);
      res.status(500).json({ error: "Failed to setup stream sources table" });
    }
  });
  app2.use("/api", redisTest_default);
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express4 from "express";
import fs4 from "fs";
import path5 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path4 from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [\
    react(),\
    runtimeErrorOverlay(),\
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [\
      await import("@replit/vite-plugin-cartographer").then(\
        (m) => m.cartographer()\
      )\
    ] : []\
  ],
  resolve: {
    alias: {
      "@": path4.resolve(import.meta.dirname, "client", "src"),
      "@shared": path4.resolve(import.meta.dirname, "shared"),
      "@assets": path4.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path4.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path4.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path5.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs4.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path5.resolve(import.meta.dirname, "public");
  if (!fs4.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express4.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path5.resolve(distPath, "index.html"));
  });
}

// server/index.ts
init_emailService();
import dotenv2 from "dotenv";
import cors from "cors";
import session from "express-session";

// server/setupTables.ts
init_db();
async function setupRequiredTables() {
  try {
    console.log("Checking if stream_sources table exists...");
    const { data, error } = await supabase2.from("stream_sources").select("id").limit(1);
    if (error && error.code === "42P01") {
      console.log("Stream sources table does not exist. Creating it...");
      await createStreamSourcesTable2();
      await populateStreamSources2();
    } else if (error) {
      console.error("Error checking stream_sources table:", error);
    } else {
      console.log("Stream sources table already exists.");
      const { count: countResult } = await supabase2.from("stream_sources").select("*", { count: "exact", head: true });
      const count = countResult || 0;
      if (count === 0 || count < 5) {
        console.log("Stream sources table exists but is empty or has few records. Adding initial data...");
        await populateStreamSources2();
      }
    }
    await initializeLeagues2();
  } catch (error) {
    console.error("Error setting up tables:", error);
  }
}
async function initializeLeagues2() {
  try {
    console.log("Checking if leagues table exists...");
    const { data, error } = await supabase2.from("leagues").select("id").limit(1);
    if (error) {
      console.error("Error checking leagues table:", error);
      console.log("Creating leagues table with initial data...");
      const leagues2 = [\
        { id: "nba", name: "NBA", description: "National Basketball Association", is_active: true },\
        { id: "nfl", name: "NFL", description: "National Football League", is_active: true },\
        { id: "mlb", name: "MLB", description: "Major League Baseball", is_active: true },\
        { id: "nhl", name: "NHL", description: "National Hockey League", is_active: true },\
        { id: "special", name: "Special Channels", description: "Special sports channels", is_active: true }\
      ];
      const { error: insertError } = await supabase2.from("leagues").upsert(leagues2, { onConflict: "id" });
      if (insertError) {
        console.error("Error initializing leagues:", insertError);
      } else {
        console.log("Successfully initialized leagues table");
      }
    } else {
      console.log("Leagues already initialized");
    }
  } catch (error) {
    console.error("Error initializing leagues:", error);
  }
}
async function createStreamSourcesTable2() {
  try {
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS stream_sources (
        id SERIAL PRIMARY KEY,
        name VARCHAR NOT NULL,
        url TEXT NOT NULL,
        description TEXT,
        is_active BOOLEAN DEFAULT true,
        league_id VARCHAR NOT NULL,
        priority INTEGER DEFAULT 1,
        team_name VARCHAR NOT NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );

      CREATE INDEX IF NOT EXISTS idx_stream_sources_team_name ON stream_sources(team_name);
      CREATE INDEX IF NOT EXISTS idx_stream_sources_league_id ON stream_sources(league_id);
    `;
    try {
      const { error } = await supabase2.rpc("exec_sql", { query: createTableSQL });
      if (error) {
        console.error("Error creating stream_sources table with SQL RPC:", error);
        console.log("Trying to create table by inserting a test record...");
        const { error: insertError } = await supabase2.from("stream_sources").insert({
          name: "Test Source",
          url: "https://example.com/test.m3u8",
          description: "Test source for table creation",
          is_active: true,
          league_id: "test",
          priority: 1,
          team_name: "Test Team"
        });
        if (insertError && insertError.code === "42P01") {
          console.error("Could not create stream_sources table:", insertError);
          console.log("Please create the table manually in Supabase dashboard");
        } else if (insertError) {
          console.error("Error creating test record:", insertError);
        } else {
          console.log("Successfully created stream_sources table with test record");
          await supabase2.from("stream_sources").delete().eq("name", "Test Source");
        }
      } else {
        console.log("Successfully created stream_sources table with SQL RPC");
      }
    } catch (error) {
      console.error("Error during table creation attempt:", error);
    }
  } catch (error) {
    console.error("Error creating stream_sources table:", error);
  }
}
async function populateStreamSources2() {
  try {
    console.log("Populating stream_sources table with initial data...");
    const specialChannels = [\
      {\
        name: "NBA TV",\
        team_name: "NBA TV",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/1.m3u8",\
        league_id: "special",\
        is_active: true,\
        priority: 1,\
        description: "NBA TV Network"\
      },\
      {\
        name: "NFL Network",\
        team_name: "NFL Network",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/2.m3u8",\
        league_id: "special",\
        is_active: true,\
        priority: 1,\
        description: "NFL Network"\
      },\
      {\
        name: "MLB Network",\
        team_name: "MLB Network",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/3.m3u8",\
        league_id: "special",\
        is_active: true,\
        priority: 1,\
        description: "MLB Network"\
      },\
      {\
        name: "NHL Network",\
        team_name: "NHL Network",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/4.m3u8",\
        league_id: "special",\
        is_active: true,\
        priority: 1,\
        description: "NHL Network"\
      },\
      {\
        name: "ESPN",\
        team_name: "ESPN",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/5.m3u8",\
        league_id: "special",\
        is_active: true,\
        priority: 1,\
        description: "ESPN Network"\
      }\
    ];
    const { error: specialError } = await supabase2.from("stream_sources").upsert(specialChannels, { onConflict: "name,team_name" });
    if (specialError) {
      console.error("Error inserting special channels:", specialError);
    } else {
      console.log("Successfully added special channels");
    }
    const nflTeams = [\
      {\
        name: "Arizona Cardinals",\
        team_name: "Arizona Cardinals",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/66.m3u8",\
        league_id: "nfl",\
        is_active: true,\
        priority: 1,\
        description: "Arizona Cardinals"\
      },\
      {\
        name: "Atlanta Falcons",\
        team_name: "Atlanta Falcons",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/67.m3u8",\
        league_id: "nfl",\
        is_active: true,\
        priority: 1,\
        description: "Atlanta Falcons"\
      },\
      {\
        name: "Baltimore Ravens",\
        team_name: "Baltimore Ravens",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/68.m3u8",\
        league_id: "nfl",\
        is_active: true,\
        priority: 1,\
        description: "Baltimore Ravens"\
      }\
    ];
    const { error: nflError } = await supabase2.from("stream_sources").upsert(nflTeams, { onConflict: "name,team_name" });
    if (nflError) {
      console.error("Error inserting NFL teams:", nflError);
    } else {
      console.log("Successfully added NFL teams");
    }
    const nbaTeams = [\
      {\
        name: "Atlanta Hawks",\
        team_name: "Atlanta Hawks",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/98.m3u8",\
        league_id: "nba",\
        is_active: true,\
        priority: 1,\
        description: "Atlanta Hawks"\
      },\
      {\
        name: "Boston Celtics",\
        team_name: "Boston Celtics",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/99.m3u8",\
        league_id: "nba",\
        is_active: true,\
        priority: 1,\
        description: "Boston Celtics"\
      },\
      {\
        name: "Brooklyn Nets",\
        team_name: "Brooklyn Nets",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/100.m3u8",\
        league_id: "nba",\
        is_active: true,\
        priority: 1,\
        description: "Brooklyn Nets"\
      }\
    ];
    const { error: nbaError } = await supabase2.from("stream_sources").upsert(nbaTeams, { onConflict: "name,team_name" });
    if (nbaError) {
      console.error("Error inserting NBA teams:", nbaError);
    } else {
      console.log("Successfully added NBA teams");
    }
    const mlbTeams = [\
      {\
        name: "Arizona Diamondbacks",\
        team_name: "Arizona Diamondbacks",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/36.m3u8",\
        league_id: "mlb",\
        is_active: true,\
        priority: 1,\
        description: "Arizona Diamondbacks"\
      },\
      {\
        name: "Atlanta Braves",\
        team_name: "Atlanta Braves",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/37.m3u8",\
        league_id: "mlb",\
        is_active: true,\
        priority: 1,\
        description: "Atlanta Braves"\
      },\
      {\
        name: "Baltimore Orioles",\
        team_name: "Baltimore Orioles",\
        url: "https://vp.pixelsport.to:443/psportsgate/psportsgate100/38.m3u8",\
        league_id: "mlb",\
        is_active: true,\
        priority: 1,\
        description: "Baltimore Orioles"\
      }\
    ];
    const { error: mlbError } = await supabase2.from("stream_sources").upsert(mlbTeams, { onConflict: "name,team_name" });
    if (mlbError) {
      console.error("Error inserting MLB teams:", mlbError);
    } else {
      console.log("Successfully added MLB teams");
    }
    return true;
  } catch (error) {
    console.error("Error populating stream_sources:", error);
    return false;
  }
}

// server/gameAlertScheduler.ts
init_emailService();
init_espnApi();
var processedAlerts = /* @__PURE__ */ new Set();
function startGameAlertScheduler() {
  console.log("\u{1F6A8} Starting game alert scheduler...");
  const interval = setInterval(async () => {
    try {
      await checkAndSendGameAlerts();
    } catch (error) {
      console.error("Error in game alert scheduler:", error);
    }
  }, 6e4);
  console.log("\u2705 Game alert scheduler started - checking every minute");
  return () => {
    clearInterval(interval);
    console.log("Game alert scheduler stopped");
  };
}
async function checkAndSendGameAlerts() {
  try {
    const { createClient: createClient5 } = await import("@supabase/supabase-js");
    const supabaseClient2 = createClient5(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY
    );
    const { data: alerts, error } = await supabaseClient2.from("game_alerts").select("*").eq("is_notified", false);
    if (error) {
      console.error("Error fetching game alerts:", error);
      return;
    }
    if (!alerts || alerts.length === 0) {
      return;
    }
    console.log(`\u{1F4CB} Checking ${alerts.length} pending game alerts...`);
    for (const alert of alerts) {
      if (processedAlerts.has(alert.id)) {
        continue;
      }
      try {
        const game = await getGameById(alert.game_id);
        if (!game) {
          console.warn(`\u26A0\uFE0F Game ${alert.game_id} not found for alert ${alert.id}`);
          continue;
        }
        const gameTime = new Date(game.date);
        const now = /* @__PURE__ */ new Date();
        const minutesUntilGame = Math.floor((gameTime.getTime() - now.getTime()) / (1e3 * 60));
        console.log(`\u{1F3AE} Alert ${alert.id}: Game ${game.shortName} starts in ${minutesUntilGame} minutes (alert set for ${alert.notify_minutes_before} minutes before)`);
        if (minutesUntilGame <= alert.notify_minutes_before && minutesUntilGame > 0) {
          const { data: userProfile, error: userError } = await supabaseClient2.from("users").select("email").eq("id", alert.user_id).single();
          if (userError || !userProfile?.email) {
            console.error(`\u274C Could not find email for user ${alert.user_id}:`, userError);
            console.log(`\u{1F9F9} Removing orphaned alert ${alert.id} for non-existent user ${alert.user_id}`);
            await supabaseClient2.from("game_alerts").delete().eq("id", alert.id);
            processedAlerts.add(alert.id);
            continue;
          }
          const userEmail = userProfile.email;
          console.log(`\u{1F4E7} Sending game alert to ${userEmail} for ${game.shortName}`);
          const success = await sendGameAlert({
            email: userEmail,
            gameId: alert.game_id,
            gameName: `${game.awayTeam.name} vs ${game.homeTeam.name}`,
            gameTime: gameTime.toLocaleString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
              hour: "numeric",
              minute: "2-digit",
              timeZoneName: "short"
            }),
            minutesRemaining: minutesUntilGame,
            teams: {
              home: game.homeTeam.name,
              away: game.awayTeam.name
            }
          });
          if (success) {
            await supabaseClient2.from("game_alerts").update({ is_notified: true }).eq("id", alert.id);
            processedAlerts.add(alert.id);
            console.log(`\u2705 Game alert sent successfully for ${game.shortName} to ${userEmail}`);
          } else {
            console.error(`\u274C Failed to send game alert for ${game.shortName} to ${userEmail}`);
          }
        } else if (minutesUntilGame <= 0) {
          console.log(`\u23F0 Game ${game.shortName} has already started, marking alert ${alert.id} as expired`);
          await supabaseClient2.from("game_alerts").update({ is_notified: true }).eq("id", alert.id);
          processedAlerts.add(alert.id);
        }
      } catch (error2) {
        console.error(`Error processing alert ${alert.id}:`, error2);
      }
    }
  } catch (error) {
    console.error("Error checking game alerts:", error);
  }
}

// server/index.ts
init_redis();
dotenv2.config();
if (!process.env.RESEND_API_KEY) {
  console.warn("\u26A0\uFE0F RESEND_API_KEY not found in environment. Email functionality will not work properly.");
} else {
  console.log("\u2705 RESEND_API_KEY is configured correctly.");
}
var app = express5();
var corsOptions = {
  origin: "*",
  // Allow ALL origins (veloplay.tv, localhost, etc.)
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "Origin", "X-Requested-With", "Accept"],
  optionsSuccessStatus: 204,
  exposedHeaders: ["Content-Length", "Content-Range"]
};
app.use(cors(corsOptions));
app.use(express5.json());
app.use(express5.urlencoded({ extended: false }));
app.use(session({
  secret: process.env.JWT_SECRET || "veloplay-session-secret",
  resave: false,
  saveUninitialized: true,
  cookie: {
    secure: process.env.NODE_ENV === "production",
    maxAge: 1e3 * 60 * 60 * 24
    // 24 hours
  }
}));
app.use((req, res, next) => {
  const start = Date.now();
  const path6 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path6.startsWith("/api")) {
      let logLine = `${req.method} ${path6} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  try {
    await setupRequiredTables();
    console.log("Database tables setup complete");
  } catch (err) {
    console.error("Error setting up database tables:", err);
  }
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  initEmailService();
  startGameAlertScheduler();
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();

```